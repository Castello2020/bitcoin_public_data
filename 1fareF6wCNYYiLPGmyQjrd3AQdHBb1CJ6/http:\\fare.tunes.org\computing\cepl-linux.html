http://fare.tunes.org/computing/cepl-linux.html
HTTP/1.1 200 OK
Date: Wed, 23 Jul 2014 16:01:47 GMT
Server: Apache/2.2.22 (Debian) PHP/5.4.4-14+deb7u8 mod_ssl/2.2.22 OpenSSL/1.0.1e
Last-Modified: Sat, 18 Jan 2014 02:30:23 GMT
ETag: "4dba2-53db8-4f03570c90dc0"
Accept-Ranges: bytes
Vary: Accept-Encoding
Content-Encoding: gzip
Connection: close
Content-Type: text/html

<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Notes pour un cours d'introduction à Linux pour le CEPL</title
>
</head
><body>
<table width="100%"><tr><td align="center" bgcolor="#FFDB31"><font size="10" face="sans-serif" color="black"><b>Notes pour un cours d'introduction à Linux pour le CEPL</b
></font
><br
/><a href="http://fare.tunes.org/">François-René Rideau</a
></td
></tr
></table
><p align="justify">
Ce cours présente les concepts de base du système Linux.
Il ne requiert aucune connaissance préalable,
mais s'adresse à des personnes ayant l'ambition
de devenir réellement maître du sujet.

</p
><p align="justify"><a href="#SECTION_0">0 Remarques préliminaires</a
><br
/><a href="#SECTION_1">1 L'architecture des ordinateurs et de Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.1">1.1 Architecture de Von Neuman</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.2">1.2 Mémoire</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.3">1.3 Architecture virtualisée</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.4">1.4 Persistence</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.5">1.5 Multiplexage des ressources</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.6">1.6 Appels systèmes</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.7">1.7 Droits d'accès</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_1.8">1.8 Niveaux d'abstraction</a
><br
/><a href="#SECTION_2">2 Le petit monde de Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.1">2.1 Le monde vu par un processus</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.2">2.2 Conventions d'usage</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.2.1">2.2.1 Paramètres de lancement d'une commande</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.2.2">2.2.2 Options</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.2.3">2.2.3 Configuration</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.2.4">2.2.4 Gestion des erreurs</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.3">2.3 L'arborescence des fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.3.1">2.3.1 Noms de fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.3.2">2.3.2 Liens durs et liens symboliques</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.3.3">2.3.3 Droits d'accès des fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.3.4">2.3.4 Organisation conventionnelle du système de fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_2.3.5">2.3.5 Trouver des fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.4">2.4 Les services en réseau</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.5">2.5 L'interface graphique X</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_2.6">2.6 Initialisation du système</a
><br
/><a href="#SECTION_3">3 Réflexes de base pour survivre</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.1">3.1 Survivre avec l'interface graphique</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.2">3.2 Savoir survivre avec la ligne de commande</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.3">3.3 Utiliser l'aide</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.4">3.4 Pour en savoir plus</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.5">3.5 Apprendre à utiliser un éditeur</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.6">3.6 Habitudes élémentaires de précaution</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_3.7">3.7 Apprendre à programmer</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_3.7.1">3.7.1 Programmation shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_3.7.2">3.7.2 Programmation de scripts</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_3.7.3">3.7.3 Langages de programmation sérieux</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_3.7.4">3.7.4 Programmation système</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_3.7.5">3.7.5 Programmation ennuyeuse</a
><br
/><a href="#SECTION_4">4 Le shell et ses amis</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.1">4.1 Shell 101</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.1.1">4.1.1 La notion de shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.1.2">4.1.2 L'offre disponible</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.1.3">4.1.3 Quel shell apprendre?</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.1.4">4.1.4 Principe de base du shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.1.5">4.1.5 Vos premières commandes</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.2">4.2 Interaction avec le Shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.2.1">4.2.1 Édition de ligne avec le shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.2.2">4.2.2 Le shell en mode EMACS</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.2.3">4.2.3 La complétion</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.2.4">4.2.4 Le terminal sans éditeur</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.3">4.3 Commandes simples</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.3.1">4.3.1 Invocation d'une commande</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.3.2">4.3.2 Commandes pour s'en sortir avec les fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.3.3">4.3.3 Conventions d'appel pour les commandes</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.4">4.4 Expansion des commandes par le shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.1">4.4.1 Variables</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.2">4.4.2 Échappements et guillemets</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.3">4.4.3 Chemins d'accès</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.4">4.4.4 Globbing</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.5">4.4.5 Backquote</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.6">4.4.6 Calculs arithmétiques</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.7">4.4.7 Brace expansion</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.4.8">4.4.8 Alias</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.5">4.5 Commandes élaborées</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.5.1">4.5.1 Redirection</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.5.2">4.5.2 Regroupement de commandes</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.5.3">4.5.3 Structure</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.5.4">4.5.4 Fonctions et Scripts</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.5.5">4.5.5 Programmation Shell Avancée</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.6">4.6 Trucs à connaître</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.6.1">4.6.1 Job control</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.6.2">4.6.2 Noms de fichiers cachés</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.6.3">4.6.3 Noms de fichiers ressemblant à des options</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.6.4">4.6.4 Noms de fichiers difficiles à reproduire</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.7">4.7 Configuration du shell</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.8">4.8 Quelques amis du shell</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.1">4.8.1 Petits utilitaires</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.2">4.8.2 Contrôler la sortie</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.3">4.8.3 Contrôler l'entrée</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.4">4.8.4 Gérer la divergence des fichiers</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.5">4.8.5 Comprimer et Archiver</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.6">4.8.6 Vous connecter au réseau</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_4.8.7">4.8.7 Aide à l'écriture</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_4.9">4.9 Expressions régulières</a
><br
/><a href="#SECTION_5">5 Applications disponibles sous Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.1">5.1 Applicatifs les plus courants</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.2">5.2 Quel type de documents produire?</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.3">5.3 Correspondance rapide Windows vers Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.4">5.4 Correspondance rapide MacOS vers Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.5">5.5 Différences rapides entre BSD vers Linux</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_5.6">5.6 Différences rapides entre Linux et les UNIX propriétaires</a
><br
/><a href="#SECTION_6">6 Tout se complique</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.1">6.1 Disquettes, CD-ROMs, etc.</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.2">6.2 Les bibliothèques à liaison dynamiques</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.3">6.3 Gestion du temps</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.4">6.4 Les terminaux</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_6.4.1">6.4.1 Principe du terminal</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_6.4.2">6.4.2 Configuration du terminal</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_6.4.3">6.4.3 Multiplexer son terminal</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_6.4.4">6.4.4 Programmer son terminal</a
><br
/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SUBSUBSECTION_6.4.5">6.4.5 Déboguer son terminal</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.5">6.5 Connexion à distance</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.6">6.6 Administration</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.7">6.7 Impression</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.8">6.8 Compiler un programme</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_6.9">6.9 Le noyau et ses modules</a
><br
/><a href="#SECTION_7">7 Quelques Exercices</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.1">7.1 Exercice permanent</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.2">7.2 Exercice d'administration de base</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.3">7.3 Exercice de configuration graphique</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.4">7.4 Copie d'écran</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.5">7.5 Burn All GIFs!</a
><br
/>&nbsp;&nbsp;&nbsp;<a href="#SUBSECTION_7.6">7.6 Pour les plus avancés...</a
></p
><a name="SECTION_0"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>0 Remarques préliminaires</b
></font
></td
></tr
></table
><p align="justify">
Les notes de cours suivantes
sont un document de travail en cours d'élaboration,
à l'occasion des cours que j'ai commencé à donner
pour le <a href="http://www.cepl.lu">CEPL</a
>
en octobre 2003.
Vous pouvez suivre l'évolution de ces notes de cours sur
<a href="http://fare.tunes.org/cgi-bin/viewcvs.cgi/fare/www/computing/cepl-linux.scr">mon serveur CVS</a
>.
[Mon serveur CVS n'est plus à jour; j'utilise maintenant monotone.]
</p
><p align="justify">
Les opinions professées sont les miennes et n'engagent que moi.
En particulier, elles n'engagent
ni le CEPL, ni mon employeur régulier,
ni aucune association ni aucun groupe dont je ferais partie,
et encore moins dont je ne ferais pas partie.
</p
><p align="justify">
Ces notes de cours ne remplacent pas le cours et les travaux pratiques;
elles ne se substituent pas non plus aux supports de cours de M. Pascal Bauler;
elles constituent un complément théorique.
Seule la pratique vous apprendra réellement Linux;
ces notes n'ont pas d'autre objet
que de vous permettre d'orienter votre pratique
et d'en cristalliser plus vite les concepts fondamentaux.
</p
><p align="justify">
Pour maîtriser Linux, vous devrez en connaître les principes fondamentaux,
mais aussi savoir vous y retrouver dans la documentation.
Ces notes de cours font systématiquement référence au manuel en-ligne de Linux,
et contiennent aussi de nombreuses références à des pages web
(notamment dans la section 3.4 "Pour en savoir plus").
Il y a aussi des notes de bas de page,
qui se veulent des points de départ utiles à ceux d'entre vous
qui voudront explorer un sujet particulier,
mais dont la connaissance n'est pas indispensable à l'utilisation de Linux.
Il est plus important de comprendre l'essentiel,
et pour le reste de savoir ce qui existe et où chercher en cas de problème,
que de maîtriser tous les détails de choses somme toute rarement utiles.
</p
><p align="justify">
Pour ce qui est du mouvement des logiciels libres et de sa philosophie,
qui soutendent tout le monde de Linux,
voir mon article <a href="http://fare.tunes.org/libre-logiciel.html">Le Libre Logiciel</a
>
et surtout les liens sur lesquels il pointe (section "ressources").
</p
><a name="SECTION_1"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>1 L'architecture des ordinateurs et de Linux</b
></font
></td
></tr
></table
><p align="justify">
Voici un court rappel sur l'architecture des ordinateurs en général,
avec des notes sur Linux en particulier.
Ce rappel permet aussi de mettre au clair certains concepts
et le vocabulaire qui va avec.
</p
><a name="SUBSECTION_1.1"></a
><font size="+1" face="sans-serif"><b>1.1 Architecture de Von Neuman</b
></font
><p align="justify">
Selon le modèle de machines formalisé
par Von Neuman dans les années 1940
et toujours suivi (à quelques variantes près)
par tous les
<em>ordinateurs à usage général</em
> (anglais: <em>general-purpose computer</em
>)
une machine est constituée
d'un <em>processeur</em
> (anglais: <em>processor</em
>)
et d'une <em>mémoire</em
> (anglais: <em>memory</em
>).
</p
><p align="justify">
La machine effectue des calculs en exécutant
séquentiellement instruction après instruction,
des milliers de fois par seconde
(de nos jours, en l'an 2003, parfois des milliards de fois).
</p
><p align="justify">
Le processeur possède un nombre limité
de <em>registres</em
> (anglais: <em>registers</em
>),
pouvant chacun représenter un sous-ensemble fini des nombres entiers
(de nos jours, presque toujours un nombre binaire sur 32 chiffres,
pouvant donc représenter tout nombre positif inférieur à 2 puissance 32).
</p
><p align="justify">
La mémoire possède un grand nombre de cases
ayant chacune son <em>adresse</em
> (anglais: <em>address</em
>),
un numéro qui peut être décrit dans un registre,
pouvant chacune contenir un <em>mot</em
> (anglais: <em>word</em
>),
qui peut être lu ou écrit depuis un registre.
</p
><p align="justify">
Chaque <em>instruction</em
> (anglais: <em>instruction</em
>)
pourra lire un petit nombre de registres ou de cases mémoires
(typiquement moins de trois),
et en modifier un petit nombre
(typiquement une au plus).
Chaque <em>opération</em
> (anglais: <em>operation</em
>)
effectuée par chacune de ces instructions
sur les registres et la mémoire est très simple:
un exemple typique est l'addition de deux mots,
le résultat étant stoqué dans un registre.
</p
><p align="justify">
Les instructions sont elles-mêmes lues dans la mémoire,
à l'adresse indiquée par un registre spécial appelé
<em>compteur du programme</em
> (anglais: <em>program counter</em
>)
ou <em>pointeur d'instruction</em
> (anglais: <em>instruction pointer</em
>);
le pointeur d'instruction est <em>incrémenté</em
> (anglais: <em>incremented</em
>)
(c'est-à-dire qu'on l'avance un peu) avant l'instruction suivante,
à moins qu'il ne soit modifié par l'instruction en cours,
alors appelée un <em>saut</em
> (anglais: <em>jump</em
>).
Grâce à des tels sauts, le programme peut effectuer
des <em>boucles</em
> (anglais: <em>loop</em
>) répétitives,
de façon à effectuer un travail similaire
un grand nombre de fois sur une grande quantité d'informations.
Pour pouvoir effectuer des variantes à chaque fois,
traiter des cas particulier,
savoir arrêter le traitement et sortir d'une boucle,
le processeur peut typiquement n'exécuter un saut ou une autre instruction
qu'après avoir vérifié un <em>test</em
> (anglais: <em>test</em
>),
qui consiste typiquement à déterminer si deux nombres étaient
égaux ou différents.
</p
><p align="justify">
Pour pouvoir communiquer avec le monde extérieur,
l'ordinateur exécute des instructions spéciales
dites d'<em>entrée-sortie</em
> (anglais: <em>input-output</em
>).
Souvent (mais pas toujours),
cette entrée-sortie prend la forme d'une opération de lecture ou d'écriture
dans une case mémoire spéciale &mdash;
on dit que l'entrée-sortie est <em>mappée en mémoire</em
> (anglais: <em>memory-mapped</em
>).
</p
><p align="justify">
<u>Pertinence</u
>:
la façon dont se font les calculs,
par un très grand nombre de petites modifications
sur un <em>espace mémoire</em
> (anglais: <em>memory space</em
>),
a une incidence sur la façon dont sont organisées
les informations sur lesquelles on travaille, les <em>données</em
> (anglais: <em>data</em
>).
Il est parfois utile de comprendre cette organisation
pour agir sur le système (le corriger, l'améliorer).
<a name="footnoteref1"></a
><a href="#footnote1"><sup><font size="-1">[1]</font
></sup
></a
>
</p
><a name="SUBSECTION_1.2"></a
><font size="+1" face="sans-serif"><b>1.2 Mémoire</b
></font
><p align="justify">
La mémoire de travail qui peut être lue ou modifiée à volonté
est appelée <em>mémoire vive (MEV)</em
> (anglais: <em>random-access memory (RAM)</em
>);
elle s'efface quand l'ordinateur est éteint ou remis à zéro.
Un mémoire ne s'effaçant pas et ne pouvant pas (normalement) être modifiée,
la <em>mémoire morte (MEM)</em
> (anglais: <em>read-only memory (ROM)</em
>)
contient le programme de démarrage de l'ordinateur.
Le reste de l'<em>espace adressable</em
> (anglais: <em>addressable space</em
>),
correspondant aux numéros de cases mémoire qui ne sont pas occupés
pas de la mémoire vive ni de la mémoire morte,
ni des entrées-sorties mappées en mémoire,
est inutilisé.
</p
><p align="justify">
Dans les ordinateurs modernes,
l'unité d'information traitée est le <em>bit</em
>
(<em>chiffre binaire</em
> (anglais: <em>binary digit</em
>)) (b),
qui peut contenir un 0 ou un 1.
les bits sont souvent groupés en mots de <em>n</em
> bits,
pouvant chacun représenter <em>2 puissance n</em
> combinaisons différentes,
typiquement un nombre entier naturel entre 0 et <em>(2 puissance n) - 1</em
>
ou un nombre entier relatif entre <em>-(2 puissance (n-1))</em
>
et <em>(2 puissance (n-1))-1</em
>.
La taille d'un mot, quand elle n'est pas spécifiée,
est celle d'un registre de la machine,
qui est de nos jours en général 32 bits ou 64 bits.
</p
><p align="justify">
Les mots de 8 bits sont appelés <em>octet</em
> (anglais: <em>byte</em
>) (1 B = 8 b),
et peuvent représenter un nombre entier entre 0 et 255
(ou entre -128 et +127).
Les textes sont composés de <em>caractères</em
> (anglais: <em>characters</em
>)
où chaque caractère est en général stoqué sur un octet
(parfois 2, parfois 4, parfois une valeur variable entre 1 et 4).
</p
><p align="justify">
Les ordinateurs travaillent typiquement
sur des mots de 32 bits
(soit 4 octets, nombres entre 0 et 4.294.967.295,
ou entre -2.147.483.648 et +2.147.483.647)
ou pour les plus puissants 64 bits
(soit 8 octets, nombres entre 0 et 18.446.744.073.709.551.615,
ou entre -9.223.372.036.854.775.808 et +9.223.372.036.854.775.807).
</p
><p align="justify">
La mémoire peut se compter en
<em>kibioctets</em
> (anglais: <em>kibibytes</em
>) (1 KiB = 1024 B),
<em>mébioctets</em
> (anglais: <em>mebibyte</em
>) (1 MiB = 1024 KiB = 1.048.576 B),
<em>gibioctets</em
> (anglais: <em>gibibyte</em
>) (1 GiB = 1024 MiB = 1.073.741.824 B).
Une page de texte prend typiquement entre 1 et 2 KiB;
le texte de la bible tient entre 4 et 5 MiB.
<a name="footnoteref2"></a
><a href="#footnote2"><sup><font size="-1">[2]</font
></sup
></a
>
</p
><p align="justify">
Un ordinateur est typiquement livré avec juste assez de mémoire vive
pour faire tourner confortablement le système du jour.
En 2003, le système du jour est Windows XP ou Mac OS X
ou Linux avec une interface graphique KDE 3,
et la bonne quantité de RAM est 256 MiB.
Une utilisation allégée se satisfera de moins
(128 MiB voire moins avec des efforts),
une utilisation intensive nécessitera plus (512 MiB et davantage).
</p
><p align="justify">
<u>Pertinence</u
>:
savoir combien de place prennent des données est important
pour évaluer la taille et le prix des supports à acheter,
des lignes sur lesquelles faire transiter ces données, etc.
Comprendre le fonctionnement du système peut permettre
d'éviter des gâchis coûteux
(comme un plantage dû à un manque de ressources),
en évitant des opérations inutiles
(transfert de très gros fichiers sur un réseau lent qui sera saturé
plutôt que sur un disque),
ou en achetant à l'avance des ressources nécessaires
(RAM, disque dur).
</p
><a name="SUBSECTION_1.3"></a
><font size="+1" face="sans-serif"><b>1.3 Architecture virtualisée</b
></font
><p align="justify">
Un ordinateur moderne correctement programmé
peut exécuter plusieurs programmes à la fois.
On dit alors qu'il est <em>multitâche</em
> (anglais: <em>multitasking</em
>),
chaque programme différent étant une <em>tâche</em
> (anglais: <em>task</em
>)
<a name="footnoteref3"></a
><a href="#footnote3"><sup><font size="-1">[3]</font
></sup
></a
>.
</p
><p align="justify">
Pour simplifier de nombreux problèmes de programmation,
y compris la gestion du multitâche,
les ordinateurs à usage général modernes
permettent d'écrire des programmes
comme si chaque programme s'exécutait
sur son propre ordinateur rien qu'à lui, isolé des autres,
une <em>machine virtuelle</em
> (anglais: <em>virtual machine</em
>).
on dit que le processeur et la mémoire
sont <em>virtualisés</em
> (anglais: <em>virtualized</em
>).
Un tel ordinateur virtuel s'appelle un
<em>processus</em
> (anglais: <em>process</em
>).
</p
><p align="justify">
Un programme spécial, le <em>noyau</em
> (anglais: <em>kernel</em
>)
sert à maintenir cette illusion.
Il utilise un mode de fonctionnement spécial du processeur,
où sont disponibles des instructions
inaccessibles aux autres programmes;
ce mode spécial est appelé <em>mode noyau</em
> (anglais: <em>kernel mode</em
>)
par opposition au <em>mode utilisateur</em
> (anglais: <em>user mode</em
>).
</p
><p align="justify">
<u>Pertinence</u
>:
les problèmes en mode noyau
(par exemple, utilisation de matériels mal reconnus)
peuvent complètement planter la machine.
Les problèmes en mode utilisateur
peuvent rendre certains processus non fonctionnels,
pendant que les autres processus continueront à tourner;
dans ce dernier cas, il sera souvent possible de relancer les calculs
voire de récupérer les résultats intermédiaires des programmes plantés.
</p
><p align="justify">
<u>Note</u
>:
sur les systèmes modernes comme
Linux (et tous les Unix), Windows NT/2000/XP,
ou MacOS X (qui fonctionne en fait avec un Unix),
l'isolation entre les processus est bien assurée.
Ce n'était pas le cas sur les systèmes
Windows 95/98/ME, MacOS 9,
et de nombreux systèmes plus ancien (MS-DOS, Windows 3, MacOS 6/7/8),
où une erreur sur un processus normal pouvait planter tout le système.
</p
><a name="SUBSECTION_1.4"></a
><font size="+1" face="sans-serif"><b>1.4 Persistence</b
></font
><p align="justify">
La mémoire d'un ordinateur est typiquement effacée à chaque fois
que l'ordinateur est éteint ou plante.
Pour que les données <em>persistent</em
> (anglais: <em>to persist</em
>)
à travers les extinctions et les plantages,
il faut effectuer des opérations d'entrées-sorties
sur une mémoire persistente (typiquement un <em>disque dur</em
> (anglais: <em>hard disk</em
>))
<a name="footnoteref4"></a
><a href="#footnote4"><sup><font size="-1">[4]</font
></sup
></a
>.
On parle aussi de <em>mémoire de masse</em
> (anglais: <em>mass memory, mass storage</em
>)
parce qu'elle peut typiquement contenir
beaucoup plus de données que la mémoire vive.
</p
><p align="justify">
Cette mémoire de masse est typiquement divisée en fichiers,
pour que des processus indépendants
puissent travailler sur des données indépendantes (fichiers différents)
ou des données partagées (fichiers identiques).
Typiquement, un fichier est vu comme une longue suite d'octets.
Un fichier est identifié par son un nom qui est
<em>une chaîne de caractère</em
> (anglais: <em>character string</em
>).
Il peut aussi selon le système posséder des <em>attributs</em
> (anglais: <em>attributes</em
>)
qui définissent typiquement la date de dernière modification,
le nom de l'utilisateur qui possède le fichier, etc.
</p
><p align="justify">
Les fichiers sont typiquement classés dans un hiérarchie
de <em>répertoires</em
> (anglais: <em>directories</em
>).
Un caractère spécial
('<code><font color="darkblue">/</font
></code
>' sous Linux et les autres Unix,
'<code><font color="darkblue">\</font
></code
>' ou optionnellement '<code><font color="darkblue">/</font
></code
>' sous Windows ou MS-DOS,
'<code><font color="darkblue">:</font
></code
>' sous les anciens Mac OS et l'interface utilisateur de Mac OS X)
sert de <em>délimiteur</em
> (anglais: <em>delimiter</em
>)
pour séparer dans le nom du fichier
le nom de la suite de répertoires où il se trouve <em></em
> (anglais: <em>dirname</em
>)
du <em>nom de base</em
> (anglais: <em>basename</em
>) du fichier.
</p
><p align="justify">
<u>Pertinence</u
>:
Les données qui persistent entre deux lancement d'un processus
sont les données sur le disque.
C'est sur ces données qu'il faut agir,
<em>pendant qu'aucun processus ne les utilise activement</em
>,
pour corriger des fautes qui surgissent d'un lancement à l'autre.
Ce sont aussi ces données qu'il faut surveiller
et protéger par une <em>sauvegarde</em
> (anglais: <em>backup</em
>) régulière,
pour éviter toute corruption par un processus erroné,
un plantage matériel, ou autre événement catastrophique.
</p
><p align="justify">
<u>Note</u
>:
Sous Windows,
les fichiers peuvent être sur l'une de plusieurs
<em>unités de disque</em
> (anglais: <em>disk units</em
>),
comme indiqué par une lettre et deux points.
Sous Linux, tous les fichiers sont visibles sous la même hiérarchie,
et des hiérarchies de fichiers provenant
d'autres partitions, d'autres disques, ou d'autres machines (via NFS)
peuvent être <em>montées</em
> (anglais: <em>mounted</em
>)
chacune sous un répertoire qui servira de
<em>point de montage</em
> (anglais: <em>mounting point</em
>),
grâce à la commande <tt><font color="darkblue">mount(8)</font
></tt
>
(voir aussi la commande <code><font color="darkblue">SUBST</font
></code
> sous MS-DOS).
Sous Linux, on peut explorer les fichiers disponibles
avec le navigateur <tt><font color="darkblue">konqueror</font
></tt
>,
ou avec des commandes comme <code><font color="darkblue">cd</font
></code
>, <code><font color="darkblue">pwd</font
></code
>, <tt><font color="darkblue">ls(1)</font
></tt
>,
<tt><font color="darkblue">cp(1)</font
></tt
>, <tt><font color="darkblue">mv(1)</font
></tt
>, <tt><font color="darkblue">ln(1)</font
></tt
> <a name="footnoteref5"></a
><a href="#footnote5"><sup><font size="-1">[5]</font
></sup
></a
>.
</p
><a name="SUBSECTION_1.5"></a
><font size="+1" face="sans-serif"><b>1.5 Multiplexage des ressources</b
></font
><p align="justify">
Les programmes utilisateurs partagent le même processeur et la même mémoire,
ayant chacun son tour une <em>tranche de temps</em
> (anglais: <em>time slice</em
>)
durant laquelle il s'exécute pendant que les autres sont en attente.
Ils partagent aussi la même mémoire de masse,
chaque disque étant divisé
en des grossières <em>partitions</em
> (anglais: <em>partitions</em
>),
et chaque partition pouvant
abriter un <em>système de fichiers</em
> (anglais: <em>filesystem</em
>),
lui-même subdivisé en de nombreux fichiers et répertoires avec leurs attributs.
</p
><p align="justify">
Le noyau assure que les <em>ressources</em
> (anglais: <em>resources</em
>)
du <em>matériel</em
> (anglais: <em>hardware</em
>)
sont ainsi disponibles pour chaque processus du système.
On dit qu'il <em>multiplexe</em
> (anglais: <em>to multiplex</em
>) les ressources.
<a name="footnoteref6"></a
><a href="#footnote6"><sup><font size="-1">[6]</font
></sup
></a
>
</p
><p align="justify">
Dans le cas où il n'y a pas assez de puissance processeur
pour effectuer toutes les tâches avant que l'utilisateur s'en aperçoive,
on sentira le système ralentir;
d'éventuelles requêtes en provenances du réseau
pourront ne pas être traitées.
Solution: acheter un ordinateur plus puissant,
ou être plus économe en puissance.
Dans le cas où il n'y a pas assez de mémoire vive réelle,
le noyau pourra utiliser une partie de la mémoire de masse
comme une extension (très lente) de la mémoire vive virtuelle,
grâce à des partitions ou des fichiers d'<em>échange</em
> (anglais: <em>swap</em
>)
à configurer à l'avance ou au dernier moment.
</p
><p align="justify">
<u>Pertinence</u
>:
grâce à ce multiplexage,
il n'y a presque plus à se soucier
des ressources individuelles de chaque processus,
mais seulement des ressources globales du système.
Il faut néanmoins parfois surveiller le niveau des ressources
et comprendre quels processus occupent trop de ressources
(avec les commandes <tt><font color="darkblue">free(1)</font
></tt
>, <tt><font color="darkblue">top(1)</font
></tt
>, <tt><font color="darkblue">ps(1)</font
></tt
>,
<tt><font color="darkblue">pidof(8)</font
></tt
>, <tt><font color="darkblue">lsof(8)</font
></tt
>, <tt><font color="darkblue">fuser(8)</font
></tt
>)
et parfois tuer le processus gênant
(avec les commandes <tt><font color="darkblue">kill(1)</font
></tt
>, <tt><font color="darkblue">killall(1)</font
></tt
>).
L'interface graphique <code><font color="darkblue">ksysguard</font
></code
>) permet de faire tout cela.
Attention que chaque système de fichiers
peut déborder indépendamment des autres,
ce qui peut être un plus
(si cela permet à certains services de survivre à un débordement
qui en fait planter d'autres;
typiquement, les utilisateurs sont sur une partition à part,
sur un serveur les logs aussi, etc.),
ou un moins (davantage de plantages potentiels à gérer).
</p
><a name="SUBSECTION_1.6"></a
><font size="+1" face="sans-serif"><b>1.6 Appels systèmes</b
></font
><p align="justify">
Pour effectuer des entrées-sorties réelles
(lecture ou écriture de fichier, communication avec l'utilisateur)
ou virtuelles
(communication avec d'autres processus),
les processus doivent passer par le noyau;
pour cela ils utilisent des séquences d'instructions spéciales
constituant des <em>appels systèmes</em
> (anglais: <em>system call</em
>).
Le noyau se charge des vraies entrées-sorties,
et de la communication entre processus.
</p
><p align="justify">
Les appels systèmes sont documentés dans la section 2
du manuel de l'utilisateur
<a name="footnoteref7"></a
><a href="#footnote7"><sup><font size="-1">[7]</font
></sup
></a
>
<a name="footnoteref8"></a
><a href="#footnote8"><sup><font size="-1">[8]</font
></sup
></a
>
Des appels systèmes typiques sont <tt><font color="darkblue">read(2)</font
></tt
> et <tt><font color="darkblue">write(2)</font
></tt
>,
qui permettent de transmettre des données
entre les entités gérées par le noyau
et la mémoire du processus courant.
</p
><p align="justify">
<u>Pertinence</u
>:
toutes les communications entre un processus
et d'autres processus ou le monde extérieur
passent par le noyau.
Il est ainsi possible de voir ce qu'un processus fait,
d'intercepter ses communications, etc.,
avec des commandes comme <tt><font color="darkblue">ps(1)</font
></tt
>, <tt><font color="darkblue">lsof(8)</font
></tt
>, <tt><font color="darkblue">strace(1)</font
></tt
>, etc.
C'est très utile pour diagnostiquer les erreurs.
<a name="footnoteref9"></a
><a href="#footnote9"><sup><font size="-1">[9]</font
></sup
></a
>
</p
><p align="justify">
<u>Note</u
>:
Contrairement à d'autres systèmes,
le noyau Linux ne se soucie que de faire un travail limité
de manière <em>fiable</em
> et <em>robuste</em
>.
Il est «&nbsp;bête et méchant&nbsp;»:
les données qu'il manipule ne sont pour lui que des zéros et des uns
sans signification particulière,
en dehors des paramètres de ses appels systèmes en tant que tels.
Charge aux processus de rendre
les données intelligibles aux utilisateurs.
</p
><a name="SUBSECTION_1.7"></a
><font size="+1" face="sans-serif"><b>1.7 Droits d'accès</b
></font
><p align="justify">
Le noyau gère un certain nombre d'utilisateurs
<a name="footnoteref10"></a
><a href="#footnote10"><sup><font size="-1">[10]</font
></sup
></a
>.
</p
><p align="justify">
Des utilisateurs spéciaux existent qui ont des droits d'administration
sur l'ensemble du système ou sur certains sous-systèmes logiciels limités.
Sous Linux, l'utilisateur dont l'UID est 0,
traditionnellement appelé <code><font color="darkblue">root</font
></code
>,
possède tous les droits d'administration.
On dit aussi qu'il s'agit d'un <em>super-utilisateur</em
> (anglais: <em>super-user</em
>)
<a name="footnoteref11"></a
><a href="#footnote11"><sup><font size="-1">[11]</font
></sup
></a
>
</p
><p align="justify">
Le noyau vérifie à chaque appel système
que le processus appelant fait une opération correcte
et que l'utilisateur qui a lancé le processus
possède les <em>droits d'accès</em
> (anglais: <em>access rights</em
>)
nécessaires pour l'opération indiquée.
</p
><p align="justify">
Le système maintient une séparation stricte
entre ses propres données et celles des processus.
Il peut ainsi continuer à tourner et à effectuer ces vérifications
sans être affecté par d'éventuelles erreurs ou tentatives de sabotage
par les processus.
</p
><p align="justify">
On peut inspecter les droits d'utilisateur du processus actuel
avec la commande <tt><font color="darkblue">id(1)</font
></tt
>, ou encore <tt><font color="darkblue">whoami(1)</font
></tt
> et <tt><font color="darkblue">groups(1)</font
></tt
>,
voire <code><font color="darkblue">who am i</font
></code
>.
</p
><p align="justify">
<u>Pertinence</u
>:
il faut savoir gérer les droits d'accès,
pour faire attention que les processus qui sont censés tournés
ne voient pas leurs requêtes refusées par le noyau.
Pour empêcher et détecter rapidement les erreurs,
il est utile se séparer strictement les programmes
avec des utilisateurs différents pour des services différents
aussi bien que utilisateurs humains différents.
Enfin, pour des raisons de sécurité,
il faut veiller à ce qu'il n'y ait pas de
<em>trou de sécurité</em
> (anglais: <em>security hole</em
>)
qui permette à un utilisateur mal-intentionné voire à un intrus
d'obtenir des droits d'accès qu'il ne devrait pas avoir.
</p
><p align="justify">
<u>Note</u
>:
Pour les administrateurs avancés, Linux dispose
<ul><li>de la notion de <em>groupes d'utilisateurs</em
> (anglais: <em>user groups</em
>),
qui permet à des utilisateurs sur un même projet de partager des fichiers.
Voir les commandes <tt><font color="darkblue">chgrp(1)</font
></tt
>, <tt><font color="darkblue">sg(1)</font
></tt
> et les fichiers
<tt><font color="darkblue">passwd(5)</font
></tt
>, <tt><font color="darkblue">group(5)</font
></tt
>, <tt><font color="darkblue">gshadow(5)</font
></tt
>.</li
><li>d'un système de quotas
limitant les ressources totales occupées par chaque utilisateur ou groupe,
disponible avec la commande <tt><font color="darkblue">quota(8)</font
></tt
>.</li
><li>d'un système de <em>capabilités</em
> (anglais: <em>capabilities</em
>)
permettant de déléguer individuellement chacun des nombreux droits
que possède <code><font color="darkblue">root</font
></code
>.
Un cousin pas si lointain de Linux, OpenBSD, très orienté sécurité,
permet filtrer assez finement les appels au système.</li
></ul
>
</p
><a name="SUBSECTION_1.8"></a
><font size="+1" face="sans-serif"><b>1.8 Niveaux d'abstraction</b
></font
><p align="justify">
On peut concevoir le système à de multiples niveaux d'abstraction.
</p
><p align="justify">
Le noyau parle au <em>matériel</em
> (anglais: <em>hardware</em
>),
et gère des processus.
</p
><p align="justify">
Chaque processus voit le monde que lui présente le noyau
et exécute une activité propre.
Pour interpréter les données de ce monde, il intègre des
<em>bibliothèques</em
> (anglais: <em>libraries</em
>) qui gèrent des conventions de codage.
</p
><p align="justify">
Certains processus tournent en tâche de fond
et fournissent des <em>services</em
> (anglais: <em>services</em
>)
(tel que l'affichage graphique,
la connexion à distance,
l'impression de documents).
On les appelle des <em>démons</em
> (anglais: <em>daemons</em
>).
Certaines bibliothèques gèrent implicitement
l'appel aux démons adéquats.
</p
><p align="justify">
Parfois, des processus normaux et des démons coopèrent
pour faire émerger un comportement cohérent.
On parle alors d'<em>environnement</em
> (anglais: <em>environment</em
>).
(Exemple: l'environnement de bureau graphique KDE).
</p
><p align="justify">
C'est la tâche de l'<em>intégrateur</em
> (anglais: <em>integrator</em
>) de faire en sorte
que sa <em>distribution</em
> (anglais: <em>distribution</em
>) de logiciels
forme un ensemble cohérent qui fournisse aux utilisateurs
un environnement stable.
</p
><p align="justify">
<u>Pertinence</u
>:
Si vous voulez modifier le système pour le réparer ou l'améliorer,
il faut comprendre à quel niveau agir.
À un niveau trop haut ou trop bas,
le problème est trop abstrait ou trop complexe,
les moyens de le décrire sont trop inadéquats,
et les moyens d'agir trop chargés de détails pas assez précis.
</p
><a name="SECTION_2"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>2 Le petit monde de Linux</b
></font
></td
></tr
></table
><p align="justify">
Comprendre Linux proprement dit,
c'est le comprendre au niveau d'abstraction des processus,
ce qu'un processus voit,
qui lui est fourni d'une part par le noyau,
et d'autre part par les conventions standards universellement respectées
par tous les processus et présentes dans les bibliothèques standards,
pour interagir via le système de fichiers et autres moyens de communication.
Il est toujours temps ensuite de découvrir
les niveaux d'abstraction supérieurs,
fournis par divers services optionnels,
par les outils de paquetage des distributions,
par les environnement de bureau graphique,
etc.
Ces niveaux supérieurs ne pouvant pas tout contrôler et intercepter
sur le système, ils doivent en fin de compte ne se fier
principalement qu'aux invariants de cohérence offerts par ce niveau de base.
</p
><p align="justify">
Notons qu'à ce niveau, Linux n'est qu'une variante d'Unix,
tel que défini par la Single Unix Specification, 
qui remplace les normes et standards de fait précédents,
comme POSIX, BSD et System V.
</p
><a name="SUBSECTION_2.1"></a
><font size="+1" face="sans-serif"><b>2.1 Le monde vu par un processus</b
></font
><p align="justify">
Un processus possède de nombreux attributs,
qui définissent sa vision du monde
et la vision que les autres processus en ont.
L'interface graphique <code><font color="darkblue">ksysguard</font
></code
>) (entre autres)
permet d'inspecter visuellement 
la <em>table des processus</em
> (anglais: <em>process table</em
>).
Les attributs d'un processus:
<ul><li>un identifiant ou <em>numéro de processus</em
> (anglais: <em>pid</em
>),
qui permet de nommer le processus et d'agir dessus
<a name="footnoteref12"></a
><a href="#footnote12"><sup><font size="-1">[12]</font
></sup
></a
>.
</li
><li>de la mémoire de travail et des registres processeur,
qui forment l'état du processus en tant que calculateur virtuel
<a name="footnoteref13"></a
><a href="#footnote13"><sup><font size="-1">[13]</font
></sup
></a
>.</li
><li>
un <em>état</em
> (anglais: <em>status</em
>): actif, inactif, etc.
<a name="footnoteref14"></a
><a href="#footnote14"><sup><font size="-1">[14]</font
></sup
></a
>.</li
><li>
Des informations sur ses droits d'accès:
un numéro d'utilisateur, un numéro de groupe,
une liste de groupes supplémentaires, etc.
<a name="footnoteref15"></a
><a href="#footnote15"><sup><font size="-1">[15]</font
></sup
></a
>
<a name="footnoteref16"></a
><a href="#footnote16"><sup><font size="-1">[16]</font
></sup
></a
>
<a name="footnoteref17"></a
><a href="#footnote17"><sup><font size="-1">[17]</font
></sup
></a
>
<a name="footnoteref18"></a
><a href="#footnote18"><sup><font size="-1">[18]</font
></sup
></a
></li
><li>
des <em>descripteurs de fichiers</em
> (anglais: <em>file descriptors</em
>)
identifiés par un entier positif.
Un descripteur correspond le plus souvent à un fichier,
mais on peut aussi ouvrir des tuyaux de communication,
des connexions réseau, des segments de mémoire partagée,
des périphériques systèmes, et autres objets du système
<a name="footnoteref19"></a
><a href="#footnote19"><sup><font size="-1">[19]</font
></sup
></a
>.
</li
><li>
un <em>répertoire (de travail) courant</em
> (anglais: <em>current (working) directory</em
>)
<a name="footnoteref20"></a
><a href="#footnote20"><sup><font size="-1">[20]</font
></sup
></a
>.</li
><li>
Un <em>processus parent</em
> (anglais: <em>parent process</em
>), (peut-être) des enfants
<a name="footnoteref21"></a
><a href="#footnote21"><sup><font size="-1">[21]</font
></sup
></a
>.</li
><li>
quelques autres ressources et propriétés
<a name="footnoteref22"></a
><a href="#footnote22"><sup><font size="-1">[22]</font
></sup
></a
>.
</li
></ul
>
</p
><p align="justify">
Quelques commandes pour inspecter les processus.
On peut regarder les processus actifs avec <tt><font color="darkblue">top(1)</font
></tt
>.
On peut regarder l'état et autres propriétés d'un processus avec <tt><font color="darkblue">ps(1)</font
></tt
>.
On peut regarder les arbres des processus pères/fils
avec <tt><font color="darkblue">pstree(1)</font
></tt
> ou <code><font color="darkblue">ps x --forest</font
></code
>.
On peut regarder les appels systèmes d'un processus grâce à <tt><font color="darkblue">strace(1)</font
></tt
>.
On peut regarder les fichiers ouverts par un processus grâce à <tt><font color="darkblue">lsof(8)</font
></tt
>.
On peut regarder soi-même en allant dans <code><font color="darkblue">/proc/$PID</font
></code
>.
</p
><p align="justify">
<u>Pertinence</u
>:
les attributs d'un processus définissent et limitent la façon
dont il interagit avec le reste du monde,
en bien comme en mal (erreurs).
Le fait que la plupart de ces attributs sont hérités de processus père à fils
limite aussi la façon dont les informations se propagent:
il n'est pas habituellement possible d'échanger
des droits d'accès, des descripteurs de fichiers,
des variables d'environnement, etc., d'un processus à l'autre;
pour se contacter, deux processus doivent donc
ou bien faire partie d'un groupe de processus ayant un ancêtre commun
qui les synchronise en leur fournissant les bons attributs hérités,
ou bien utiliser le système de fichier ou les services réseaux,
le client contactant le serveur
via un chemin d'accès ou un port de communication bien identifié
<a name="footnoteref23"></a
><a href="#footnote23"><sup><font size="-1">[23]</font
></sup
></a
>.
</p
><a name="SUBSECTION_2.2"></a
><font size="+1" face="sans-serif"><b>2.2 Conventions d'usage</b
></font
><a name="SUBSUBSECTION_2.2.1"></a
><p align="left"><b>2.2.1 Paramètres de lancement d'une commande</b
> </p
><p align="justify">
Quand on lance une nouvelle commande,
on spécifie un certain nombre de paramètres explicites et implicites:
le programme, la ligne de commande, les variables d'environnement
sous présents explicitement dans l'appel système <tt><font color="darkblue">execve(2)</font
></tt
>;
les fichiers déjà ouverts et autres attributs et ressources
sont hérités du processus père ou pas au moment de l'appel système
<tt><font color="darkblue">fork(2)</font
></tt
> ou sa variante <tt><font color="darkblue">clone(2)</font
></tt
> précédent le exec.
Lors de l'<tt><font color="darkblue">execve(2)</font
></tt
>, la mémoire est remise à zéro (aucun mapping),
puis de nouveaux mappings sont créés pour le programme,
les données privées du processus et sa pile d'exécution.
Le programme peut alors faire de nouveaux mappings
(pour les bibliothèques partagées notamment, ou pour demander plus de mémoire),
et lire ou mapper des fichiers de configuration, des fichiers de travail, etc.
</p
><p align="justify">
Quand on lance un nouveau programme en exécutant les appels systèmes
<a name="footnoteref24"></a
><a href="#footnote24"><sup><font size="-1">[24]</font
></sup
></a
>,
le noyau va donc charger le programme indiqué et lui fournir:
<ul><li>
Une liste de <em>paramètres</em
> (anglais: <em>parameters</em
>),
aussi appelés <em>arguments</em
> (anglais: <em>arguments</em
>),
qui sont des chaînes de caractères.
Typiquement, ce sont des options
suivies de paramètres proprement dit qui sont souvent des noms de fichiers
<a name="footnoteref25"></a
><a href="#footnote25"><sup><font size="-1">[25]</font
></sup
></a
>.
</li
><li>
Un <em>environnement</em
> (anglais: <em>environment</em
>), qui est un ensemble de variables
dont le nom est une chaîne de caractère,
et la valeur est une chaîne de caractère.
Sous votre shell, on peut utiliser une variable en précédent son nom
du caractère <code><font color="darkblue">'$'</font
></code
>.
Exemple: <code><font color="darkblue">echo $HOME</font
></code
>
<a name="footnoteref26"></a
><a href="#footnote26"><sup><font size="-1">[26]</font
></sup
></a
>
</li
><li>
Des descripteurs de fichiers déjà ouvert.
Par convention, le descripteur 0 sert d'entrée standard,
le 1 de sortie standard, le 2 de sortie standard d'erreur.
Avec le shell, on peut rediriger les entrées, sorties et sorties d'erreur
standards avec <code><font color="darkblue">&#60;</font
></code
> (ou <code><font color="darkblue">&#60;&#60;</font
></code
>)
<code><font color="darkblue">&#62;</font
></code
> (ou <code><font color="darkblue">&#62;&#62;</font
></code
>) et <code><font color="darkblue">2&#62;</font
></code
> (ou <code><font color="darkblue">2&#62;&#62;</font
></code
>), etc.
</li
></ul
>
</p
><a name="SUBSUBSECTION_2.2.2"></a
><p align="left"><b>2.2.2 Options</b
> </p
><p align="justify">
Le comportement des commandes peut souvent être modifié
par un nombre plus ou moins grand d'options.
</p
><p align="justify">
Par convention, ces options sont spécifiés parmi les arguments d'appel,
et reconnus en ce qu'ils commencent par le caractère <tt><font color="brown">-</font
></tt
> <a name="footnoteref27"></a
><a href="#footnote27"><sup><font size="-1">[27]</font
></sup
></a
>
De nombreux programmes ont des options courtes,
introduites par un seul caractère <tt><font color="brown">-</font
></tt
>, et nommées par un caractère,
et que l'on peut regrouper:
ainsi <code><font color="darkblue">ls -as</font
></code
> active les options <code><font color="darkblue">-a</font
></code
> et <code><font color="darkblue">-s</font
></code
>.
Parfois, il existe aussi des options longues,
introduites par deux caractères <tt><font color="brown">-</font
></tt
>, et nommées par un mot;
ainsi la commande précédente est équivalente à
<code><font color="darkblue">ls --all --size</font
></code
>.
D'autres programmes n'acceptent que des options longues avec un seul <tt><font color="brown">-</font
></tt
>.
</p
><p align="justify">
Le caractère <code><font color="darkblue">-</font
></code
> tout seul signifie souvent l'utilisation
de l'entrée ou de la sortie standard (selon le contexte)
comme fichier sur lequel la commande doit agir.
Doublé <code><font color="darkblue">--</font
></code
> il signifie souvent la fin des options du programme appelé,
le reste étant des paramètres normaux pour ce programme,
même s'ils commencent par <tt><font color="brown">-</font
></tt
> <a name="footnoteref28"></a
><a href="#footnote28"><sup><font size="-1">[28]</font
></sup
></a
>.
</p
><a name="SUBSUBSECTION_2.2.3"></a
><p align="left"><b>2.2.3 Configuration</b
> </p
><p align="justify">
Pour déterminer ce qu'elle va faire effectivement,
une commande regardera sa configuration,
par ordre de priorité décroissante:
<ul><li>
dans la ligne de commande.
</li
><li>
dans des variables d'environnement.
</li
><li>
dans le répertoire actuel
(pour des commandes comme <tt><font color="darkblue">make(1)</font
></tt
> ou <tt><font color="darkblue">cvs(1)</font
></tt
>,
assez contextuelles).
</li
><li>
dans les fichiers de configuration personnels de l'utilisateur:
souvent, <code><font color="darkblue">~/.<i>foo</i
>rc</font
></code
> pour le programme <code><font color="darkblue"><i>foo</i
></font
></code
>
<a name="footnoteref29"></a
><a href="#footnote29"><sup><font size="-1">[29]</font
></sup
></a
>.
</li
><li>
dans un fichier de configuration global;
traditionnellement, il se trouve dans <code><font color="darkblue">/etc</font
></code
>
ou un de ses sous-répertoires,
ou sous le répertoire <code><font color="darkblue">etc</font
></code
> de l'endroit où le programme est installé.
</li
></ul
>
<tt><font color="darkblue">ls(1)</font
></tt
> et <tt><font color="darkblue">grep(1)</font
></tt
> sont vos amis pour identifier les fichiers
de configuration, ainsi que <tt><font color="darkblue">strings(1)</font
></tt
> sur le binaire
ou <tt><font color="darkblue">strace(1)</font
></tt
>, mais bien sûr commencez par <tt><font color="darkblue">man(1)</font
></tt
>,
et s'il n'est pas concluant, tentez <code><font color="darkblue">rpm -qil</font
></code
> ou <code><font color="darkblue">dpkg -L</font
></code
>.
</p
><a name="SUBSUBSECTION_2.2.4"></a
><p align="left"><b>2.2.4 Gestion des erreurs</b
> </p
><p align="justify">
La convention est qu'un processus écrira sur sa sortie standard d'erreur
(descripteur de fichier numéro 2) des textes relatifs
aux erreurs ou événements anormaux ayant lieu.
Les démons (processus tournant en tâche de fond) pourront souvent
utiliser la facilité <tt><font color="darkblue">syslog(3)</font
></tt
> (<code><font color="darkblue">apropos syslog</font
></code
>)
pour le journal des événements anormaux rencontrés.
La configuration par défaut de syslog va en général correspondre à stoquer
des journaux des événements survenus dans <code><font color="darkblue">/var/log</font
></code
>,
mais il est possible de filtrer ce journal et de le rediriger
vers d'autres fichiers, voire une autre machine, etc.
</p
><p align="justify">
En se terminant, chaque processus donne un code d'erreur,
nombre compris entre 0 et 255.
La convention est que le 0 indique
que le programme s'est déroulé correctement,
tandis qu'autre chose indique une erreur qui n'a pas pu être corrigée.
</p
><p align="justify">
Dans un shell,
le code d'erreur du dernier programme est disponible
dans la variable <code><font color="darkblue">$?</font
></code
>.
</p
><a name="SUBSECTION_2.3"></a
><font size="+1" face="sans-serif"><b>2.3 L'arborescence des fichiers</b
></font
><p align="justify">
Les fichiers sont organisés dans une structure
de <em>répertoires</em
> (anglais: <em>directories</em
>)
récursivement imbriqués les uns dans les autres, appelée
<em>système de fichier</em
> (anglais: <em>filesystem</em
>).
On parle aussi d'arborescence de fichiers
ou de hiérarchie de fichiers.
</p
><a name="SUBSUBSECTION_2.3.1"></a
><p align="left"><b>2.3.1 Noms de fichiers</b
> </p
><p align="justify">
Le <em>nom d'un fichier</em
> (anglais: <em>filename</em
>) proprement dit
est une chaîne de caractère
ne comprenant pas ni le caractère nul (de code 0),
ni le caractère <em>barre de division</em
> (anglais: <em>slash</em
>) '/'.
Sur le système par fichier standard de Linux (ext2 ou ext3),
les noms de fichiers sont limités à 255 caractères.
</p
><p align="justify">
Sous Unix, traditionnellement,
la différence entre minuscule et majuscule compte.
Ceci vaut pour les noms de fichiers
et donc aussi par conséquence pour les noms de programmes exécutables
(qui sont des fichiers) <a name="footnoteref30"></a
><a href="#footnote30"><sup><font size="-1">[30]</font
></sup
></a
>
</p
><p align="justify">
Un <em>chemin d'accès à un fichier</em
> (anglais: <em>pathname</em
>) (ou nom de fichier)
est une chaîne de caractère formé de noms de fichiers séparés
par des slashes '/'.
Le fichier spécifié est obtenu en entrant successivement
dans chacun des répertoires nommé par un composant du chemin d'accès
jusqu'à arriver au dernier composant, qui est le nom du fichier désigné.
</p
><p align="justify">
Si le chemin d'accès commence par un slash,
alors il est dit être <em>absolu</em
> (anglais: <em>absolute</em
>),
et commence à partir du répertoire racine.
Sinon, il est dit être relatif,
et commence à partir du répertoire de travail courant du processus actuel.
</p
><p align="justify">
Au cours de la traversée d'un chemin d'accès,
les noms de fichiers '.' et '..' font toujours référence au répertoire actuel
et au répertoire père du répertoire actuel
<a name="footnoteref31"></a
><a href="#footnote31"><sup><font size="-1">[31]</font
></sup
></a
>
</p
><a name="SUBSUBSECTION_2.3.2"></a
><p align="left"><b>2.3.2 Liens durs et liens symboliques</b
> </p
><p align="justify">
D'autres fichiers sont des <em>liens durs</em
> (anglais: <em>hard links, hardlinks</em
>),
de façon que plusieurs noms de fichiers correspondent à un même fichier réel,
avec le même contenu et les mêmes attributs.
Toute modification du fichier via un de ses noms sera visible
sous chacun de ses autres noms,
jusqu'à ce que le liens soit éventuellement brisé.
Les fichiers de même lien dur sont identifiés
par leur numéro d'<i>inode</i
>, visible avec <code><font color="darkblue">ls -li</font
></code
>
<a name="footnoteref32"></a
><a href="#footnote32"><sup><font size="-1">[32]</font
></sup
></a
>
Un fichier ne disparaît vraiment du disque
que lorsque le dernier lien est supprimé.
On ne peut faire de lien dur que vers un fichier de la même partition.
</p
><p align="justify">
On peut lire le nombre de liens durs vers un fichier
avec la commande <code><font color="darkblue">ls -l</font
></code
>.
Notez qu'un répertoire a toujours de nombreux liens, au moins deux,
puisque chaque parent est lié à son fils et réciproquement.
On ne peut toutefois pas faire de lien dur sur un répertoire autrement
que par une telle relation père-fils
<a name="footnoteref33"></a
><a href="#footnote33"><sup><font size="-1">[33]</font
></sup
></a
>.
</p
><p align="justify">
Il existe une autre sorte de liens.
Certains fichiers sont des
<em>liens symboliques</em
> (anglais: <em>symbolic links, symlinks</em
>)
qui pointent vers un chemin d'accès (absolu ou relatif).
Quand le noyau voit un tel lien, il remplace toute tentative d'accès
à ce lien par une tentative d'accès au chemin désigné
<a name="footnoteref34"></a
><a href="#footnote34"><sup><font size="-1">[34]</font
></sup
></a
>
</p
><p align="justify">
Les liens symboliques servent très souvent,
pour préserver des chemin d'accès connus aux fichiers
malgré le fait que l'arborescence réelle a été déplacée
<a name="footnoteref35"></a
><a href="#footnote35"><sup><font size="-1">[35]</font
></sup
></a
>.
Ainsi, les liens symboliques permettent de conserver
des chemins d'accès <em>logique</em
> (anglais: <em>logical</em
>) à chaque fichier.
</p
><p align="justify">
Les liens durs, eux, servent à partager des données devant être accessible
depuis un nombre indéterminé d'entrées de répertoire.
De tels fichiers partagés sont souvent gardés en lecture seule
après leur création initiale.
Un exemple connu d'utilisation de liens durs est
pour la gestion de groupes de discussion avec multipostage comme USENET
(voir le serveur <code><font color="darkblue">innd</font
></code
>).
Une autre application utile est pour le développement de versions concurrentes
d'un même logiciel:
on pourra ainsi partager les fichiers sources qui n'ont pas changé
entre les multiples arborescences d'un logiciel
dont on maintient simultanément plusieurs versions
(dernière version stable connue,
nouvelle version stable en provenance d'amont,
version de développement en amont, version localement modifiée, etc.)
<a name="footnoteref36"></a
><a href="#footnote36"><sup><font size="-1">[36]</font
></sup
></a
>.
</p
><a name="SUBSUBSECTION_2.3.3"></a
><p align="left"><b>2.3.3 Droits d'accès des fichiers</b
> </p
><p align="justify">
Chaque fichier a des droits d'accès déterminant
qui a le droit d'effectuer quelles opérations sur le fichier.
<tt><font color="darkblue">chgrp(1)</font
></tt
>.
<code><font color="darkblue">root</font
></code
> peut utiliser <tt><font color="darkblue">chown(1)</font
></tt
>.
</p
><p align="justify">
<tt><font color="darkblue">chmod(1)</font
></tt
>
</p
><p align="justify">
rwx
setuid
setgid
sticky <a name="footnoteref37"></a
><a href="#footnote37"><sup><font size="-1">[37]</font
></sup
></a
>
</p
><p align="justify">
Droits en octal.
</p
><p align="justify">
Truc: rendre répertoires et exécutables accessibles à tous
sans changer les autres droits:
	<code><font color="darkblue">chmod -R a+X foo</font
></code
>
</p
><p align="justify">
Un paramètre spécial du processus actuel,
disponible via la commande shell interne <code><font color="darkblue">umask</font
></code
>
(qui utilise l'appel système <tt><font color="darkblue">umask(2)</font
></tt
>),
détermine les droits d'accès qui seront refusés sur les fichiers créés.
Le umask est noté avec la syntaxe numérique octale du <code><font color="darkblue">chmod</font
></code
>.
Traditionnellement, le <code><font color="darkblue">umask</font
></code
>
est mis à <code><font color="darkblue">022</font
></code
> pour que seul l'utilisateur actuel
puisse modifier ses propres fichiers.
Il peut être mis à <code><font color="darkblue">002</font
></code
> si le groupe actuel
ne contient que l'utilisateur lui-même
et des personnes de confiance sur le projet dont on modifie les fichiers.
Il pourra être mis à <code><font color="darkblue">077</font
></code
> pour être paranoïaque et peu partageux
vis-à-vis des autres utilisateurs. etc.
</p
><p align="justify">
Par delà les droits d'accès unix traditionnels tels que décrits ci-dessus,
certains systèmes de fichiers fournissent des droits supplémentaires.
Par exemple, le système de fichier ext2 ou ext3 de Linux offre des
attributs accessibles avec les commandes <tt><font color="darkblue">lsattr(1)</font
></tt
> et <tt><font color="darkblue">chattr(1)</font
></tt
>.
</p
><p align="justify">
Traditionnellement, quand on crée un utilisateur normal,
on lui crée un répertoire personnel
ou <em>répertoire maison</em
> (anglais: <em>home directory</em
>),
(normalement répertorié dans le fichier <tt><font color="darkblue">passwd(5)</font
></tt
>.
Ce répertoire appartiendra au dit utilisateur,
et il pourra ainsi y faire ce qu'il veut,
sans être embêté par d'autres utilisateurs.
Par convention, le répertoire actuellement considéré comme maison
et connu via la variable d'environnement <code><font color="darkblue">HOME</font
></code
>.
</p
><a name="SUBSUBSECTION_2.3.4"></a
><p align="left"><b>2.3.4 Organisation conventionnelle du système de fichiers</b
> </p
><p align="justify">
Grâce aux techniques respectives des points de montage
<a name="footnoteref38"></a
><a href="#footnote38"><sup><font size="-1">[38]</font
></sup
></a
>
et des liens symboliques
<a name="footnoteref39"></a
><a href="#footnote39"><sup><font size="-1">[39]</font
></sup
></a
>,
l'<em>organisation du système de fichier</em
> (anglais: <em>filesystem layout</em
>)
est <em>logique</em
> (anglais: <em>logical</em
>) plutôt que <em>physique</em
> (anglais: <em>physical</em
>).
C'est-à-dire que ce qui compte pour déterminer le chemin d'accès à un fichier
est la structure logique de l'intention dans laquelle existe le fichier,
plutôt que la structure physique du disque sur lequel est stoqué le fichier.
</p
><p align="justify">
Pour le standard, plus ou moins respecté par toutes les distributions modernes,
voir le <a href="http://www.pathname.com/fhs/">FHS</a
>.
</p
><p align="justify">
Fichiers systèmes:
les répertoires <code><font color="darkblue">/bin</font
></code
>, <code><font color="darkblue">/lib</font
></code
>, <code><font color="darkblue">/sbin</font
></code
>, <code><font color="darkblue">/usr</font
></code
>,
contiennent des fichiers des programmes gérés par votre distribution;
le système ne modifie pas ces fichiers en temps normal,
sauf quand vous installez de nouveaux paquets.
<code><font color="darkblue">/usr</font
></code
> est lui-même divisé en de nombreux répertoires et sous-répertoires.
</p
><p align="justify">
Fichiers de travail:
Le répertoire <code><font color="darkblue">/var</font
></code
> contient les fichiers de travail persistents
des services installés.
Le répertoire <code><font color="darkblue">/tmp</font
></code
> (et/ou parfois aussi <code><font color="darkblue">/var/tmp</font
></code
>)
contient les fichiers temporaires du système,
qui n'ont pas besoin de survivre à un redémarrage
des programmes ou services qui les utilisent.
</p
><p align="justify">
Fichiers de configuration du système:
sous Unix, les fichiers de configuration sont généralement dans <code><font color="darkblue">/etc</font
></code
>,
et les distributions modernes s'y tiennent assez bien
pour les paquets qu'elles gèrent.
Si vous installez des logiciels d'une autre provenance,
vous pourrez aussi en avoir
dans <code><font color="darkblue">/opt/etc</font
></code
>, <code><font color="darkblue">/usr/local/etc</font
></code
>, <code><font color="darkblue">/var/qmail</font
></code
>, etc.
</p
><p align="justify">
Fichiers magiques:
Parmi les ressources multiplexées par le système,
il y a les <em>périphériques</em
> (anglais: <em>devices</em
>) connectés au système
(écran, clavier, souris, son, réseau, disque, imprimante, scanner, etc.),
chacun géré par un <em>gestionnaire de périphérique</em
> (anglais: <em>device driver</em
>)
approprié.
Sous Linux, ces périphériques sont souvent vus comme des fichiers spéciaux,
«&nbsp;magiques&nbsp;», dans le répertoire <code><font color="darkblue">/dev</font
></code
>.
D'autres fichiers «&nbsp;magiques&nbsp;» pour configurer le système
sont dans <code><font color="darkblue">/proc</font
></code
>
(allez donc y faire un tour avec <code><font color="darkblue">cd</font
></code
>, <code><font color="darkblue">ls</font
></code
> et <code><font color="darkblue">cat</font
></code
>)
voire dans certaines versions du système dans <code><font color="darkblue">/sys</font
></code
>.
Seul l'administrateur a normalement le droit
d'agir directement sur ces fichiers spéciaux.
</p
><p align="justify">
Fichiers utilisateurs:
<code><font color="darkblue">/root</font
></code
> contient souvent le répertoire utilisateur de <code><font color="darkblue">root</font
></code
>,
tandis que les autres utilisateurs sont souvent mis dans <code><font color="darkblue">/home</font
></code
>
(en général le répertoire par défaut où la distribution les met;
certains préfèrent <code><font color="darkblue">/users</font
></code
> ou quand il y a beaucoup d'utilisateurs,
une arborescence logique en-dessous de <code><font color="darkblue">/home</font
></code
> ou <code><font color="darkblue">/users</font
></code
>).
Le répertoire utilisateur de l'utilisateur courant est
dans la variable d'environnement <code><font color="darkblue">HOME</font
></code
>,
que les shells modernes abrègent souvent en <code><font color="darkblue">~</font
></code
>.
Les fichiers de configuration personnels de chaque utilisateur sont dans
son répertoire personnel avec un nom commençant par un point
(par exemple <code><font color="darkblue">~/.bashrc</font
></code
> pour le programme <tt><font color="darkblue">bash(1)</font
></tt
>).
</p
><p align="justify">
Autres:
<code><font color="darkblue">/opt</font
></code
> ou <code><font color="darkblue">/usr/local</font
></code
>
contiennent typiquement des programmes
qui ne sont pas gérés par la distribution,
mais par un autre système de paquetage,
voire installés manuellement par l'administrateur.
<code><font color="darkblue">/mnt</font
></code
> est souvent utilisé pour des montages temporaires.
Pour le reste, votre imagination est la seule limite!
</p
><a name="SUBSUBSECTION_2.3.5"></a
><p align="left"><b>2.3.5 Trouver des fichiers</b
> </p
><p align="justify">
La documentation peut aider à les trouver.
<ul><li>
la commande <tt><font color="darkblue">locate(1)</font
></tt
> peut aider à trouver un fichier par son nom;
</li
><li>
la commande <tt><font color="darkblue">grep(1)</font
></tt
> peut trouver un fichier d'après son contenu;
</li
><li>
la commande <tt><font color="darkblue">apropos(1)</font
></tt
> identifie un programme par sujet
<a name="footnoteref40"></a
><a href="#footnote40"><sup><font size="-1">[40]</font
></sup
></a
>;
</li
><li>
la commande <code><font color="darkblue">type</font
></code
> (ou <tt><font color="darkblue">which(1)</font
></tt
>) trouve l'exécutable de nom donné;
</li
><li>
au pire, la commande <tt><font color="darkblue">find(1)</font
></tt
> peut tout parcourir, mais prend du temps.
</li
><li>
Si votre distribution utilise des paquets RPM,
la commande <code><font color="darkblue">rpm -qif</font
></code
> identifie le paquet possédant un fichier,
et la commande <code><font color="darkblue">rpm -ql</font
></code
> trouve les autres fichiers du paquet.
Si votre distribution utilise des paquets .deb,
installez et utilisez plutôt les commandes <tt><font color="darkblue">dlocate(1)</font
></tt
> et <tt><font color="darkblue">apt-file(1)</font
></tt
>,
voire <code><font color="darkblue">dpkg -L</font
></code
> et <code><font color="darkblue">dpkg -S</font
></code
>;
la commande <tt><font color="darkblue">apt-cache(8)</font
></tt
> pourra aussi vous être utile.
</li
></ul
>
</p
><a name="SUBSECTION_2.4"></a
><font size="+1" face="sans-serif"><b>2.4 Les services en réseau</b
></font
><p align="justify">
Ce qui a fait le succès d'UNIX en général et de Linux en particulier a
toujours été leur intégration aux réseaux utilisant
les protocoles de l'Internet (TCP/IP).
</p
><p align="justify">
Linux gère aussi d'autres types de réseau et de services
(par exemple, AppleTalk grâce au logiciel <tt><font color="darkblue">netatalk(8)</font
></tt
>
ou Novell grâce à <tt><font color="darkblue">marsnwe(8)</font
></tt
>),
mais ceux qui valent le plus la peine d'être connus sont les réseaux IP.
<a name="footnoteref41"></a
><a href="#footnote41"><sup><font size="-1">[41]</font
></sup
></a
>
</p
><p align="justify">
À introduire dans cette section:
<ul><li>
Les principes de base de TCP/IP &mdash; renvoyer sur un document externe.
Ces protocoles sont définis et documentés via le processus des RFC de l'IETF.
</li
><li>
Droits d'accès:
les services privilégiés (port inférieur à 1024),
sur lesquels seul un processus ayant les droits de <code><font color="darkblue">root</font
></code
>
peut a priori devenir serveur,
et les autres services, où tout processus utilisateur peut a priori écouter.
Cependant, voir le principe du démon <tt><font color="darkblue">inetd(8)</font
></tt
>
(ou son remplaçant <tt><font color="darkblue">xinetd(8)</font
></tt
>),
et voir aussi les capabilités,
transmission de descripteurs de fichiers, etc.
</li
><li>
Les fichiers de <code><font color="darkblue">/etc</font
></code
> correspondant aux services de base:
<ul><li>
le <tt><font color="darkblue">resolver(3)</font
></tt
> et les fichiers
<tt><font color="darkblue">hosts(5)</font
></tt
> <tt><font color="darkblue">resolv.conf(5)</font
></tt
> <tt><font color="darkblue">host.conf(5)</font
></tt
> <tt><font color="darkblue">nsswitch.conf(5)</font
></tt
>
</li
><li>
la désignation des services:
<tt><font color="darkblue">protocols(5)</font
></tt
> <tt><font color="darkblue">services(5)</font
></tt
>
</li
><li>
Le démon <tt><font color="darkblue">inetd(8)</font
></tt
> et sa configuration <tt><font color="darkblue">inetd.conf(5)</font
></tt
>
(ou son remplaçant <tt><font color="darkblue">xinetd(8)</font
></tt
> et son <tt><font color="darkblue">xinetd.conf(5)</font
></tt
>).
</li
><li>
Les tcpwrappers
<tt><font color="darkblue">hosts.allow(5)</font
></tt
> <tt><font color="darkblue">hosts.equiv(5)</font
></tt
> <tt><font color="darkblue">hosts.deny(5)</font
></tt
>
</li
><li>
Le <em>parefeu</em
> (anglais: <em>firewall</em
>) avec <tt><font color="darkblue">iptables(8)</font
></tt
>.
</li
></ul
>
</li
></ul
>
</p
><p align="justify">
Pour une discussion de ce qui fait qu'UNIX
est historiquement particulièrement adapté aux services en réseau,
voir la discussion sur la notion de terminal.
</p
><a name="SUBSECTION_2.5"></a
><font size="+1" face="sans-serif"><b>2.5 L'interface graphique X</b
></font
><p align="justify">
Architecture en couches:
serveur X,
window manager,
desktop environment (GNOME, KDE, XFCE),
bibliothèques de fonctions,
applications, etc.
</p
><p align="justify">
<em>transparence réseau</em
> (anglais: <em>network transparency</em
>):
les programmes sont censés pouvoir s'exécuter
de n'importe quelle machine vers n'importe quelle machine.
<pre><font color="darkblue">export DISPLAY=:0
export DISPLAY=machine:0</font
></pre
>
</p
><p align="justify">
Authentification: <code><font color="darkblue">xhost(1x)</font
></code
>, <code><font color="darkblue">xauth(1x)</font
></code
>.
Sur certaines distributions,
la configuration par défaut du serveur X n'écoute pas sur le réseau,
et vous devez modifier ce point-là à la main.
</p
><p align="justify">
Pour davantage de sécurité, tunnel ssh ou IPSEC, etc.
</p
><p align="justify">
De nombreuses complications font que la transparence réseau
marche mal dès qu'on veut faire plus que d'afficher des données
ou que l'on veut utiliser l'une de diverses extensions au protocole X,
voire des protocoles qui agissent à côté de X:
le son, l'accès direct à l'écran, les fontes, etc.,
sont chacun source de problèmes de configuration
<a href="http://www.jargon.net/jargonfile/i/interesting.html">"intéressants"</a
>.
</p
><p align="justify">
Un résumé de l'état de l'art:
<a href="http://freedesktop.org/~jg/roadmap.html">Open Source Desktop Technology Road Map</a
>.
</p
><a name="SUBSECTION_2.6"></a
><font size="+1" face="sans-serif"><b>2.6 Initialisation du système</b
></font
><p align="justify">
Finalement pour comprendre Linux,
il faut comprendre comment Linux démarre.
Pour tous les détails, lire le HOWTO adéquat... 
</p
><p align="justify">
Démarrage de la machine:
la ROM initialise le matériel,
puis cherche un "secteur d'amorce"
sur une disquette, un disque dur, le réseau, etc.
</p
><p align="justify">
Le secteur d'amorce va charger le reste du programme d'amorce du système.
Pour Linux, il s'agit typiquement de GRUB ou de LILO,
qu'il ira chercher à tel numéro sur tel disque,
tel que spécifié lors de l'installation de GRUB ou de LILO.
</p
><p align="justify">
Le programme d'amorce offre éventuellement un menu,
et en fin de compte, décide de charger tel noyau avec tel paramètre,
à moins qu'il ne donne la main au programme d'amorce d'un autre système
(par exemple, au secteur d'amorce d'un disque contenant Windows).
</p
><p align="justify">
Le programme d'amorce cherche le noyau à l'endroit indiqué.
GRUB lit le système de fichier et retrouve le noyau d'après son nom de fichier;
LILO est plus bas niveau et reconstitue le noyau en cherchant
tel et tel secteur du disque;
LILO doit donc être réinstallé à chaque fois que le noyau est modifié.
</p
><p align="justify">
Une fois chargé par le programme d'amorce,
le noyau prend la main.
Le programme d'amorce peut donner au noyau des paramètres de lancement
ainsi qu'un "disque de démarrage" virtuel à charger en mémoire

contenant des programmes pour démarrer le système.
</p
><p align="justify">
Le noyau lance le processus <tt><font color="darkblue">init(8)</font
></tt
> sur son disque de démarrage.
S'il s'agit d'un disque de démarrage virtuel,
il va généralement donner la main au programme <code><font color="darkblue">init</font
></code
> du disque réel
après avoir chargé les gestionnaires de périphériques adéquats.
</p
><p align="justify">
Pour la suite, voir la documentation de <tt><font color="darkblue">init(8)</font
></tt
>,
sa vie son &oelig;uvre,
et ses fichiers de démarrage.
</p
><p align="justify">
La configuration de démarrage selon la convention System V,
et ses runlevels. 
</p
><a name="SECTION_3"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>3 Réflexes de base pour survivre</b
></font
></td
></tr
></table
><a name="SUBSECTION_3.1"></a
><font size="+1" face="sans-serif"><b>3.1 Survivre avec l'interface graphique</b
></font
><p align="justify">
C'est difficile à décrire seulement qu'avec des mots.
Suivez le cours.
</p
><p align="justify">
Le processus qui parle au matériel:
le serveur X.
Il accepte des connexions de <em>clients</em
>
en local ou sur le réseau,
qui communiquent en utilisant le protocole X11R6 avec diverses extensions
<a name="footnoteref42"></a
><a href="#footnote42"><sup><font size="-1">[42]</font
></sup
></a
>.
Lancer le serveur X quand il n'est pas lancé automatiquement: <code><font color="darkblue">startx</font
></code
>
<a name="footnoteref43"></a
><a href="#footnote43"><sup><font size="-1">[43]</font
></sup
></a
>.
</p
><p align="justify">
Attention:
<ul><li>À l'époque où les programmes X plus anciens ont été conçu,
toutes les souris UNIX avaient trois boutons;
mais on ne connaissaient ni le double-click, ni le bouton-laissé-enfoncé.
Donc, expérimenter avec l'interface de ces programmes
avec les trois boutons en ce sens...</li
><li>Si votre souris n'a que deux boutons, le serveur X peut être configuré
pour que les deux en même temps fassent bouton-du-milieu;
si cela vous gêne pour copier-coller, échangez les boutons 2 et 3
dans la configuration de votre serveur X, dans <code><font color="darkblue">/etc/X11/XF86Config-4</font
></code
>.</li
><li>Si le serveur X est vraiment planté, <code><font color="darkblue">Ctrl-Alt-BackSpace</font
></code
>.</li
><li>Pour changer de console virtuelle,
<code><font color="darkblue">Ctrl-Alt-F1</font
></code
> ... <code><font color="darkblue">Ctrl-Alt-F12</font
></code
>.</li
></ul
>
</p
><a name="SUBSECTION_3.2"></a
><font size="+1" face="sans-serif"><b>3.2 Savoir survivre avec la ligne de commande</b
></font
><p align="justify">
Pour lire le manuel d'une commande nommée <code><font color="darkblue">toto</font
></code
>: <code><font color="darkblue">man toto</font
></code
>.
Autres façons d'obtenir de l'aide (parfois):
<code><font color="darkblue">toto -h</font
></code
>
ou
<code><font color="darkblue">toto -\?</font
></code
>
ou
<code><font color="darkblue">toto --help</font
></code
>
ou
<code><font color="darkblue">toto -help</font
></code
>
ou simplement
<code><font color="darkblue">toto</font
></code
>.
</p
><p align="justify">
Si toto est un programme interactif,
essayer au cours du programme la commande <code><font color="darkblue">help</font
></code
> ou les touches:
                        <code><font color="darkblue">h</font
></code
>
			<code><font color="darkblue">?</font
></code
>
			<code><font color="darkblue">H</font
></code
>
			<code><font color="darkblue">Ctrl-H</font
></code
>
			<code><font color="darkblue">Alt-H</font
></code
>.
</p
><p align="justify">
Pour sortir d'une commande, essayer:
                        <code><font color="darkblue">q</font
></code
>
			<code><font color="darkblue">Q</font
></code
>
			<code><font color="darkblue">Ctrl-Q</font
></code
>
			<code><font color="darkblue">Ctrl-D</font
></code
>
</p
><p align="justify">
Pour interrompre une commande, essayer:
			<code><font color="darkblue">Ctrl-C</font
></code
>
			<code><font color="darkblue">Ctrl-\</font
></code
>
			<code><font color="darkblue">Ctrl-Z</font
></code
>.
</p
><p align="justify">
Votre shell est sans doute <tt><font color="darkblue">bash(1)</font
></tt
>
(mais je recommande de changer pour <tt><font color="darkblue">zsh(1)</font
></tt
> si vous le pouvez,
en utilisant <tt><font color="darkblue">chsh(8)</font
></tt
>),
donc pour avoir de l'aide à propos du shell:
                        <code><font color="darkblue">man bash</font
></code
>.
</p
><p align="justify">
Pour lire son courrier électronique:                    <code><font color="darkblue">mutt</font
></code
>
</p
><p align="justify">
Pour avoir la liste des fichiers:                       <code><font color="darkblue">ls</font
></code
>
</p
><p align="justify">
Pour connaître l'effet d'une commande:                  <code><font color="darkblue">type commande</font
></code
>
</p
><p align="justify">
Pour lister le contenu d'un fichier:                    <code><font color="darkblue">less fichier</font
></code
>
</p
><p align="justify">
Pour changer de répertoire:                             <code><font color="darkblue">cd</font
></code
>
</p
><p align="justify">
Pour quitter le shell:                                  <code><font color="darkblue">exit</font
></code
> ou parfois <code><font color="darkblue">logout</font
></code
> ou <tt><font color="brown">C-d</font
></tt
>
</p
><p align="justify">
Autres commandes courantes:
<code><font color="darkblue">zsh cp mv ln rm mkdir rmdir echo cat gzip tar grep cut ps</font
></code
>
</p
><a name="SUBSECTION_3.3"></a
><font size="+1" face="sans-serif"><b>3.3 Utiliser l'aide</b
></font
><p align="justify">
Une distribution Linux est vient typiquement
avec une documentation en-ligne extensive,
sans parler des sites sur internet
(voir la section "pour en savoir plus").
Il faut juste savoir où et comment regarder.
</p
><p align="justify">
Sous KDE, ouvrez le programme <code><font color="darkblue">khelpcenter</font
></code
>, et naviguez.
</p
><p align="justify">
Avec la ligne de commande,
vous disposez de la commande <tt><font color="darkblue">man(1)</font
></tt
> pour lire les pages de manuel,
de la commande <tt><font color="darkblue">info(1)</font
></tt
> (ou de <tt><font color="darkblue">emacs(1)</font
></tt
>) pour lire les pages info,
de <tt><font color="darkblue">lynx(1)</font
></tt
> (ou <tt><font color="darkblue">links(1)</font
></tt
> ou <tt><font color="darkblue">w3m(1)</font
></tt
>)
pour lire les fichiers html,
de la commande <tt><font color="darkblue">less(1)</font
></tt
> pour lire les fichiers textes,
ou <tt><font color="darkblue">zless(1)</font
></tt
> s'ils sont comprimés avec <tt><font color="darkblue">gzip(1)</font
></tt
>.
Les fichiers dvi peuvent être lus avec <tt><font color="darkblue">xdvi(1)</font
></tt
>
(ou <tt><font color="darkblue">advi(1)</font
></tt
> s'ils sont actifs);
les fichiers ps ou pdf peuvent être lus
avec <code><font color="darkblue">gv(1x)</font
></code
>, <tt><font color="darkblue">kghostview(1)</font
></tt
> ou <tt><font color="darkblue">ggv(1)</font
></tt
>;
les fichiers pdf peuvent aussi être lus avec
<tt><font color="darkblue">xpdf(1)</font
></tt
> ou <tt><font color="darkblue">acroread(1)</font
></tt
> (logiciel exclusif).
</p
><p align="justify">
Les pages de manuel sont dans <code><font color="darkblue">/usr/man</font
></code
>
et dans les autres répertoires de votre <code><font color="darkblue">$MANPATH</font
></code
>,
mais vous pouvez les consulter directement avec un nom de commande,
ou chercher un mot dans l'index avec <code><font color="darkblue">man -k <i>motclef</i
></font
></code
>.
Les pages <tt><font color="darkblue">info(1)</font
></tt
> sont dans <code><font color="darkblue">/usr/info</font
></code
>
et dans votre <code><font color="darkblue">$INFOPATH</font
></code
>.
De nombreux fichiers de documentation en mode texte ou en html
se trouvent selon la distribution
dans <code><font color="darkblue">/usr/doc</font
></code
> ou <code><font color="darkblue">/usr/share/doc</font
></code
>;
c'est là, dans un répertoire <code><font color="darkblue">HOWTO</font
></code
> qu'on trouve souvent
les notables documents du
<a href="http://fr.tldp.org/">Linux Documentation Projet</a
>
qui expliquent comment résoudre divers problèmes ciblés
quand on débute avec Linux, (et en fait même quand on connaît déjà Linux
mais qu'on débute avec le domaine du problème en question).
</p
><a name="SUBSECTION_3.4"></a
><font size="+1" face="sans-serif"><b>3.4 Pour en savoir plus</b
></font
><p align="justify">
Les pages de manuel (disponibles graphiquement avec
<code><font color="darkblue">khelpcenter</font
></code
>, ou par la ligne de commande avec <tt><font color="darkblue">man(1)</font
></tt
>)
sont une excellente référence,
mais ne sont pas orientées vers la résolution de problèmes spécifiques.
Heureusement, il existe de très nombreux documents sur Internet
écrits par des techniciens ayant déjà affronté les mêmes problèmes que vous,
et qui vous permettront de survivre.
<ul><li>
Tutoriels:
En français, voir sur
<a href="http://www.Linux-France.org/">Linux-France.org</a
>,
<a href="http://lea-linux.org/">lea-linux.org</a
>,
<a href="http://www.toolinux.com">toolinux.com</a
>,
<a href="http://www.commentcamarche.net">commentcamarche.net</a
>,
<a href="http://www.ac-creteil.fr/reseaux/systemes/linux/">ac-creteil.fr</a
>,
ou (avec parfois des spécificités de l'installation là-bas)
<a href="http://www.eleves.ens.fr/tuteurs/unix/">les tuteurs de l'ENS</a
>,
ou le
<a href="http://etna.int-evry.fr/COURS/UNIX/">Cours UNIX de l'INT EVRY</a
>.
En anglais, voir
<a href="http://www-106.ibm.com/developerworks/training/">chez IBM</a
> (notamment cette
<a href="http://www-106.ibm.com/developerworks/library/l-start.html">page de départ</a
>
et parmi les
<a href="http://www-106.ibm.com/developerworks/views/linux/tutorials.jsp">tutoriels</a
> ceux du programme LPI 101);
voir aussi des sites comme
<a href="http://www.comptechdoc.org/os/linux/">comptechdoc.org</a
>,
ou encore ce livre
<a href="http://rute.2038bug.com/rute.html.gz">Rute User's Tutorial and Exposition</a
>.
</li
><li>
La référence en matière de documentation pour Linux, c'est
<a href="http://www.tldp.org/">The Linux Documentation Project</a
>
(et leur pages
<a href="http://fr.tldp.org/">en français</a
>, pas toujours à jour):
voir notamment les
<a href="http://www.tldp.org/HOWTO/">HOWTO</a
> et 
<a href="http://www.tldp.org/HOWTO/mini/">mini-HOWTO</a
>,
ou les <a href="http://www.tldp.org/guides.html">Guides</a
>, etc.
Parmi ces guides, le
<a href="http://www.dsl.org/cookbook/">Linux Cookbook</a
>
par exemple offre des solutions aux problèmes de tous les jours.
À noter cependant qu'il existe aussi nombreux livres et documents
qui ne sont pas dans le LDP.
</li
><li>
Pour rechercher des informations ou des logiciels
sur un sujet donné, on pourra consulter les moteurs de recherche de
<a href="http://www.google.fr/linux/">Google Linux</a
>
ou de
<a href="http://www.freshmeat.net/">Freshmeat</a
> (logiciels).
</li
><li>
Outre des sites portails comme
<a href="http://www.linux.org/">Linux.org</a
>,
il y a de nombreux petits sites intéressants avec des petits tutoriels,
comme
<a href="http://linuxprocess.tuxfamily.org/documents.php">LinuxProcess</a
>,
ou encore
<a href="http://newbie.linuxbe.org/linux/">Newbie.linuxbe.org</a
> ou
<a href="http://www.linuxfr.free.fr/sections.php">linuxfr.free.fr</a
>.
Sans parler des cours comme
<a href="http://www.iro.umontreal.ca/~dift3830/">celui-ci</a
> ou
<a href="http://ecole.eu.org/doc/supports.html">ceux-là</a
>.
</li
><li>
Les principales distributions,
par un ordre subjectif de facilité d'abord:
<a href="http://www.mandrakelinux.com/">Mandrake</a
>,
<a href="http://www.suse.de/">SuSE</a
>,
<a href="http://www.redhat.com/">RedHat</a
>,
<a href="http://www.debian.org/">Debian</a
>,
<a href="http://www.gentoo.org/">Gentoo</a
>.
</li
><li>
Pour ceux qui aiment les outils GNU et voudraient les utiliser sous Windows:
<a href="http://sources.redhat.com/cygwin/">cygwin</a
>,
<a href="http://gnuwin.epfl.ch/fr/index.html">GNUWin</a
>.
Ne pas oublier votre éditeur préféré,

<a href="http://www.xemacs.org/">XEmacs</a
> ou
<a href="http://www.vim.org/">VIM</a
>.
</li
><li>
Sur le Luxembourg, ne manquez pas de faire un tour du côté de
<a href="http://www.linux.lu">LiLux</a
>.
Associations francophones en Europe:
<a href="http://www.aful.org/">AFUL</a
>,
<a href="http://www.april.org/">APRIL</a
>.
</li
><li>
Consulter les newsgroups et les mailing-lists
via <a href="http://groups.google.com">Google Groups</a
>,
ou se connecter sur IRC.
Avant de poser des questions,
n'oubliez pas de consulter la FAQ, surtout si vous êtes débutant,
et faites une recherche dans les archives récentes si elles sont disponibles.
Enfin, avant toute question sur tout sujet, cet article vous sera utile:
<a href="http://www.gnurou.org/documents/smart-questions-fr.html">Comment poser les questions de manière intelligente</a
>.
</li
></ul
>
</p
><a name="SUBSECTION_3.5"></a
><font size="+1" face="sans-serif"><b>3.5 Apprendre à utiliser un éditeur</b
></font
><p align="justify">
Si vous devenez un utilisateur expérimenté,
vous devrez apprendre à utiliser un éditeur de fichiers textes.
</p
><p align="justify">
Parmi les plus simples, il y a en mode graphique l'éditeur <code><font color="darkblue">kwrite</font
></code
>
qui suffit pour les besoins de tous les jours.
</p
><p align="justify">
L'éditeur visuel le plus universellement disponible
sous tous les systèmes UNIX est <tt><font color="darkblue">vi(1)</font
></tt
>;
pour pouvoir se sortir de cas extrêmes où on démarre
sur une disquette ou un système autrement restreint,
il est donc utile de savoir survivre sous <code><font color="darkblue">vi</font
></code
>.
Toutefois, en-dehors de cette utilisation, <code><font color="darkblue">vi</font
></code
> lui-même est à éviter.
Il existe par contre une version très améliorée et extensible de <code><font color="darkblue">vi</font
></code
>:
<tt><font color="darkblue">vim(1)</font
></tt
> (y compris la version intégrée à KDE, <tt><font color="darkblue">kvim(1)</font
></tt
>),
qui est un éditeur tout à fait décent;
je conseille ceux qui veulent apprendre <code><font color="darkblue">vi</font
></code
>
à lire le tutoriel de <code><font color="darkblue">vim</font
></code
>
et à se faire une <i>cheat sheet</i
> (demander à Google).
</p
><p align="justify">
La mère de tous les éditeurs, véritable système d'exploitation à lui tout seul,
écrit et extensible dans son propre dialecte de Lisp,
c'est <a href="http://www.emacswiki.org/">GNU EMACS</a
>.
Emacs se décline dans sa
<a href="http://www.gnu.org/software/emacs/">version officielle</a
> de la FSF,
ou dans la version rivale <a href="http://www.xemacs.org/">XEmacs</a
>.
Dotés de nombreux modules pour faciliter le développement de programmes
dans de très nombreux langages, ou pour lire son courrier, naviguer sur le web,
se connecter à des bases de données, etc.
Là encore, commencez par utiliser le tutoriel et par imprimer la
<i>reference card</i
>.
Vous trouverez aussi dans ces notes de cours,
à la section sur le shell en mode EMACS,
les quelques commandes les plus usuelles.
</p
><p align="justify">
Notez que vim, emacs et xemacs sont tous trois disponibles
sous Windows comme sous MacOS X,
et que les talents que vous acquerrez à les maîtriser
pourront donc être aussi mis à profit sur vos autres plateformes de travail.
</p
><a name="SUBSECTION_3.6"></a
><font size="+1" face="sans-serif"><b>3.6 Habitudes élémentaires de précaution</b
></font
><p align="justify">
Faites des sauvegardes régulières avec copie distante.
Par exemple, j'utilise <tt><font color="darkblue">rsync(1)</font
></tt
> avec une clef SSH
(créée par <tt><font color="darkblue">ssh-keygen(1)</font
></tt
>).
</p
><p align="justify">
Quand vous changez un fichier de configuration important,
dont le dysfonctionnement pourrait vous empêcher de plus vous connecter,
gardez ouverte une console
avec un shell tournant sous l'ancienne configuration
jusqu'à avoir vérifié que la nouvelle configuration tourne.
De même, ne changez rien au démarrage de votre machine
sans avoir une disquette ou un CD de démarrage à votre disposition.
Effectuez vos changements majeurs de distribution sous <tt><font color="darkblue">chroot(8)</font
></tt
>
et ne redémarrez qu'après avoir bien testé.
</p
><p align="justify">
Ai-je bien dit qu'il fallait faire
des sauvegardes régulières avec copie distante?
</p
><p align="justify">
Mettez vos fichiers de configuration importants
sur un serveur CVS ou équivalent
pour pouvoir récupérer les anciennes versions
qui marchaient et consulter les différences
qui auront déclenché un dysfonctionnement.
Je ne suis pas tout à fait au courant de l'offre,
mais on me dit
qu'<a href="http://www.linuxmafia.com/~rick/linux-info/scm.html">il y a mieux de nos jours</a
>:
j'utilise encore <a href="http://www.cvshome.org/">CVS</a
>,
mais de nos jours, <a href="http://subversion.tigris.org/">Subversion</a
>
fait tout ce que fait CVS en mieux et plus robuste et de façon quasi-compatible,
et il existe de nombreux logiciels qui proposent des approches plus intéressantes,
dont
<a href="http://gnuarch.org/">Arch</a
>,
<a href="http://bitconjurer.org/codeville/">Code*ville</a
>,
<a href="http://abridgegame.org/darcs/">DARCS</a
>,
<a href="http://users.footprints.net/~kaz/mcvs.html">Meta-CVS</a
>,
<a href="http://www.venge.net/monotone/">monotone</a
>,
<a href="http://www.opencm.org/">OpenCM</a
>.
Affaire à suivre.
</p
><p align="justify">
Au cas où je n'aurais pas été assez clair,
faites des sauvegardes régulières avec copie distante.
</p
><p align="justify">
Oh, j'allais oublier la règle la plus importante:
<b>faites des sauvegardes régulières avec copie distante</b
>.
</p
><a name="SUBSECTION_3.7"></a
><font size="+1" face="sans-serif"><b>3.7 Apprendre à programmer</b
></font
><p align="justify">
<i>La différence entre un programmeur et un utilisateur,
c'est que le programmeur sait qu'il n'y a pas de différence
entre programmation et utilisation.</i
>
Vous apprendrez donc à programmer, que vous en soyiez conscients ou pas.
Si vous devenez utilisateur expérimenté, autant vous y mettre consciemment.
Quelques soient les langages que vous apprendrez,
le meilleur moyen, après avoir parcouru des documents introductifs,
est lire des exemples simples en ayant le manuel sous la main.
Repérez donc des programmes simples utilisant le langage que vous apprenez,
et lisez-les, exécutez-les pas-à-pas, etc.
</p
><p align="justify">
Sur l'esprit général dans lequel le code linux existant est écrit,
voir par exemple
<a href="http://catb.org/~esr/writings/taoup/html/">TAOUP</a
>;
cela dit, il y a d'autres approches ou d'autres vues sur la programmation,
et si la programmation est un sujet qui vous passionne,
vous trouverez plus et mieux sur des sites adéquats.
</p
><a name="SUBSUBSECTION_3.7.1"></a
><p align="left"><b>3.7.1 Programmation shell</b
> </p
><p align="justify">
Pour survivre dans la vie de tous les jours,
il faut connaître un minimum votre shell:
<a href="http://directory.google.com/Top/Computers/Software/Operating_Systems/Unix/Shell/bash/">bash</a
>,
ou celui que je recommande, <a href="http://www.zsh.org/">zsh</a
>.
Si vous administrez une machine,
vous aurez souvent besoin d'écrire des petits <em>shell scripts</em
>,
ou du moins de modifier des scripts existant pour les adapter à vos besoins.
</p
><p align="justify">
Pour écrire des shells script portables,
il faut aussi savoir se limiter aux fonctionnalités du shell POSIX de base
(soupir!).
Mais pour vous-mêmes, n'hésitez pas
à utiliser toute la puissance de votre shell;
quoique si vous avez vraiment besoin de puissance,
choisissez un meilleur langage ci-dessous.
</p
><p align="justify">
Vous voudrez aussi sans doute configurer votre shell
pour le rendre plus convivial;
outre la documentation de votre shell (sur votre machine ou le site officiel)
et les fichiers d'exemples qui vont avec,
il y a des sites comme d'information comme
<a href="http://www.shelldorado.com/">shelldorado</a
>
<a name="footnoteref44"></a
><a href="#footnote44"><sup><font size="-1">[44]</font
></sup
></a
>.
</p
><a name="SUBSUBSECTION_3.7.2"></a
><p align="left"><b>3.7.2 Programmation de scripts</b
> </p
><p align="justify">
En administrant des machines,
vous voudrez souvent écrire des petits programmes, des <em>scripts</em
>,
qui automatiseront vos tâches,
lieront ensembles les programmes disparates que vous utiliserez, etc.
Plusieurs solutions s'offrent à vous:
<ul><li>
Le shell:
c'est moche, c'est lent, c'est compliqué, c'est fragile,
ça doit faire appel à des tas de programmes externes.
Mais c'est immédiatement disponible,
et vous n'avez qu'à récupérer et généraliser des commandes
que vous avez déjà tapées.
À n'utiliser que quand c'est nécessaire,
ou pour les cas les plus simples,
ou pour faire des <em>emballages</em
> (anglais: <em>wrappers</em
>)
autour de fonctionnalités offertes par de vrais programmes,
ou quand l'intégration au shell interactif est nécessaire.
</li
><li>
<a href="http://www.perl.org/">perl</a
>:
la «&nbsp;tronçonneuse de l'armée suisse&nbsp;» des outils Unix.
C'est moche, mais c'est pratique et ça fait tout, tout de suite.
Le perl est fascinant et peut offrir une gratification rapide.
Toutefois, l'abus de perl peut nuire gravement à la santé mentale.
Il est déconseillé de faire de la vraie programmation avec perl,
mais c'est possible, et si vous êtes déjà un fou du perl, autant en profiter.
</li
><li>
<a href="http://www.python.org/">python</a
>:
Un vrai langage de programmation, bien plus propre que perl,
et qui possède aussi une bibliothèque de fonctions très étendue,
des infrastructures de développement, etc.
</li
><li>
<a href="http://www.ruby.org/">ruby</a
>:
le rival de la bande, qui est plus avancé par de nombreux côtés,
mais un peu moins populaire, donc avec parfois moins de bibliothèques.
</li
><li>
scsh:
puissant et conceptuellement intéressant,
intégrant le shell-scripting à un vrai langage de programmation.
</li
><li>
tcl: à éviter absolument.
</li
><li>
Un vrai langage de programmation: voir ci-dessous.
</li
></ul
>
</p
><a name="SUBSUBSECTION_3.7.3"></a
><p align="left"><b>3.7.3 Langages de programmation sérieux</b
> </p
><p align="justify">
Dès que vous commencez à écrire un programme sérieux
(disons, plus de cinq mille lignes),
alors fuyez les langages de scripts,
et optez pour un vrai langage de programmation,
conçu pour faire de la programmation
propre, efficace, bien structurée, robuste, expressive, etc.
Voici les langages les plus adaptés à la programmation sérieuse,
qui offrent chacun à sa façon les paradigmes de programmation
fonctionnel, objet et générique, avec en plus des spécifités propres:
<ul><li>
<a href="http://caml.inria.fr/">OCaml</a
>:
de la programmation propre, bien structurée,
avec un compilateur ultra performant.
Un typage statique qui aide à structurer le code et éviter les erreurs.
Très bien à tous points de vue.
Excellent si vous partez d'un problème bien spécifié.
Ne faites plus de C, C++ ou Java, faites du Caml!
</li
><li>
<a href="http://www.cliki.net/">Common Lisp</a
>:
un langage pour faire de la programmation dynamique, incrémentale,
du développement rapide.
Le langage le plus expressif que vous puissiez trouver,
inégalable pour faire de l'exploration conceptuelle.
Possède des compilateurs performants
aussi bien que des interprètes instantanés.
Si vous voulez tenter ce qui n'a jamais été tenté auparavant,
ou si vous voulez des systèmes que vous pouvez corriger et mettre à jour
pendant qu'ils tournent, alors utilisez Common Lisp.
</li
><li>
<a href="http://www.erlang.org/">Erlang</a
>:
le must pour tout ce qui est programmation
massivement concurrente, répartie, robuste.
Comme Lisp, permet aussi la mise à jour dynamique pendant l'exécution.
Si vous avez un modèle conceptuel où des centaines de milliers d'activités
tournent en parallèle sur une à plusieurs milliers de machines
(exemple: opération d'un réseau téléphonique),
alors erlang est <em>le</em
> langage qu'il vous faut
pour que tout marche sur des roulettes, de façon robuste.
</li
></ul
>
</p
><p align="justify">
Si vous vous tournez vers la programmation,
il existe aussi de nombreux autres langages
chacun avec ses dialectes, qui pourront vous ouvrir l'esprit
vers de nouveaux horizons tout en vous permettant
de faire de la programmation sérieuse:
Haskell, Scheme, Mercury, Oz, etc.
Il y a de très nombreux langages de programmation.
Voir par exemple la page
<a href="http://tunes.org/wiki/Programming%20Languages">Programming Languages</a
> du
<a href="http://tunes.org/wiki/">wiki de TUNES</a
>.
</p
><a name="SUBSUBSECTION_3.7.4"></a
><p align="left"><b>3.7.4 Programmation système</b
> </p
><p align="justify">
Parfois, vous aurez besoin de descendre
dans des couches relativement basses du système,
ou du moins de comprendre ce qui s'y passe.
Pour cela, il vous faudra apprendre un langage d'implantation système,
même si dans la pratique,
il est recommandé de ne s'en servir qu'avec parcimonie,
et d'enrober les routines et bibliothèques écrites dans ces langages
pour utilisation dans un langage sérieux de haut niveau comme vu précédemment.
<ul><li>
C: le C est le langage dans lequel UNIX est défini et documenté.
Pour faire de la programmation système portable,
il faut en passer par du code C.
Même si ensuite vous faites de la programmation système en Caml ou en Lisp,
il vous faudra parfois comprendre la façon dont le C fonctionne
si vous interagissez finement avec le système.
Certaines bibliothèques de fonctions
ne sont directement accessibles que depuis C,
et il faut parfois écrire soi-même des <i>wrappers</i
>
pour les appeler depuis un autre langage.
Je déconseille le C pour tout ce qui dépasse une utilisation simple
ou une application résolument de bas niveau:
utilisez un des langages précédents.
</li
><li>
Assembleur: si vous avez des problèmes très bas niveau sur votre machine
(par exemple en implémentant un compilateur pour votre langage favori,
en gérant vous-même la récupération des <em>fautes de pages</em
> (anglais: <em>page faults</em
>)
et autres signaux que reçoivent vos programmes),
alors vous devrez apprendre l'assembleur.
L'assembleur varie d'un type de machine à une autre,
et il est donc stupide d'écrire de trop gros programmes en assembleur.
Il est fortement déconseillé d'utiliser l'assembleur
quand il n'est pas strictement nécessaire,
à moins que vous soyiez masochiste.
</li
></ul
>
</p
><p align="justify">
Si ces langages systèmes, de bas niveau,
permettent d'obtenir des performances supérieures dans des micro-benchmarks,
dans des programmes de taille raisonnable,
les langages de haut niveau les rattrapent
en permettant d'optimiser plus facilement
l'organisation des structures de données;
de plus, le cas échéant, il est toujours possible d'employer
après <em>profilage</em
> (anglais: <em>profiling</em
>)
(voir <code><font color="darkblue">man -k prof</font
></code
>)
un langage de bas niveau juste pour les quelques
<em>boucles fines</em
> (anglais: <em>tight loops</em
>)
qui occupent la majeure partie du temps de vos programmes.
</p
><a name="SUBSUBSECTION_3.7.5"></a
><p align="left"><b>3.7.5 Programmation ennuyeuse</b
> </p
><p align="justify">
Il est des langages de programmation
qui offrent de mauvais compromis techniques,
mais qui sont néanmoins répandus,
pour des raisons économico-politiques.
Ils sont aussi disponibles sous Linux.
<ul><li>
Java: le langage médiocre par excellence.
Il fait tout, mais jamais rien de vraiment bien (ni de vraiment mal non plus).
Il peut être portable, mais en fait pas beaucoup plus que ses rivaux,
ou alors au prix d'une baisse de fonctionnalité
(et ses rivaux aussi proposent des compromis similaires).
Aucune raison technique de jamais l'utiliser,
sauf à vouloir passer trois fois plus de temps que nécessaire sur un problème
pour obtenir un résultat trois fois plus lent qu'avec autre chose.
Seul intérêt, l'intégration très répandue avec les navigateurs web;
mais alors, considérer <a href="http://www.openlaszlo.org/">OpenLaszlo</a
>.
</li
><li>
C++: avec C++, on peut faire des programmes performants <em>ou</em
> élaborés,
mais rarement les deux à la fois.
Il faut savoir se restreindre à un petit sous-ensemble du langage,
ou la complexité devient ingérable.
La gestion de la mémoire devient vite infernale,
à moins d'utiliser le GC de Hans Boehm.
Lui préférer un des langages précédents.
Toutefois, nécessaire pour programmer avec le bureau graphique KDE
(quoique, il y a bien des extensions de Perl ou Python
pour utiliser Qt et KDE).
À éviter, sauf pour les experts capables de jouer les funambules.
</li
></ul
>
</p
><a name="SECTION_4"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>4 Le shell et ses amis</b
></font
></td
></tr
></table
><a name="SUBSECTION_4.1"></a
><font size="+1" face="sans-serif"><b>4.1 Shell 101</b
></font
><a name="SUBSUBSECTION_4.1.1"></a
><p align="left"><b>4.1.1 La notion de shell</b
> </p
><p align="justify">
Dans la terminologie UNIX, un <i>shell</i
>
est un logiciel qui offre à l'utilisateur
une interface vers l'ensemble du système.
Littéralement, le mot signifie coquille,
et indique bien que c'est le composant le plus extérieur du système,
directement en contact avec l'utilisateur,
par opposition au noyau qui est au c&oelig;ur du système
et aux applications entre les deux.
</p
><p align="justify">
Si on peut considérer
que l'interface graphique GNOME ou KDE constitue un shell,
et si l'éditeur EMACS est effectivement utilisé par certains
comme un shell dans tous les sens du termes,
on réserve l'appellation de shell au sens strict
à des programmes conçus pour fonctionner dans un terminal
en interprétant les commandes de l'utilisateur ligne-à-ligne,
et en lançant les programmes spécifiés.
</p
><p align="justify">
Le shell est le sel et la terre de l'utilisateur UNIX expérimenté:
<ul><li>
C'est à partir du shell que vous explorerez le système
et lancerez vos commandes dès qu'elles seront un tant soit peu élaborées.
</li
><li>
C'est avec le shell que vous écrirez des <i>scripts</i
>,
petits programmes automatisant les tâches ancillaires de votre ordinateur.
</li
><li>
C'est entre autre avec le shell que vous intégrerez les divers logiciels
qui composent le système.
</li
><li>
Même si vous trouvez, non sans raisons,
que le shell est un bricolage ringard de mauvais goût,
il vous faudra comprendre l'usage qui en est fait
par les scripts livrés avec le système
et les logiciels que vous lui intégrerez.
</li
></ul
>
</p
><p align="justify">
Sur le sujet de ligne de commande par opposition à l'interface graphique,
voir l'article célèbre de Neal Stephenson
<a href="http://artlung.com/smorgasborg/C_R_Y_P_T_O_N_O_M_I_C_O_N.shtml"><i>In the beginning was the command line</i
></a
>
(aussi
<a href="http://steve-parker.org/articles/others/stephenson/">ici</a
>
ou
<a href="http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/">là</a
>
voire sur le
<a href="http://www.cryptonomicon.com/beginning.html">site original</a
>).
</p
><a name="SUBSUBSECTION_4.1.2"></a
><p align="left"><b>4.1.2 L'offre disponible</b
> </p
><p align="justify">
Il existe de nombreux shells:
<tt><font color="darkblue">ash(1)</font
></tt
>, <tt><font color="darkblue">bash(1)</font
></tt
>, <tt><font color="darkblue">csh(1)</font
></tt
>, <tt><font color="darkblue">dash(1)</font
></tt
>, <tt><font color="darkblue">posh(1)</font
></tt
>, <tt><font color="darkblue">ksh(1)</font
></tt
>,
<tt><font color="darkblue">pdksh(1)</font
></tt
>, <tt><font color="darkblue">rc(1)</font
></tt
>, <tt><font color="darkblue">tcsh(1)</font
></tt
>, <tt><font color="darkblue">zsh(1)</font
></tt
>,
sans parler de shells spéciaux pour systèmes de secours
comme <tt><font color="darkblue">busybox(1)</font
></tt
>, <tt><font color="darkblue">kiss(1)</font
></tt
> ou <tt><font color="darkblue">sash(1)</font
></tt
>,
variantes que je ne traiterai pas davantage ici <a name="footnoteref45"></a
><a href="#footnote45"><sup><font size="-1">[45]</font
></sup
></a
>.
</p
><p align="justify">
Le standard POSIX, repris par la norme SUS, 
définit ce que sait faire le shell standard de base <code><font color="darkblue">/bin/sh</font
></code
>.
La plupart des shells reprennent ce standard
et l'étendent avec des fonctionnalités spécifiques.
GNU <tt><font color="darkblue">bash(1)</font
></tt
> est le premier parmi ceux-là,
et à l'époque où tous les marchands d'UNIX exclusifs
livraient des shells antiques et bogués jusqu'à la moëlle,
il s'est imposé comme standard de fait chez les utilisateurs expérimentés;
il est aujourd'hui le plus répandu dans le monde Linux,
et un standard officiel du
<a href="http://www.linuxbase.org">Linux Standard Base</a
>.
Aussi, dans la plupart des distributions,
<code><font color="darkblue">/bin/sh</font
></code
> est un lien symbolique ou dur vers <code><font color="darkblue">/bin/bash</font
></code
>
(qui détecte qu'il a été appelé comme <code><font color="darkblue">sh</font
></code
>
et adapte son comportement en correspondance
pour être le plus compatible possible).
Cela au point que parfois,
des programmes censés marcher sur n'importe quel UNIX
dépendent en fait de fonctionnalités spécifiques à <tt><font color="darkblue">bash(1)</font
></tt
>,
ce qui est en général une erreur non intentionnelle de la part du développeur.
</p
><p align="justify">
<tt><font color="darkblue">csh(1)</font
></tt
> et son successeur <tt><font color="darkblue">tcsh(1)</font
></tt
>
utilisent une syntaxe notablement différente du shell POSIX,
et qui se veut plus proche du langage C.
Durant l'époque précédent l'émergence de Linux
et la victoire populaire de <tt><font color="darkblue">bash(1)</font
></tt
>,
ils ont eu un certain succès,
mais il n'y a aucune particulière raison de s'y intéresser de nos jours,
à part pour déboguer un rare script issu de temps anciens.
</p
><p align="justify">
<tt><font color="darkblue">ksh(1)</font
></tt
> se veut le nouveau standard officiel parmi les systèmes UNIX exclusifs,
et possède de nombreuses extensions en faisant
un langage bien plus raisonnable que <code><font color="darkblue">sh</font
></code
> pour l'écriture de scripts.
Cependant, comme il a longtemps été un logiciel exclusif,
il n'a jamais été très répandu, et n'a finalement rien de spécial à offrir,
puisque pour tout script avancé,
on lui préférera de loin <tt><font color="darkblue">perl(1)</font
></tt
> ou un autre langage plus avancé,
cependant qu'en terme de fonctionnalités interactives,
il pêche devant <tt><font color="darkblue">bash(1)</font
></tt
> ou <tt><font color="darkblue">zsh(1)</font
></tt
>.
Pendant que <tt><font color="darkblue">ksh(1)</font
></tt
> n'était pas libre,
une version libre rivale <tt><font color="darkblue">pdksh(1)</font
></tt
> a été développée,
qui n'est pas forcément compatible à 100% avec le <tt><font color="darkblue">ksh(1)</font
></tt
> officiel.
</p
><p align="justify">
<tt><font color="darkblue">ash(1)</font
></tt
> ou <tt><font color="darkblue">dash(1)</font
></tt
> est la version BSD du shell POSIX,
qui colle au plus près à la norme, avec quelques rares extensions.
À quoi bon s'y restreindre? À être sûr que vos shell-scripts sont portables.
Shell minimal inventé juste pour vérifier la portabilité des scripts: <tt><font color="darkblue">posh(1)</font
></tt
>.
</p
><p align="justify">
<tt><font color="darkblue">rc(1)</font
></tt
>, issu du système expérimental Plan9,
se veut un redesign mieux conçu du shell,
de même que Plan9 était un redesign mieux conçu d'Unix
(mais qui, n'étant pas libre, a manqué son occasion de percer).
Incompatible, pauvre en fonctionnalités,
il a fait quelques émules, mais n'est pas si extraordinaire que ça.
</p
><p align="justify">
Mon préféré est <tt><font color="darkblue">zsh(1)</font
></tt
>, le «&nbsp;shell ultime&nbsp;»
qui reprend les meilleures idées de
<tt><font color="darkblue">sh(1)</font
></tt
>, <tt><font color="darkblue">bash(1)</font
></tt
>, <tt><font color="darkblue">tcsh(1)</font
></tt
> et <tt><font color="darkblue">ksh(1)</font
></tt
>,
et possède même des modes de compatibilité
<code><font color="darkblue">sh</font
></code
>, <tt><font color="darkblue">bash(1)</font
></tt
>, et <tt><font color="darkblue">ksh(1)</font
></tt
>
(et aussi <code><font color="darkblue">csh</font
></code
> mais de façon incomplète).
Mais surtout, il possède un grand nombre de fonctionnalités,
y compris un mode de complétion programmable,
un éditeur intégré,
et il est très très configurable et très très extensible
avec des modules dynamiquement chargés. Pourquoi s'en priver?
</p
><p align="justify">
On peut changer le shell par défaut d'un utilisateur
avec la commande <tt><font color="darkblue">chsh(8)</font
></tt
>
<a name="footnoteref46"></a
><a href="#footnote46"><sup><font size="-1">[46]</font
></sup
></a
>.
Les administrateurs téméraires pourront éditer directement
le <code><font color="darkblue">/etc/passwd</font
></code
>
<a name="footnoteref47"></a
><a href="#footnote47"><sup><font size="-1">[47]</font
></sup
></a
>.
Il faut se reloguer pour que la modification prenne effet.
</p
><a name="SUBSUBSECTION_4.1.3"></a
><p align="left"><b>4.1.3 Quel shell apprendre?</b
> </p
><p align="justify">
Je vous enseignerai ici le <tt><font color="darkblue">bash(1)</font
></tt
>, qui est le standard sous Linux,
tout en précisant parfois dans quelques notes les différences
pour le shell POSIX <code><font color="darkblue">sh</font
></code
> et le «&nbsp;shell ultime&nbsp;» <tt><font color="darkblue">zsh(1)</font
></tt
>.
</p
><p align="justify">
Pour apprendre votre shell en détail,
je vous invite toutefois à consulter la page de manuel,
à regarder la configuration par défaut sur votre système,
à lire les fichiers d'exemples livrés avec le shell,
à visionner les sources de shell-scripts utilisant votre shell.
</p
><a name="SUBSUBSECTION_4.1.4"></a
><p align="left"><b>4.1.4 Principe de base du shell</b
> </p
><p align="justify">
Le shell offre une interface en <em>ligne de commande</em
> (anglais: <em>command line</em
>):
un interacteur permet à l'utilisateur d'éditer une ligne de texte
qui spécifie une commande à exécuter.
</p
><p align="justify">
L'interacteur se reconnaît généralement à l'<em>invite</em
> (anglais: <em>prompt</em
>)
qu'il affiche avant chaque commande.
On peut typiquement personnaliser cette invite
(grâce à une variable d'environnement nommée <code><font color="darkblue">PS1</font
></code
> ou <code><font color="darkblue">PROMPT</font
></code
>),
de façon à afficher le répertoire courant, l'heure,
le nom de l'utilisateur ou de la machine actuelle,
ou toute autre information pertinente <a name="footnoteref48"></a
><a href="#footnote48"><sup><font size="-1">[48]</font
></sup
></a
>.
</p
><p align="justify">
Quand on confirme la commande en appuyant sur la touche entrée,
le shell lit la ligne qu'il analyse comme un petit programme qu'il exécute.
Dans le cas habituel, le plus simple,
le programme est une commande simple suivie d'arguments;
le shell lance alors ladite commande avec les arguments spécifiés.
Ainsi, la commande <code><font color="darkblue">ls -l /bin</font
></code
>
appellera typiquement la commande externe <code><font color="darkblue">ls</font
></code
>
avec comme arguments l'option <code><font color="darkblue">-l</font
></code
> d'une part
et le nom de répertoire <code><font color="darkblue">/bin</font
></code
> d'autre part.
</p
><a name="SUBSUBSECTION_4.1.5"></a
><p align="left"><b>4.1.5 Vos premières commandes</b
> </p
><p align="justify">
Vous pouvez essayer les commandes suivantes,
et utiliser en parallèle <code><font color="darkblue">konqueror</font
></code
>
pour essayer de visualiser l'effet de ces commandes:
<pre>echo 'Hello, world!'   # affiche des informations
kwrite toto.txt        # édite un fichier
pwd         # affiche le répertoire actuel
ls          # affiche les fichiers dans le répertoire actuel
cd ..       # change le répertoire actuel au répertoire père
pwd         # affiche le répertoire actuel (après cette modification)
ls          # affiche les fichiers dans ce nouveau répertoire
ls -l       # affiche les même fichiers avec davantage d'information
ls -la ~    # le contenu de votre répertoire personnel avec ses fichiers cachés
ls -ld .    # informations sur le répertoire actuel lui-même
ls -F       # ajoute des symboles 
cd /        # va dans le répertoire racine
ls
cd bin      # répertoire des programmes de base du système UNIX
pwd
ls
cd /usr/bin # répertoire avec de nombreux programmes
pwd
ls
cd          # dans quel répertoire vous transporte cette commande?
pwd         # dans votre répertoire personnel!
ls
</pre
>
</p
><a name="SUBSECTION_4.2"></a
><font size="+1" face="sans-serif"><b>4.2 Interaction avec le Shell</b
></font
><a name="SUBSUBSECTION_4.2.1"></a
><p align="left"><b>4.2.1 Édition de ligne avec le shell</b
> </p
><p align="justify">
Les shells modernes comme <tt><font color="darkblue">bash(1)</font
></tt
> <tt><font color="darkblue">tcsh(1)</font
></tt
> <tt><font color="darkblue">zsh(1)</font
></tt
>
gèrent directement l'interaction avec le terminal,
et vous offrent de nombreuses facilités pour vous simplifier la vie.
Ils peuvent traditionnellement fonctionner selon deux modes,
le mode <code><font color="darkblue">emacs</font
></code
> ou le mode <code><font color="darkblue">vi</font
></code
>,
dont le comportement imite chacun celui
d'un des deux éditeurs traditionnels les plus populaires du monde Unix.
<em>Je vous enseignerai le mode <code><font color="darkblue">emacs</font
></code
>,
qui est le mode par défaut</em
>;
lisez le manuel pour le mode <code><font color="darkblue">vi</font
></code
>.
</p
><p align="justify">
Pour <tt><font color="darkblue">bash(1)</font
></tt
>, l'éditeur intégré s'appelle <tt><font color="darkblue">readline(3)</font
></tt
>
et est configurable via le fichier <code><font color="darkblue">~/.inputrc</font
></code
>
(voir <code><font color="darkblue">man 1 bash</font
></code
> ou <code><font color="darkblue">man 3 readline</font
></code
>).
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, l'éditeur intégré s'appelle <code><font color="darkblue">zle</font
></code
>
est avec la commande <code><font color="darkblue">bindkey</font
></code
>
à appeler depuis votre <code><font color="darkblue">~/.zshrc</font
></code
> ou interactivement
(voir <code><font color="darkblue">man 1 zshzle</font
></code
>).
Notez que de dans le monde UNIX, de nombreux autres programmes interactif,
en mode texte ou en mode graphique,
utilisent des combinaisons de touches directement inspirées de EMACS,
voire utilisent directement <tt><font color="darkblue">readline(3)</font
></tt
>.
</p
><p align="justify">
<u>Note</u
>:
par convention du monde EMACS,
on écrit <tt><font color="brown">C-r</font
></tt
> pour <tt><font color="brown">Contrôle-r</font
></tt
>,
c'est-à-dire laisser enfoncer la touche modificatrice <tt><font color="brown">Ctrl</font
></tt
>,
puis la touche <code><font color="darkblue">R</font
></code
>,
relâcher le <tt><font color="brown">R</font
></tt
> puis la touche <tt><font color="brown">Ctrl</font
></tt
>.
On écrit <tt><font color="brown">M-x</font
></tt
> pour <tt><font color="brown">Méta-x</font
></tt
>,
la touche <tt><font color="brown">Méta</font
></tt
> étant souvent celle avec l'étiquette <tt><font color="brown">Alt</font
></tt
>
sur les claviers de PC.
Dans un terminal, <tt><font color="brown">M-x</font
></tt
> est équivalent
à la séquence d'échappement <tt><font color="brown">ESC x</font
></tt
>.
La touche d'échappement <tt><font color="brown">ESC</font
></tt
> est aussi équivalente à <tt><font color="brown">C-[</font
></tt
>.
</p
><a name="SUBSUBSECTION_4.2.2"></a
><p align="left"><b>4.2.2 Le shell en mode EMACS</b
> </p
><p align="justify">
<u>Déplacement sur la ligne actuelle</u
>:
flèche gauche ou <tt><font color="brown">C-b</font
></tt
> (back) pour caractère précédent,
flèche droite ou <tt><font color="brown">C-f</font
></tt
> (forward) pour caractère suivant.
Prochain mot: <tt><font color="brown">M-f</font
></tt
>,
précédent mot: <tt><font color="brown">C-b</font
></tt
>.
Début de ligne avec <tt><font color="brown">Home</font
></tt
> ou <tt><font color="brown">C-a</font
></tt
>,
fin de ligne avec <tt><font color="brown">End</font
></tt
> ou <tt><font color="brown">C-e</font
></tt
>.
</p
><p align="justify">
<u>Effacement</u
>:
<tt><font color="brown">Delete</font
></tt
> ou <tt><font color="brown">C-d</font
></tt
> pour détruire le caractère suivant,
<tt><font color="brown">BackSpace</font
></tt
> pour détruire le caractère précédent
<a name="footnoteref49"></a
><a href="#footnote49"><sup><font size="-1">[49]</font
></sup
></a
>.
<tt><font color="brown">C-u</font
></tt
> pour effacer toute la ligne,
ou <tt><font color="brown">C-w</font
></tt
> pour effacer le mot précédent
(non disponibles sous EMACS proprement dit).
Effacer la fin de la ligne: <tt><font color="brown">C-k</font
></tt
>
</p
><p align="justify">
<u>Copier/Couper-Coller</u
>:
<tt><font color="brown">C-y</font
></tt
> pour récupérer le groupe de caractères
dernièrement effacé ou sélectionné.
<tt><font color="brown">C-SPC</font
></tt
> pour marquer le début d'une zone à sélectionner,
<tt><font color="brown">M-w</font
></tt
> pour sélectionner la zone depuis le marqueur précédent.
(ces derniers non disponibles sous <tt><font color="darkblue">bash(1)</font
></tt
>.)
</p
><p align="justify">
<u>Récupérer les commandes précédentes</u
>:
flèche haute ou <tt><font color="brown">C-p</font
></tt
> (previous) pour la précédente,
flèche basse ou <tt><font color="brown">C-n</font
></tt
> (next) pour la suivante.
Recherche en arrière avec <tt><font color="brown">C-r</font
></tt
> ou en avant avec <tt><font color="brown">C-s</font
></tt
>.
</p
><p align="justify">
<u>Annulation</u
>:
Annuler la recherche ou toute autre opération spéciale en cours: <tt><font color="brown">C-g</font
></tt
>.
Annuler la ligne actuelle ou interrompre une commande: <tt><font color="brown">C-c</font
></tt
>,
très pratique si on ne sait plus où on en est
question guillemets et parenthèses.
Sous <tt><font color="darkblue">emacs(1)</font
></tt
> ou <tt><font color="darkblue">zsh(1)</font
></tt
>,
<tt><font color="brown">C-x u</font
></tt
> pour annuler une modification durant l'édition,
plusieurs fois pour en annuler plus
(non disponible sous <tt><font color="darkblue">bash(1)</font
></tt
>).
</p
><p align="justify">
<u>Entrer un caractère spécial directement</u
>: <tt><font color="brown">C-v</font
></tt
>.
Vous aurez peut-être <em>en plus</em
> à le mettre entre guillemets.
Notez que sous EMACS proprement dit,
<tt><font color="brown">C-v</font
></tt
> sert à passer à la page suivante
cependant que <tt><font color="brown">M-v</font
></tt
> va à la page précédente,
et il faut utiliser <tt><font color="brown">C-q</font
></tt
> pour l'effet ci-dessus.
</p
><a name="SUBSUBSECTION_4.2.3"></a
><p align="left"><b>4.2.3 La complétion</b
> </p
><p align="justify">
Parce qu'ils passent du temps sur leur ligne de commande,
les utilisateurs d'UNIX ont de nombreux trucs pour accélérer la frappe.
Outre l'édition de ligne et son couper-coller,
un truc important est la completion:
sous un shell moderne,
utilisez la touche <tt><font color="brown">Tab</font
></tt
>
pour compléter le nom d'un fichier ou d'une variable
que vous avez commencé à taper.
</p
><p align="justify">
Quand il y a plusieurs fins possibles,
le shell complète jusqu'à l'endroit où il faut choisir.
Vous pouvez avoir la liste des choix disponibles
sous <tt><font color="darkblue">bash(1)</font
></tt
>, en appuyant sur <tt><font color="brown">ESC ESC</font
></tt
> ou <tt><font color="brown">Tab</font
></tt
>.
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, la touche <tt><font color="brown">C-d</font
></tt
> en fin de ligne
permet de voir la liste des choix disponibles
<a name="footnoteref50"></a
><a href="#footnote50"><sup><font size="-1">[50]</font
></sup
></a
>
et la touche <tt><font color="brown">Tab</font
></tt
> propose chacun son tour chacun des choix possibles.
</p
><p align="justify">
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>,
la complétion est particulièrement puissante,
et est de plus programmable;
vous pouvez ainsi inclure dans votre configuration zsh
des complétions adaptées spécifiquement
à chacun des programmes que vous utilisez,
plutôt que toujours des noms de fichiers.
</p
><a name="SUBSUBSECTION_4.2.4"></a
><p align="left"><b>4.2.4 Le terminal sans éditeur</b
> </p
><p align="justify">
Les antiques shells standards d'UNIX
<tt><font color="darkblue">sh(1)</font
></tt
> <tt><font color="darkblue">csh(1)</font
></tt
> ou vieux <tt><font color="darkblue">ksh(1)</font
></tt
>,
ainsi que la plupart des programmes conçus pour être invoqués depuis le shell,
n'ont pas d'édition de ligne.
À défaut de mieux, le gestionnaire de terminal inclus dans le noyau
peut gérer pour ces programmes qui ne veulent pas s'en soucier
une édition de ligne rudimentaire.
</p
><p align="justify">
Dans son mode par défaut,
le noyau n'enverra au programme lecteur le texte saisi
qu'après réception de la touche entrée;
cela lui permet de gérer entre autres choses
l'effacement arrière (<tt><font color="brown">BackSpace</font
></tt
>)
et l'annulation de la ligne (<tt><font color="brown">C-u</font
></tt
>),
ainsi que le signal de fin de fichier (<tt><font color="brown">C-d</font
></tt
> en début de ligne).
Le noyau enverra un signal d'interruption (<code><font color="darkblue">kill -INT</font
></code
>)
au processus courant si on appuie sur la touche <tt><font color="brown">C-c</font
></tt
>,
et un signal de fin prématurée (<code><font color="darkblue">kill -QUIT</font
></code
>)
si on appuie sur la touche <tt><font color="brown">C-\</font
></tt
>,
ou encore un signal d'arrêt momentané (<code><font color="darkblue">kill -STOP</font
></code
>)
si on appuie sur la touche <tt><font color="brown">C-z</font
></tt
>
(voir la section job control ci-dessous).
</p
><p align="justify">
On peut ainsi signaler aux programmes qui lisent leur entrée
sur l'entrée standard que cette entrée est terminée
en leur envoyant une fin de fichier.
Si un programme tarde trop à répondre,
on peut l'arrêter définitivement avec <tt><font color="brown">C-c</font
></tt
>
ou momentanément avec <tt><font color="brown">C-z</font
></tt
>
(et le reprendre avec la commande <code><font color="darkblue">fg</font
></code
>).
</p
><p align="justify">
Pour plus de détails sur les façons d'interagir avec le terminal,
voir la section sur le terminal.
</p
><a name="SUBSECTION_4.3"></a
><font size="+1" face="sans-serif"><b>4.3 Commandes simples</b
></font
><a name="SUBSUBSECTION_4.3.1"></a
><p align="left"><b>4.3.1 Invocation d'une commande</b
> </p
><p align="justify">
La syntaxe la plus simple pour une commande est
une liste constituée par le nom de la commande suivi par ses arguments,
les composants de la liste étant séparés par un ou plusieurs espacements.
</p
><p align="justify">
Exemple: <code><font color="darkblue">ls -l /bin</font
></code
>
lancera la commande <code><font color="darkblue">ls</font
></code
> avec les arguments <code><font color="darkblue">-l</font
></code
> et <code><font color="darkblue">/bin</font
></code
>.
</p
><p align="justify">
Si la commande est parmi la liste des
<em>commandes internes au shell</em
> (anglais: <em>shell built-in commands</em
>)
telle que documentée dans le manuel,
ou une fonction définie par l'utilisateur
alors ladite commande sera exécutée.
</p
><p align="justify">
Sinon, le shell créera un nouveau processus qui exécutera
une commande externe.
Si le nom de la commande est un chemin d'accès (absolu ou relatif)
spécifiant un répertoire, alors il spécifiera le programme à exécuter
(utiliser <code><font color="darkblue">./<i>foo</i
></font
></code
> pour préciser le répertoire actuel).
Si ce nom ne comporte pas de répertoire, alors le shell
ira chercher dans chacun des répertoires définis
dans la variable d'environnement <code><font color="darkblue">PATH</font
></code
>
si un programme de ce nom existe, et exécutera le premier
<a name="footnoteref51"></a
><a href="#footnote51"><sup><font size="-1">[51]</font
></sup
></a
>.
Si aucun programme n'est trouvé dans le <code><font color="darkblue">$PATH</font
></code
>,
ou que l'utilisateur ne possède pas
les droits d'accès en exécution sur ledit programme,
alors le shell renvoie une erreur <a name="footnoteref52"></a
><a href="#footnote52"><sup><font size="-1">[52]</font
></sup
></a
>.
</p
><a name="SUBSUBSECTION_4.3.2"></a
><p align="left"><b>4.3.2 Commandes pour s'en sortir avec les fichiers</b
> </p
><p align="justify">
Les commandes suivantes permettent de manipuler les fichiers
à partir du shell textuel.
Pour des cas simples, cela n'apporte rien par rapport à l'interface graphique;
par contre, l'interface textuelle pourra être automatisée et fiabilisée.
<ul><li>
<code><font color="darkblue">cd</font
></code
>
</li
><li>
<code><font color="darkblue">pwd</font
></code
>
</li
><li>
<tt><font color="darkblue">cp(1)</font
></tt
>
</li
><li>
<tt><font color="darkblue">mv(1)</font
></tt
>
</li
><li>
<tt><font color="darkblue">ln(1)</font
></tt
>
</li
><li>
<tt><font color="darkblue">rm(1)</font
></tt
>
&mdash; <b>Attention!</b
> commande irréversible
<a name="footnoteref53"></a
><a href="#footnote53"><sup><font size="-1">[53]</font
></sup
></a
>
<a name="footnoteref54"></a
><a href="#footnote54"><sup><font size="-1">[54]</font
></sup
></a
>
</li
><li>
<tt><font color="darkblue">mkdir(1)</font
></tt
>
</li
><li>
<tt><font color="darkblue">rmdir(1)</font
></tt
>
</li
></ul
>
</p
><a name="SUBSUBSECTION_4.3.3"></a
><p align="left"><b>4.3.3 Conventions d'appel pour les commandes</b
> </p
><p align="justify">
Une commande prend un nom de commande suivi de paramètres,
dont des options. <a name="footnoteref55"></a
><a href="#footnote55"><sup><font size="-1">[55]</font
></sup
></a
>
</p
><p align="justify">
Les options conventionnellement généralement par un caractère '-'.
De nombreuses commandes acceptent de grouper plusieurs options simples
derrière un seul '-':
<code><font color="darkblue">cp -ax /foo /bar</font
></code
>
au lieu de <code><font color="darkblue">cp -a -x /foo /bar</font
></code
>,
ou <code><font color="darkblue">tar -zxvf foo.tar.gz</font
></code
>
au lieu de <code><font color="darkblue">tar -z -x -v -f foo.tar.gz</font
></code
>.
De nombreuses commandes ont des options avec un nom long,
et la convention aujourd'hui dominante est que de telles options
doivent être introduites par deux caractères '-':
<code><font color="darkblue">cp --help</font
></code
>.
De nombreux programmes suivent la convention supplémentaire
selon laquelle le caractère '+' est employé pour désactiver l'option
activée avec le caractère '-'.
Certaines options sont suivies d'un chemin d'accès à un fichier,
d'un nombre ou d'un autre paramètre.
</p
><p align="justify">
La seule façon fiable de savoir comment fonctionne une commande,
c'est de lire sa documentation: <code><font color="darkblue">man <i>nom_de_commande</i
></font
></code
>.
Les <em>commandes internes</em
> (anglais: <em>builtin commands</em
>) de votre shell
sont décrites dans la page de manuel dudit shell:
<code><font color="darkblue">man bash</font
></code
> ou <code><font color="darkblue">man zshbuiltins</font
></code
>.
</p
><p align="justify">
Le shell lui-même possède des options
(très nombreuses dans le cas de <tt><font color="darkblue">zsh(1)</font
></tt
>),
documentées dans le manuel.
À fins d'inspection (pour débogage notamment),
on peut appeler le shell avec l'option <code><font color="darkblue">-x</font
></code
>
pour tracer les commandes.
Ou on peut l'activer durant l'exécution avec <code><font color="darkblue">set -x</font
></code
>
ou la désactiver avec <code><font color="darkblue">set +x</font
></code
>.
Sous <tt><font color="darkblue">bash(1)</font
></tt
>, on préférera <code><font color="darkblue">shopt</font
></code
> pour changer les options.
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, on préférera <code><font color="darkblue">setopt</font
></code
>.
Notez sous <tt><font color="darkblue">zsh(1)</font
></tt
> l'option <code><font color="darkblue">LOCAL_OPTIONS</font
></code
>
pour ne changer des options qu'à l'intérieur de la fonction actuelle.
</p
><a name="SUBSECTION_4.4"></a
><font size="+1" face="sans-serif"><b>4.4 Expansion des commandes par le shell</b
></font
><p align="justify">
Principe supplémentaire:
avant d'exécuter votre commande comme un petit programme,
le shell va d'abord procéder à une <i>expansion</i
> de la commande,
remplaçant textuellement diverses parties de la commande
par le résultat de calculs simples,
déclenchés par la présence de
<em>caractères spéciaux</em
> (anglais: <em>special characters</em
>)
dans la commande originale.
Le processus d'expansion est décrit en détail
dans la section <code><font color="darkblue">EXPANSION</font
></code
> de la page de manuel de <tt><font color="darkblue">bash(1)</font
></tt
>,
ou dans la page <tt><font color="darkblue">zshexpn(1)</font
></tt
> en ce qui concerne <tt><font color="darkblue">zsh(1)</font
></tt
>.
Cette expansion permet de faire du shell et de ses amis,
les programmes qu'il appelle, un véritable petit langage de programmation.
</p
><a name="SUBSUBSECTION_4.4.1"></a
><p align="left"><b>4.4.1 Variables</b
> </p
><p align="justify">
environnement.
variables exportées ou pas.
expansion.
La différence entre minuscule et majuscule compte dans les noms de variables
(comme dans les noms de fichiers).
<pre>
echo $HOME
FOO=bar
echo $FOO
env
export FOO
env
FOOBAR=baz
echo $FOOBAR
echo ${FOO}BAR
</pre
>

</p
><p align="justify">
Nombreuses options pour l'expansion des variables:
valeur par défaut, extraction de sous-chaînes, etc.
</p
><p align="justify">
<code><font color="darkblue">man bash</font
></code
> section <code><font color="darkblue">EXPANSIONS</font
></code
>;
<code><font color="darkblue">man zshexpn</font
></code
>, et dans <code><font color="darkblue">man zshbuiltins</font
></code
> voir <code><font color="darkblue">typeset</font
></code
>.
</p
><p align="justify">
<tt><font color="darkblue">zsh(1)</font
></tt
>, comme <tt><font color="darkblue">ksh(1)</font
></tt
>, possède aussi des variables listes contenant
une liste de chaînes de caractères.
Extrêmement utile pour des fonctions et scripts.
</p
><p align="justify">
Variables spéciales du shell:
<code><font color="darkblue">man bash</font
></code
> section <code><font color="darkblue">Shell Variables</font
></code
>;
<code><font color="darkblue">man zshparam</font
></code
>.
</p
><a name="SUBSUBSECTION_4.4.2"></a
><p align="left"><b>4.4.2 Échappements et guillemets</b
> </p
><p align="justify">
Quotes: <pre>A='Hello,  world'
echo $A
echo '$A'
zsh# echo $=A
Erreur, à terminer avec Ctrl-C# A=l'ivrogne</pre
>
Explication: le quote débute une phrase;
le shell ne terminera la lecture de la ligne actuelle
que quand le quote <code><font color="darkblue">'</font
></code
> sera refermé,
ou qu'il aura été interrompu (par <tt><font color="brown">Ctrl-C</font
></tt
>).
</p
><p align="justify">
Double quotes: <pre>
echo "$A"
echo "L'ivrogne"
</pre
>
</p
><p align="justify">
Backslash: <pre>echo L\'ivrogne
A="Salut \"toi\""
echo \$A
echo "\$A=$A"
echo '\$A=$A'
echo "\\\$A=\$A"
echo '$A='$A
echo '$A='"'$A'"
echo "\$A=$(perl -e 'print(join(" ",map(quotemeta,@ARGV)))' -- "$A")"</pre
>
</p
><p align="justify">
to split or not to split.
<code><font color="darkblue">"$@"</font
></code
> vs <code><font color="darkblue">"$*"</font
></code
>.

</p
><a name="SUBSUBSECTION_4.4.3"></a
><p align="left"><b>4.4.3 Chemins d'accès</b
> </p
><p align="justify">
Chemins absolus ou relatifs si vous êtes l'utilisateur <code><font color="darkblue">cepl1</font
></code
>
dans votre répertoire personnel <code><font color="darkblue">/home/cepl1</font
></code
>,
alors ces chemins correspondent tous au même fichier:
<ul><li><code><font color="darkblue">/home/cepl1/toto.txt</font
></code
></li
><li><code><font color="darkblue">./toto.txt</font
></code
></li
><li><code><font color="darkblue">../cepl1/toto.txt</font
></code
></li
><li><code><font color="darkblue">$HOME/toto.txt</font
></code
></li
><li><code><font color="darkblue">~/toto.txt</font
></code
></li
><li><code><font color="darkblue">~cepl1/toto.txt</font
></code
></li
></ul
>
Notez que le tilde <code><font color="darkblue">~</font
></code
> et la variable <code><font color="darkblue">$HOME</font
></code
>
sont <em>"expansés"</em
> (anglais: <em>expanded</em
>) par le shell
et ne sont pas vus par la commande exécutée,
cependant que les répertoires spéciaux <code><font color="darkblue">.</font
></code
> et <code><font color="darkblue">..</font
></code
>
sont gérés par le noyau.

</p
><a name="SUBSUBSECTION_4.4.4"></a
><p align="left"><b>4.4.4 Globbing</b
> </p
><p align="justify">
<ul><li><code><font color="darkblue">ls *.txt</font
></code
></li
><li><code><font color="darkblue">echo *a*</font
></code
></li
><li><code><font color="darkblue">ls images?.gif</font
></code
></li
><li><code><font color="darkblue">ls images[1-5].gif</font
></code
></li
></ul
>
</p
><p align="justify">
Les divers shells réagissent diversement dans le cas où rien ne correspond,
selon qu'ils soient interactifs ou pas, selon leurs options, etc.
Essayez avec <code><font color="darkblue">ls -l foo*bar*baz</font
></code
>.
</p
><p align="justify">
Avec <tt><font color="darkblue">zsh(1)</font
></tt
>, on peut paramétrer le résultat avec des options du shell.
<tt><font color="darkblue">zsh(1)</font
></tt
>: <code><font color="darkblue">setopt NULL_GLOB</font
></code
>, <code><font color="darkblue">man zshoptions</font
></code
>
<code><font color="darkblue">unsetopt NULL_GLOB</font
></code
>.
<tt><font color="darkblue">zsh(1)</font
></tt
> possède aussi
un système d'options pour qu'un <i>pattern</i
>
ne corresponde qu'à des fichiers d'un certain type
(fichiers véritables, liens symboliques, répertoires,
fichiers exécutables, etc.).
</p
><p align="justify">
Exercice: utiliser le globbing pour enlever des fichiers de backup,
déplacer des fichiers image, etc.

</p
><a name="SUBSUBSECTION_4.4.5"></a
><p align="left"><b>4.4.5 Backquote</b
> </p
><p align="justify">
Le langage de programmation du shell est très rudimentaire,
et le shell a souvent besoin de récupérer le résultat de commandes externes
pour pouvoir l'utiliser dans la suite du contrôle des commandes à exécuter.
Pour cela, il y a le mécanisme des backquotes <code><font color="darkblue">`commande...`</font
></code
>
par lequel une commande spécifiée entre backquotes est exécutée,
et sa sortie standard lue par le shell
et lorsque la commande termine,
ce résultat est employé en remplacement des backquotes.
</p
><p align="justify">
Exemple: pour aller dans le répertoire des modules du noyau courant,
utilisez <code><font color="darkblue">cd /lib/modules/`uname -r`</font
></code
>.
</p
><p align="justify">
<code><font color="darkblue">$( ... )</font
></code
>
Même effet que les backquotes, mais moins sujet à problème,
notamment pour les imbriquer.
N'existe pas dans les shells les plus antiques.
</p
><p align="justify">
<tt><font color="darkblue">zsh(1)</font
></tt
>: créer un fichier temporaire avec <code><font color="darkblue">=( ... )</font
></code
>.
Utile pour les commandes qui tiennent absolument à travailler
avec un fichier plutôt qu'avec un pipe.
</p
><a name="SUBSUBSECTION_4.4.6"></a
><p align="left"><b>4.4.6 Calculs arithmétiques</b
> </p
><p align="justify">
<code><font color="darkblue">$(( 1 + 2 * 3 ))</font
></code
> (ancienne notation: <code><font color="darkblue">$[ ... ]</font
></code
>)
</p
><p align="justify">
Incrémenter un compteur:
<code><font color="darkblue">(( i = i + 1 ))</font
></code
>
(aussi: <code><font color="darkblue">let "i = i + 1"</font
></code
> ou <code><font color="darkblue">i=$[ $i + 1 ]</font
></code
>
ou en shell POSIX de base, <code><font color="darkblue">i=`expr $i + 1`</font
></code
>.)
</p
><a name="SUBSUBSECTION_4.4.7"></a
><p align="left"><b>4.4.7 Brace expansion</b
> </p
><p align="justify">
<tt><font color="darkblue">tcsh(1)</font
></tt
>, et à sa suite <tt><font color="darkblue">bash(1)</font
></tt
>, <tt><font color="darkblue">ksh(1)</font
></tt
>, <tt><font color="darkblue">zsh(1)</font
></tt
>,
a une fonctionnalité par laquelle les métacaractères
<em>accolades</em
> (anglais: <em>braces</em
>) '<code><font color="darkblue">{</font
></code
>' et '<code><font color="darkblue">}</font
></code
>'
servent à délimiter des choix qui seront expansés par le shell
en toutes les combinaisons possibles dédits choix.
Essayer les commandes suivantes:
<pre><font color="darkblue">echo a{b,c,d}e
echo FOO{0,1,2,3,4}{a,b,c,d}
echo {bar{0,1,2},{baz,quux}{3,4,5}}.html</font
></pre
>
Exercice: prévoyez avant de l'exécuter ce que va faire la commande suivante:
<code><font color="darkblue">echo x{{0,1,2,3,4,5,6,7,8,9},{1,2,3,4,5,6,7,8,9}{0,1,2,3,4,5,6,7,8,9}}</font
></code
>
</p
><p align="justify">
<tt><font color="darkblue">zsh(1)</font
></tt
> possède une extension fort utile à ce système:
S'il n'y a pas de virgules,
<tt><font color="darkblue">zsh(1)</font
></tt
> reconnaît que les choix possibles sont des caractères spécifiés
comme dans un motif de glob entre crochets.
Essayez: <code><font color="darkblue">print -l 0x{0-9a-f}</font
></code
>.

Exercice: avec <tt><font color="darkblue">zsh(1)</font
></tt
>, générez avec les accolades des noms de fichier
appelés <code><font color="darkblue">image$x.gif</font
></code
> pour toutes les valeurs de <code><font color="darkblue">$x</font
></code
>
entre 0 à 255.
(Solution <a name="footnoteref56"></a
><a href="#footnote56"><sup><font size="-1">[56]</font
></sup
></a
>)
</p
><a name="SUBSUBSECTION_4.4.8"></a
><p align="left"><b>4.4.8 Alias</b
> </p
><p align="justify">
seulement pour des raccourcis claviers de commandes fréquentes
(ou arguments fréquents avec les alias globaux de zsh)
dont on veut spécifiquement qu'ils aient un comportement différent
sous la frappe et dans un programme.
Exemple typique,
<code><font color="darkblue">alias cp='cp -i' ;
alias mv='mv -i' ;
alias rm='rm -i'</font
></code
>
Pour tous les autres usages, utiliser des fonctions.

</p
><a name="SUBSECTION_4.5"></a
><font size="+1" face="sans-serif"><b>4.5 Commandes élaborées</b
></font
><p align="justify">
Par opposition aux commandes simples.
</p
><a name="SUBSUBSECTION_4.5.1"></a
><p align="left"><b>4.5.1 Redirection</b
> </p
><p align="justify">
Redirections de fichiers: <code><font color="darkblue">&#60;&#60; &#60; &#62; &#62;&#62; &#62;&#38; &#62;&#62;&#38; &#62;! 2&#62; 2&#62;&#38;1 /dev/null</font
></code
>
</p
><p align="justify">
Sous Unix, le moyen typique pour combiner des commandes est d'utiliser des
<em>tuyaux</em
> (anglais: <em>pipes</em
>) avec la syntaxe <code><font color="darkblue">commande1... | commande2...</font
></code
>
pour rediriger la sortie de l'un dans l'entrée de l'autre.
Exemples typiques:
examiner le contenu d'une arborescence avec un pager décent:
<code><font color="darkblue">ls -lR | less</font
></code
>
</p
><p align="justify">
Rediriger en même temps la sortie standard et la sortie d'erreur:
<pre><font color="darkblue">commande arguments &#62;&#38; foo
commande arguments &#62; foo 2&#62;&#38;1
commande arguments |&#38; traitement sortie
commande arguments 2&#62;&#38;1 | traitement sortie</font
></pre
>
</p
><p align="justify">
Partage des variables ou non:
<pre><font color="darkblue">ls --sort=time | head -1
ls -l --sort=time | read A B C D E F G H ; echo $E $H
</font
></pre
>
</p
><p align="justify">
Exemples: <code><font color="darkblue">wc</font
></code
>, <code><font color="darkblue">less</font
></code
>
</p
><a name="SUBSUBSECTION_4.5.2"></a
><p align="left"><b>4.5.2 Regroupement de commandes</b
> </p
><p align="justify">
Séquences de commande avec <code><font color="darkblue">;</font
></code
>.
Exemple: <code><font color="darkblue">sleep 3 ; echo -e '\007'</font
></code
>
</p
><p align="justify">
Regroupement de commandes avec <code><font color="darkblue">{ }</font
></code
>.
Exemple: <code><font color="darkblue">echo "1 2 3" | { read A B C ; echo $A }</font
></code
>
</p
><p align="justify">
Commandes dans un sous-shell avec <code><font color="darkblue">( )</font
></code
>.
Exemple: <code><font color="darkblue">(cd /usr/src/linux ; make)</font
></code
>.
Différence: les variables et autres attributs du processus
modifiés dans le sous-shell n'affecteront pas le shell principal
</p
><p align="justify">
Commandes en tâche de fond avec <code><font color="darkblue">&#38;</font
></code
>.
Exemple: <code><font color="darkblue">xterm &#38;</font
></code
>

Pour certaines applications (notamment graphiques),
on préférera parfois utiliser <tt><font color="darkblue">setsid(8)</font
></tt
>
accompagné de redirections vers <code><font color="darkblue">/dev/null</font
></code
> (<tt><font color="darkblue">null(4)</font
></tt
>)
ou vers un fichier de logs. Exemple:
<code><font color="darkblue">setsid firefox &#60; /dev/null &#62;&#38; /dev/null</font
></code
>
</p
><p align="justify">
Neutralisation de commandes avec <code><font color="darkblue">:</font
></code
>
(commande qui ne fait rien, avec succès, et que l'on peut rediriger)
ou avec <code><font color="darkblue">#</font
></code
>
(commentaires, ne change pas <code><font color="darkblue">$?</font
></code
>, n'est pas redirigé).
</p
><a name="SUBSUBSECTION_4.5.3"></a
><p align="left"><b>4.5.3 Structure</b
> </p
><p align="justify">
</p
><p align="justify">
Rappel de la convention pour la gestion des erreur:
un processus se termine avec un code de retour
qui est 0 en cas de succès (vrai)
ou différent de zéro en cas d'échec (faux).
La variable <code><font color="darkblue">$?</font
></code
> permet de récupérer
le résultat de la dernière commande.
Ainsi, exécution conditionnelle avec <code><font color="darkblue">if ...; then ... ; else ... ; fi</font
></code
>,
ou encore avec <code><font color="darkblue">commande1... &#38;&#38; commande2...</font
></code
>
(conjonction - continuer si vrai)
ou <code><font color="darkblue">commande1... || commande2...</font
></code
> (disjonction - continuer si faux),
<code><font color="darkblue">! commande...</font
></code
> (négation - changer vrai en faux et vice-versa).
Souvent utilisation du programme <tt><font color="darkblue">test(1)</font
></tt
>
ou de l'équivalent interne au shell, <code><font color="darkblue">[</font
></code
>,
pour divers tests.
</p
><p align="justify">
Par exemple, pour éviter que le <code><font color="darkblue">/etc/zshrc</font
></code
>
s'exécute quand l'utilisateur possède sa propre configuration, utiliser
<code><font color="darkblue">if [ -f ${ZDOTDIR:-$HOME}/.zshrc ] ; then return ; fi</font
></code
>
</p
><p align="justify">
Boucles avec <code><font color="darkblue">for</font
></code
>, <code><font color="darkblue">while</font
></code
>.
</p
><p align="justify">
<pre><font color="darkblue">for i in *.txt ; do cp $i ${i}.bak ; done
i=0 ; while (( i &#60; 20 )) ; do echo $i ; let i='i+1' ; done</font
></pre
>
</p
><p align="justify">
Programmation par cas et pattern matching avec <code><font color="darkblue">case ... esac</font
></code
>.

</p
><a name="SUBSUBSECTION_4.5.4"></a
><p align="left"><b>4.5.4 Fonctions et Scripts</b
> </p
><p align="justify">
Dès que vous réutilisez des commandes identiques ou fortement similaires
plus de trois fois, il devient utile d'écrire une fonction
qui vous simplifiera dorénavant la tâche,
et dont la formulation vous aidera à bien comprendre ce que vous faites.
</p
><p align="justify">
<pre><font color="darkblue">function foo () {
  for i ; do echo "ARG: $i" ; done
}</font
></pre
>

</p
><p align="justify">
Pratique: <code><font color="darkblue">:</font
></code
> sert à afficher des informations
ssi on est en mode debug (<code><font color="darkblue">set -x</font
></code
>).
</p
><a name="SUBSUBSECTION_4.5.5"></a
><p align="left"><b>4.5.5 Programmation Shell Avancée</b
> </p
><p align="justify">
Parallélisme avec <code><font color="darkblue">&#38;</font
></code
> (et éventuellement <code><font color="darkblue">$!</font
></code
>).
</p
><p align="justify">
Tuyaux nommés avec <code><font color="darkblue">mknod <i>foo</i
> p</font
></code
>.
</p
><p align="justify">
<tt><font color="darkblue">zsh(1)</font
></tt
>: <code><font color="darkblue">coproc</font
></code
>.
</p
><p align="justify">
Ne faites pas comme moi, arrêtez-vous avant de devenir fou,
et utilisez un vrai langage de programmation.
</p
><p align="justify">
<u>Pertinence</u
>:
savoir que c'est possible,
savoir ce qui est «&nbsp;facile&nbsp;» sous Unix,
et ce qui ne l'est pas.
</p
><a name="SUBSECTION_4.6"></a
><font size="+1" face="sans-serif"><b>4.6 Trucs à connaître</b
></font
><a name="SUBSUBSECTION_4.6.1"></a
><p align="left"><b>4.6.1 Job control</b
> </p
><p align="justify">
job control: <tt><font color="brown">C-z</font
></tt
>, <code><font color="darkblue">fg</font
></code
>, <code><font color="darkblue">bg</font
></code
>,
<code><font color="darkblue">kill</font
></code
>, <code><font color="darkblue">kill -CONT %1</font
></code
>, <code><font color="darkblue">kill -STOP</font
></code
>,
<code><font color="darkblue">&#38;</font
></code
>, <code><font color="darkblue">$!</font
></code
>, etc.
<tt><font color="brown">C-c</font
></tt
>, <tt><font color="brown">C-\</font
></tt
>.
Pour tous les détails, voir la page de manuel du shell.
</p
><a name="SUBSUBSECTION_4.6.2"></a
><p align="left"><b>4.6.2 Noms de fichiers cachés</b
> </p
><p align="justify">
Par convention, les fichiers dont le nom commence par un
<em>point</em
> (anglais: <em>dot</em
>) <tt><font color="brown">.</font
></tt
> sont cachés par défaut
par l'interface utilisateur.
On peut les visualiser tout de même avec l'option <code><font color="darkblue">-a</font
></code
> de <tt><font color="darkblue">ls(1)</font
></tt
>,
en cliquant au bon endroit dans <code><font color="darkblue">kfm</font
></code
> ou <code><font color="darkblue">gmc</font
></code
>, etc.
</p
><p align="justify">
Ces fichiers cachés sont typiquement employés
pour les fichiers de configuration personnalisée
des divers programmes
(essayez donc <code><font color="darkblue">ls -a ~</font
></code
>),
des fichiers temporaires ou automatiquement générés,
et autres données ancillaires qui ne concernent pas
directement l'utilisateur typique
(<code><font color="darkblue">.cvsignore</font
></code
> pour CVS,
<code><font color="darkblue">.depend</font
></code
> dans beaucoup de <code><font color="darkblue">Makefile</font
></code
>,
<code><font color="darkblue">.AppleDouble</font
></code
> pour <tt><font color="darkblue">netatalk</font
></tt
>, etc.).
</p
><p align="justify">
Interaction avec le globbing: <code><font color="darkblue">* .*</font
></code
>
(<tt><font color="darkblue">zsh(1)</font
></tt
>: <code><font color="darkblue">setopt GLOB_DOTS</font
></code
>)
Attention! Sous <tt><font color="darkblue">sh(1)</font
></tt
> et <tt><font color="darkblue">bash(1)</font
></tt
>, le filtre <code><font color="darkblue">.*</font
></code
>
va laisser passer <code><font color="darkblue">.</font
></code
> et <code><font color="darkblue">..</font
></code
>
les répertoires actuel et précédent;
Sous bash, utiliser <code><font color="darkblue">.??*</font
></code
> en conjonction possible avec <code><font color="darkblue">.[^.]</font
></code
>
pour tous les fichiers cachés sauf ces deux-là.
</p
><p align="justify">
Personnellement, je déteste le fait de tout mettre en vrac dans <code><font color="darkblue">~</font
></code
>
(ou même dans <code><font color="darkblue">/etc</font
></code
>), et les fichiers que je personnalise à la main,
je les mets dans des sous-répertoire de <code><font color="darkblue">~/etc</font
></code
> (ou <code><font color="darkblue">/etc</font
></code
>,
avec un lien symbolique depuis l'endroit où le programme va le chercher
vers l'endroit où je préfère le stoquer.
Un avantage supplémentaire est de pouvoir mettre mes fichiers de configuration
sous contrôle d'un programme de gestion de versions multiples
(j'utilise le très-répandu <tt><font color="darkblue">cvs(1)</font
></tt
>),
ce qui est très pratique à de nombreux égards
(archivage avec historique, partage entre nombreuses machines,
détection de bugs et récupération d'une version qui marche).
</p
><a name="SUBSUBSECTION_4.6.3"></a
><p align="left"><b>4.6.3 Noms de fichiers ressemblant à des options</b
> </p
><p align="justify">
Clash entre options et nom de fichier.
Parfois, un nom de fichier peut commencer par un tiret,
que ce soit de manière intentionnelle ou pas
(exemple: <code><font color="darkblue">echo 2 &#62; -i</font
></code
> ou n'importe quel copier-coller
d'un texte avec un <tt><font color="brown">&#62;</font
></tt
>)
et si c'est intentionnel, avec une intention bonne ou mauvaise.
Dans ces cas, comment faire pour donner un tel fichier à traiter
à une commande?
Réponse: sur des commandes modernes,
en indiquant la fin des options avec <code><font color="darkblue">--</font
></code
>
comme avec <code><font color="darkblue">rm -- -i</font
></code
>.
Sur des commandes plus anciennes,
en donnant un chemin avec répertoire pour que le tiret ne soit pas en premier:
<code><font color="darkblue">rm ./-i</font
></code
>.
</p
><a name="SUBSUBSECTION_4.6.4"></a
><p align="left"><b>4.6.4 Noms de fichiers difficiles à reproduire</b
> </p
><p align="justify">
Utiliser des quotes.
Dans les quotes, utiliser éventuellement un <code><font color="darkblue">$(echo -e '\033')</font
></code
>
(code octal).
</p
><p align="justify">
Utiliser la complétion.
</p
><p align="justify">
Utiliser le globbing.
</p
><a name="SUBSECTION_4.7"></a
><font size="+1" face="sans-serif"><b>4.7 Configuration du shell</b
></font
><p align="justify">
Votre shell lira des fichiers de configuration légèrement différents
selon qu'il décide ou non d'être
un <em>shell de démarrage</em
> (anglais: <em>login shell</em
>) d'une part
et un shell <em>interactif</em
> (anglais: <em>interactive</em
>) d'autre part.
</p
><p align="justify">
Il est un shell de démarrage s'il est invoqué par la commande <tt><font color="darkblue">login(8)</font
></tt
>
<a name="footnoteref57"></a
><a href="#footnote57"><sup><font size="-1">[57]</font
></sup
></a
>.
On peut forcer un shell <tt><font color="darkblue">bash(1)</font
></tt
> ou <tt><font color="darkblue">zsh(1)</font
></tt
>
(mais pas le shell POSIX de base)
à être de démarrage avec l'option <code><font color="darkblue">-l</font
></code
>.
On peut forcer <tt><font color="darkblue">zsh(1)</font
></tt
> à ne pas l'être avec l'option <code><font color="darkblue">+l</font
></code
>.
S'il est de démarrage, le shell lira
un fichier de configuration supplémentaire,
dans le répertoire système <code><font color="darkblue">/etc</font
></code
> puis chez l'utilisateur.
Pour <code><font color="darkblue">sh</font
></code
> il s'agit du <code><font color="darkblue">.profile</font
></code
>,
pour <tt><font color="darkblue">bash(1)</font
></tt
> il s'agit du <code><font color="darkblue">.bash_profile</font
></code
>,
pour <tt><font color="darkblue">zsh(1)</font
></tt
> il s'agit du <code><font color="darkblue">.zprofile</font
></code
>.
</p
><p align="justify">
Un shell sera interactif s'il détecte que son entrée standard est reliée
à un terminal (par opposition à être lié à un fichier ou un tuyau)
<a name="footnoteref58"></a
><a href="#footnote58"><sup><font size="-1">[58]</font
></sup
></a
>
.
On peut forcer un shell à être interactif avec l'option <code><font color="darkblue">-i</font
></code
>,
et on peut forcer <tt><font color="darkblue">zsh(1)</font
></tt
> à ne pas l'être avec l'option <code><font color="darkblue">+i</font
></code
>.
S'il est interactif, le shell lira un fichier de configuration supplémentaire,
dans le répertoire système <code><font color="darkblue">/etc</font
></code
> puis chez l'utilisateur:
pour <tt><font color="darkblue">bash(1)</font
></tt
> il s'agit du <code><font color="darkblue">.bashrc</font
></code
>,
pour <tt><font color="darkblue">zsh(1)</font
></tt
> il s'agit du <code><font color="darkblue">.zshrc</font
></code
>,
pour <code><font color="darkblue">sh</font
></code
> il n'y a pas de tel fichier.
Dans ce fichier de ressources pour shell interactif,
on configurera
<ul><li>
son <em>invite</em
> (anglais: <em>prompt</em
>), dans la variable <code><font color="darkblue">PS1</font
></code
>
(sous <tt><font color="darkblue">zsh(1)</font
></tt
>, on préférera <code><font color="darkblue">PROMPT</font
></code
> et <code><font color="darkblue">RPROMPT</font
></code
>).
On pourra ainsi afficher le répertoire courant et d'autres informations utiles
dans le prompt, voire, via des caractères spéciaux dans le prompt,
dans le titre de la fenêtre actuelle.
</li
><li>
Les options de configuration de son shell
<a name="footnoteref59"></a
><a href="#footnote59"><sup><font size="-1">[59]</font
></sup
></a
>.
</li
><li>
Diverses variables de configuration du shell,
comme celles contrôlant l'historique de vos commandes
<a name="footnoteref60"></a
><a href="#footnote60"><sup><font size="-1">[60]</font
></sup
></a
>,
</li
><li>
Des paramètres système comme
le masque des droits d'accès pour les fichiers que vous créez
(commande interne <code><font color="darkblue">umask</font
></code
> pour l'appel système du même nom),
ou les limites de ressources allouées au processus
(commandes internes <code><font color="darkblue">limit</font
></code
> et <code><font color="darkblue">ulimit</font
></code
>).
</li
><li>
Tous vos alias de shell.
</li
><li>
Toutes les fonctions que vous utilisez en mode interactif.


</li
></ul
>
</p
><p align="justify">
Note sur fichiers de configuration global du shell:
ils sont le Mal, de ce genre de bonnes intentions dont l'enfer est pavé.
À défaut de les effacer, il est bon de les désactiver sélectivement
en mettant à leur début une commande comme
<code><font color="darkblue">[ -f "$HOME/.bashrc" ] &#38;&#38; return</font
></code
>
pour le <code><font color="darkblue">/etc/bash.bashrc</font
></code
>
ou sinon d'utiliser l'évaluation conditionnelle
pour ne pas polluer la configuration d'un utilisateur
avec des commandes indésirables et parfois irréversibles.
</p
><a name="SUBSECTION_4.8"></a
><font size="+1" face="sans-serif"><b>4.8 Quelques amis du shell</b
></font
><a name="SUBSUBSECTION_4.8.1"></a
><p align="left"><b>4.8.1 Petits utilitaires</b
> </p
><p align="justify">
<tt><font color="darkblue">sort(1)</font
></tt
> pour trier des données
(<code><font color="darkblue">sort -u</font
></code
> est utile pour éviter les doublons).
</p
><p align="justify">
<tt><font color="darkblue">cut(1)</font
></tt
>,
<tt><font color="darkblue">head(1)</font
></tt
> et
<tt><font color="darkblue">tail(1)</font
></tt
>
pour extraire des données.
</p
><p align="justify">

Exercice: identifier tous les programmes utilisés comme shell de login.
(Indice <a name="footnoteref61"></a
><a href="#footnote61"><sup><font size="-1">[61]</font
></sup
></a
>)(Solution <a name="footnoteref62"></a
><a href="#footnote62"><sup><font size="-1">[62]</font
></sup
></a
>)
</p
><p align="justify">
<tt><font color="darkblue">pr(1)</font
></tt
> pour formatter une sortie sur plusieurs colonnes.
Exemple: <code><font color="darkblue">cat /etc/passwd | cut -f 1 -d: | pr -5</font
></code
>
</p
><p align="justify">
<tt><font color="darkblue">printf(1)</font
></tt
> pour formatter des messages.
</p
><p align="justify">
<tt><font color="darkblue">find(1)</font
></tt
>

Pour pouvoir les intégrer chacun à une URL présentable,
vous voulez extraire les noms de fichiers (par opposition à répertoire)
du répertoire courant
en les débarassant du disgracieux préfixe <code><font color="darkblue">./</font
></code
> &mdash;
Comment vous y prendrez-vous?
(Indice <a name="footnoteref63"></a
><a href="#footnote63"><sup><font size="-1">[63]</font
></sup
></a
>)(Solution <a name="footnoteref64"></a
><a href="#footnote64"><sup><font size="-1">[64]</font
></sup
></a
>)
</p
><p align="justify">
<tt><font color="darkblue">xargs(1)</font
></tt
> <a name="footnoteref65"></a
><a href="#footnote65"><sup><font size="-1">[65]</font
></sup
></a
>
Exemple:
<code><font color="darkblue">find /usr/include -type f | xargs grep "malloc"</font
></code
>
cherchera quel fichier d'entête C définit la fonction <tt><font color="darkblue">malloc(3)</font
></tt
>
(dans ce cas là, la page de manuel aurait pu vous le dire).
</p
><p align="justify">
Pour faire des calculs plus compliqués, intensifs ou conviviaux
que ne sait le faire votre shell:
<tt><font color="darkblue">expr(1)</font
></tt
>,
<tt><font color="darkblue">dc(1)</font
></tt
>,
<tt><font color="darkblue">bc(1)</font
></tt
>,
<tt><font color="darkblue">rpncalc(1)</font
></tt
>
(pour une vrai calculatrice scientifique HP avec interface graphique,
utilisez <code><font color="darkblue">x48</font
></code
>),
voire
<tt><font color="darkblue">clisp(1)</font
></tt
>
(pour un vrai langage de programmation dynamique).
</p
><p align="justify">
Utiles pour certains scripts dans des shells antiques:
<tt><font color="darkblue">basename(1)</font
></tt
>,
<tt><font color="darkblue">dirname(1)</font
></tt
>.
</p
><p align="justify">
Informations diverses sur le système:
<tt><font color="darkblue">hostname(1)</font
></tt
>,
<tt><font color="darkblue">uname(1)</font
></tt
>,
<tt><font color="darkblue">whoami(1)</font
></tt
>.
</p
><a name="SUBSUBSECTION_4.8.2"></a
><p align="left"><b>4.8.2 Contrôler la sortie</b
> </p
><p align="justify">
Redirection vers <code><font color="darkblue">/dev/null</font
></code
> ou un fichier.
Souvent, option <code><font color="darkblue">-o</font
></code
>
pour utiliser un fichier plutôt que la sortie standard
(ou l'imprimante, pour certains programmes produisant du PostScript).
Souvent, le pseudo-nom-de-fichier <code><font color="darkblue">-</font
></code
>
signifie la sortie standard plutôt qu'un fichier.
</p
><p align="justify">
<tt><font color="darkblue">less(1)</font
></tt
>
(version largement améliorée du <tt><font color="darkblue">more(1)</font
></tt
> des UNIX propriétaires):
permet d'aller en arrière,
ainsi que de faire de la recherche d'expressions régulières:
touche <tt><font color="brown">/</font
></tt
> pour la recherche, <tt><font color="brown">?</font
></tt
> pour recherche en arrière,
<tt><font color="brown">n</font
></tt
> (next) ou <tt><font color="brown">/ RET</font
></tt
> pour répéter la dernière recherche.
Utiliser <tt><font color="brown">h</font
></tt
> pour l'aide, <tt><font color="brown">q</font
></tt
> pour quitter
<a name="footnoteref66"></a
><a href="#footnote66"><sup><font size="-1">[66]</font
></sup
></a
>.
</p
><p align="justify">
<tt><font color="darkblue">tee(1)</font
></tt
>
</p
><p align="justify">
<tt><font color="darkblue">mail(1)</font
></tt
> pour envoyer du courrier depuis la ligne de commande
<a name="footnoteref67"></a
><a href="#footnote67"><sup><font size="-1">[67]</font
></sup
></a
>.
Pour l'interface interactive, ou pour envoyer des attachements,
préférer <tt><font color="darkblue">mutt(1)</font
></tt
>.
).
</p
><p align="justify">
<tt><font color="darkblue">logger(1)</font
></tt
>, <tt><font color="darkblue">syslog(2)</font
></tt
>, <tt><font color="darkblue">syslog(3)</font
></tt
>, etc.
</p
><a name="SUBSUBSECTION_4.8.3"></a
><p align="left"><b>4.8.3 Contrôler l'entrée</b
> </p
><p align="justify">
Redirection depuis <code><font color="darkblue">/dev/null</font
></code
> ou un fichier.
Souvent une option pour utiliser un fichier plutôt que l'entrée standard.
Souvent le pseudo-nom-de-fichier <code><font color="darkblue">-</font
></code
>
sert à signifier l'entrée standard plutôt qu'un fichier.
</p
><p align="justify">
<code><font color="darkblue">commande &#60;&#60; END</font
></code
> suivi de nombreuses lignes
puis d'une ligne contenant <code><font color="darkblue">END</font
></code
>
(ou le marqueur choisi quelqu'il soit).
C'est très utile dans un script, où on appelle
<em></em
> (anglais: <em>here document</em
>) le document incis grâce à cette redirection.
En interactif plutôt que dans un script, c'est moins utile,
puisqu'on on peut utiliser <tt><font color="brown">C-d</font
></tt
> plutôt que <code><font color="darkblue">&#60;&#60;END</font
></code
>
pour envoyer une fin de fichier à un programme.
Toutefois, le <code><font color="darkblue">&#60;&#60;END</font
></code
> permet de mettre des variables à expanser
dans le texte;
si on veut spécifiquement éviter une telle expansion,
utiliser des guillemets autour du code: <code><font color="darkblue">&#60;&#60;'END'</font
></code
>.
</p
><p align="justify">
<code><font color="darkblue">echo 'foo bar baz' | commande</font
></code
>
</p
><p align="justify">
<tt><font color="darkblue">yes(1)</font
></tt
>
</p
><p align="justify">
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, <code><font color="darkblue">commande &#60;&#60;&#60; 'foo bar baz'</font
></code
>
est un équivalent plus court.
</p
><a name="SUBSUBSECTION_4.8.4"></a
><p align="left"><b>4.8.4 Gérer la divergence des fichiers</b
> </p
><p align="justify">
<tt><font color="darkblue">cmp(1)</font
></tt
>
<tt><font color="darkblue">diff(1)</font
></tt
>
<tt><font color="darkblue">diff3(1)</font
></tt
>
<tt><font color="darkblue">patch(1)</font
></tt
>
<tt><font color="darkblue">xdelta(1)</font
></tt
>
</p
><p align="justify">
<tt><font color="darkblue">rsync(1)</font
></tt
>
<tt><font color="darkblue">unison(1)</font
></tt
>
</p
><p align="justify">
<tt><font color="darkblue">cvs(1)</font
></tt
> et consorts.
(De nos jours utiliser plutôt <tt><font color="darkblue">svn(1)</font
></tt
> que <tt><font color="darkblue">cvs(1)</font
></tt
>;
voir la section "Habitudes élémentaires de précaution")
)
</p
><a name="SUBSUBSECTION_4.8.5"></a
><p align="left"><b>4.8.5 Comprimer et Archiver</b
> </p
><p align="justify">
L'utilitaire standard pour comprimer des fichiers est <tt><font color="darkblue">gzip(1)</font
></tt
>
<a name="footnoteref68"></a
><a href="#footnote68"><sup><font size="-1">[68]</font
></sup
></a
>.
Vous pouvez décomprimer un fichier avec <tt><font color="darkblue">gunzip(1)</font
></tt
>
ou l'envoyer dans un tuyau grâce à <tt><font color="darkblue">zcat(1)</font
></tt
>.
Pour vous éviter des tuyaux dans tous les sens, voir aussi
<tt><font color="darkblue">zless(1)</font
></tt
>,
<tt><font color="darkblue">zgrep(1)</font
></tt
>,
<tt><font color="darkblue">zdiff(1)</font
></tt
>, etc.
</p
><p align="justify">
Dans le monde UNIX et donc aussi Linux,
le standard de fait en matière d'archivage est la commande <tt><font color="darkblue">tar(1)</font
></tt
>,
dont les fichiers sont conventionnellement nommés
avec le suffixe <code><font color="darkblue">.tar</font
></code
>
<a name="footnoteref69"></a
><a href="#footnote69"><sup><font size="-1">[69]</font
></sup
></a
>.
</p
><p align="justify">
Les commandes les plus usuelles pour manipuler des fichiers tar sont:
<ul><li>
<code><font color="darkblue">tar zvcf ~/tutoriel.tar.gz tutoriel</font
></code
><br
/>
En comprimant avec gZip, et en étant Verbeux, Créer un Fichier archive
<a name="footnoteref70"></a
><a href="#footnote70"><sup><font size="-1">[70]</font
></sup
></a
>.
</li
><li>
<code><font color="darkblue">tar zvtf ~/tutoriel.tar.gz</font
></code
><br
/>
Tester l'archive.
</li
><li>
<code><font color="darkblue">tar zxvf ~/tutoriel.tar.gz</font
></code
><br
/>
eXtraire l'archive.
</li
></ul
>
</p
><p align="justify">
Note de politesse et de prudence quant aux archives tar et autres:
une archive peut contenir de nombreux fichiers,
qui seront désarchivés dans le répertoire actuel.
Ils pourront écraser des fichiers du répertoire actuel,
et/ou il pourra être difficile de repérer tous les fichiers de l'archive
(y compris les fichiers cachés en <code><font color="darkblue">.*</font
></code
>)
pour les effacer le moment venu.
Aussi, il est <em>poli</em
>, en créant une archive,
de mettre tous les fichiers en-dessous d'un unique sous-répertoire
dont le nom est bien distingué, de façon à épargner toute mauvaise man&oelig;uvre
à celui qui recevra l'archive.
Et il est <em>prudent</em
> ou bien de vérifier
(avec l'option <code><font color="darkblue">t</font
></code
> de <code><font color="darkblue">tar</font
></code
>, combinée à <tt><font color="darkblue">less(1)</font
></tt
>)
que l'archive se comporte selon vos attentes,
ou bien de créer un nouveau sous-répertoire
dans lequel extraire bien à part le contenu de l'archive,
que son créateur ait été poli ou non.
</p
><p align="justify">
Encrypter vos archives pour qu'elles ne tombent pas en de mauvaises mains:
<tt><font color="darkblue">gpg(1)</font
></tt
>
&mdash; faites très attention à vos clefs, maillon faible du système.
Et faites attention que dès que vous êtes un peu prudent avec la technique,
l'électronique est rarement le maillon faible d'une organisation humaine.
</p
><a name="SUBSUBSECTION_4.8.6"></a
><p align="left"><b>4.8.6 Vous connecter au réseau</b
> </p
><p align="justify">
<tt><font color="darkblue">ssh(1)</font
></tt
> pour lancer des commandes à distance.
(gestion des clefs, <tt><font color="darkblue">rsh(1)</font
></tt
> si vraiment confiance, etc.)
</p
><p align="justify">
<tt><font color="darkblue">netcat(1)</font
></tt
> pour connecter des commandes à des services réseau.
</p
><p align="justify">
<tt><font color="darkblue">stunnel(1)</font
></tt
> et consorts pour faire du SSL.
</p
><a name="SUBSUBSECTION_4.8.7"></a
><p align="left"><b>4.8.7 Aide à l'écriture</b
> </p
><p align="justify">
<tt><font color="darkblue">dict(1)</font
></tt
>,
<tt><font color="darkblue">ispell(1)</font
></tt
>,
<tt><font color="darkblue">aspell(1)</font
></tt
>.
</p
><p align="justify">
<tt><font color="darkblue">fortunes(6)</font
></tt
> (considéré comme un jeu &mdash; <code><font color="darkblue">man -k game</font
></code
>).
</p
><a name="SUBSECTION_4.9"></a
><font size="+1" face="sans-serif"><b>4.9 Expressions régulières</b
></font
><p align="justify">
Les <em>expressions régulières</em
> (anglais: <em>regular expressions</em
>)
sont un moyen de définir des filtres permettant
d'isoler ou d'exclure certains bouts de texte
<a name="footnoteref71"></a
><a href="#footnote71"><sup><font size="-1">[71]</font
></sup
></a
>.
On les emploie pour faire de la recherche et du remplacement de texte
dans des fichiers.
</p
><p align="justify">
Pour apprendre les regexp:
<a href="http://developpeur.journaldunet.com/tutoriel/cgi/010315cgi_expreg.shtml">expreg</a
>,
<a href="http://www.shellunix.com/regexp.html">regexp</a
>,
<a href="http://www.linuxfocus.org/Francais/July1998/article53.html">article53</a
>,
<a href="http://www.oreilly.fr/catalogue/regex2.html">regex2</a
>,
<a href="http://perso-info.enst-bretagne.fr/~aubert/perl/html/node6.html">node6</a
>,
<a href="http://toutprogrammer.com/article.php3?id_article=7">article</a
>.
</p
><p align="justify">
La commande usuelle pour trouver du texte dans des fichiers
est la commande <tt><font color="darkblue">grep(1)</font
></tt
>.
Elle possède plusieurs variantes:
<tt><font color="darkblue">egrep(1)</font
></tt
>, <tt><font color="darkblue">fgrep(1)</font
></tt
>, <tt><font color="darkblue">pcregrep(1)</font
></tt
>.
</p
><p align="justify">
Exemple: en supposant que les élèves de la promotion 2004
aient un répertoire personnel sous <code><font color="darkblue">/home/eleves/2004</font
></code
>,
on peut compter combien il y en a grâce à
<code><font color="darkblue">&#60; /etc/passwd grep /home/eleves/2004/ | wc -l</font
></code
>
</p
><p align="justify">
Une autre commande utile (mais moins standard) est <tt><font color="darkblue">rename(1)</font
></tt
>
qui sert à renommer des fichier avec des regexp de <tt><font color="darkblue">perl(1)</font
></tt
>
(ou toutes autres commandes <tt><font color="darkblue">perl(1)</font
></tt
>).
</p
><p align="justify">
<tt><font color="darkblue">sed(1)</font
></tt
>, <tt><font color="darkblue">awk(1)</font
></tt
>.
<tt><font color="darkblue">perl(1)</font
></tt
>, vrais langages.
<tt><font color="darkblue">vi(1)</font
></tt
>, <tt><font color="darkblue">emacs(1)</font
></tt
>, éditeurs, etc.
</p
><p align="justify">
Diverses versions subtilement incompatibles des regexp,
entre <tt><font color="darkblue">grep(1)</font
></tt
>, <tt><font color="darkblue">egrep(1)</font
></tt
>, <tt><font color="darkblue">perl(1)</font
></tt
>,
<tt><font color="darkblue">pcregrep(1)</font
></tt
>,
<tt><font color="darkblue">vi(1)</font
></tt
>, <tt><font color="darkblue">emacs(1)</font
></tt
>, etc. AARRGGG!
Ainsi, pour le remplacement <code><font color="darkblue">\1</font
></code
>
dans les anciens outils dont <tt><font color="darkblue">grep(1)</font
></tt
>,
mais <code><font color="darkblue">$1</font
></code
> dans <tt><font color="darkblue">perl(1)</font
></tt
> (qui accepte aussi <code><font color="darkblue">\1</font
></code
>).
</p
><p align="justify">
Standard de fait vers lequel tendent ceux qui évoluent: <tt><font color="darkblue">perlre(1)</font
></tt
>.
(notamment avec la bibliothèque <tt><font color="darkblue">pcre(7)</font
></tt
>
&mdash;
<a href="http://www.pcre.org">perl-compatible regular expressions</a
>.)
Cependant, <tt><font color="darkblue">perl(1)</font
></tt
> lui-même évolue,
alors il y a et il y aura toujours des incompatibilités subtiles.
Toutefois, le fond commun est là, qui ne change pas trop.
Les incompatibilités sont sur les extensions et les détails subtils.
</p
><p align="justify">
Attention au double niveau de citation et d'échappement
quand on appelle <tt><font color="darkblue">perl(1)</font
></tt
> depuis un shell
plutôt que d'écrire un perl-script.
</p
><p align="justify">
<code><font color="darkblue">perl -npe 's/foo/bar/g;
s/baz/quux/g;'
</font
></code
>
</p
><p align="justify">
Exercice: Repérer les occurrences du mot «&nbsp;attention&nbsp;» dans ce fichier texte.
(Solution <a name="footnoteref72"></a
><a href="#footnote72"><sup><font size="-1">[72]</font
></sup
></a
>)</p
><p align="justify">
Exercice:
supposons que vous avez oublié le nom du fichier
où se trouve la base de donnée des utilisateurs,
mais que vous vous souvenez qu'elle se trouve
avec toute la configuration du système
dans un fichier de <code><font color="darkblue">/etc</font
></code
>
et que vous êtes l'utilisateur <code><font color="darkblue">cepl</font
></code
>.
Utilisez <tt><font color="darkblue">grep(1)</font
></tt
> pour retrouver
les fichiers où apparaît le mot <code><font color="darkblue">cepl</font
></code
>.
(Solution <a name="footnoteref73"></a
><a href="#footnote73"><sup><font size="-1">[73]</font
></sup
></a
>)</p
><p align="justify">
Évaluer le nombre de lignes où apparaît le mot «&nbsp;foo&nbsp;»
dans le fichier <code><font color="darkblue">cepl-linux.html</font
></code
>.
(Indice <a name="footnoteref74"></a
><a href="#footnote74"><sup><font size="-1">[74]</font
></sup
></a
>)(Solution <a name="footnoteref75"></a
><a href="#footnote75"><sup><font size="-1">[75]</font
></sup
></a
>)</p
><a name="SECTION_5"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>5 Applications disponibles sous Linux</b
></font
></td
></tr
></table
><a name="SUBSECTION_5.1"></a
><font size="+1" face="sans-serif"><b>5.1 Applicatifs les plus courants</b
></font
><p align="justify">
Savoir lancer un applicatif depuis KDE: <tt><font color="brown">Ctrl-F2</font
></tt
>.
Depuis GNOME, etc.
Au pire, lancer depuis un shell dans un terminal
(attention au <code><font color="darkblue">&#38;</font
></code
>).
</p
><p align="justify">
<u>X</u
>:
<tt><font color="darkblue">firefox(1)</font
></tt
>, <tt><font color="darkblue">thunderbird(1)</font
></tt
>, <tt><font color="darkblue">ooffice(1)</font
></tt
>,
<tt><font color="darkblue">qiv(1)</font
></tt
>, <tt><font color="darkblue">texmacs(1)</font
></tt
>, <tt><font color="darkblue">xchat(1)</font
></tt
>,
<tt><font color="darkblue">mplayer(1)</font
></tt
>, <tt><font color="darkblue">ogle(1)</font
></tt
>, <tt><font color="darkblue">xmms(1)</font
></tt
>,
<tt><font color="darkblue">xplaycd(1)</font
></tt
>, ...
<a name="footnoteref76"></a
><a href="#footnote76"><sup><font size="-1">[76]</font
></sup
></a
>
</p
><p align="justify">
<u>petits outils X</u
>:
<tt><font color="darkblue">xbiff(1)</font
></tt
>, <tt><font color="darkblue">xzoom(1)</font
></tt
>,
<tt><font color="darkblue">xeyes(1)</font
></tt
>, <tt><font color="darkblue">xroach(1)</font
></tt
>.
</p
><p align="justify">
<u>GNOME</u
>:
<tt><font color="darkblue">galeon(1)</font
></tt
>, <tt><font color="darkblue">gimp(1)</font
></tt
>, <tt><font color="darkblue">evolution(1)</font
></tt
>,
<tt><font color="darkblue">gcd(1)</font
></tt
>, <tt><font color="darkblue">gaim(1)</font
></tt
>, <tt><font color="darkblue">abiword(1)</font
></tt
>...
</p
><p align="justify">
<u>KDE</u
>:
<tt><font color="darkblue">konqueror(1)</font
></tt
>, <tt><font color="darkblue">kwrite(1)</font
></tt
>, KOffice (<tt><font color="darkblue">kword(1)</font
></tt
>, etc.),
<tt><font color="darkblue">kontour(1)</font
></tt
>, <tt><font color="darkblue">kroupware(1)</font
></tt
>, <tt><font color="darkblue">kmail(1)</font
></tt
>, <tt><font color="darkblue">kopete(1)</font
></tt
>,
<tt><font color="darkblue">k3b(1)</font
></tt
>, <tt><font color="darkblue">juk(1)</font
></tt
>, etc.
</p
><p align="justify">
<u>EMACS ou XEmacs</u
>:
<code><font color="darkblue">w3</font
></code
>, <code><font color="darkblue">gnus</font
></code
>, <code><font color="darkblue">terminal</font
></code
>, <code><font color="darkblue">shell</font
></code
>...
</p
><p align="justify">
<u>terminal</u
>:
<tt><font color="darkblue">mutt(1)</font
></tt
>,
<tt><font color="darkblue">links(1)</font
></tt
>, <tt><font color="darkblue">lynx(1)</font
></tt
> ou <tt><font color="darkblue">w3m(1)</font
></tt
>;
<tt><font color="darkblue">cdtool(1)</font
></tt
>, <tt><font color="darkblue">aumix(1)</font
></tt
>, <tt><font color="darkblue">epic(1)</font
></tt
>, etc.
</p
><p align="justify">
<u>ligne de commande</u
>:
<tt><font color="darkblue">mailx(1)</font
></tt
>, <tt><font color="darkblue">mix(1)</font
></tt
>, <tt><font color="darkblue">mpg321(1)</font
></tt
>, <tt><font color="darkblue">sox(1)</font
></tt
>, ...
</p
><p align="justify">
<u>filtres mail</u
>:
<tt><font color="darkblue">procmail(1)</font
></tt
>, <tt><font color="darkblue">spamassassin(1)</font
></tt
>, <tt><font color="darkblue">bogofilter(1)</font
></tt
>, ...
</p
><p align="justify">
<u>Common-Lisp</u
>:
<code><font color="darkblue">clim</font
></code
>, <code><font color="darkblue">closure</font
></code
>, ...
</p
><a name="SUBSECTION_5.2"></a
><font size="+1" face="sans-serif"><b>5.2 Quel type de documents produire?</b
></font
><p align="justify">
<u>Sortie finale</u
>.
HTML, man page, info, PDF, PS (PostScript).
Très bien pour les documents en lecture seule, sans plus de modifications,
mais ne convient pas à la modification (sauf retouche très légère).
Pour visionner du HTML, utilisez votre brouteur web habituel:
<tt><font color="darkblue">konqueror(1)</font
></tt
>,
<tt><font color="darkblue">galeon(1)</font
></tt
>,
<tt><font color="darkblue">firefox(1)</font
></tt
>,
<tt><font color="darkblue">opera(1)</font
></tt
> (logiciel exclusif), etc.
Pour visionner du PostScript ou du PDF,
utiliser les dérivés <tt><font color="darkblue">ghostview(1)</font
></tt
>:
<tt><font color="darkblue">gv(1)</font
></tt
>,
<tt><font color="darkblue">ggv(1)</font
></tt
>,
<tt><font color="darkblue">kghostview(1)</font
></tt
>, etc.
Pour le PDF, essayez aussi <tt><font color="darkblue">xpdf(1)</font
></tt
>, <tt><font color="darkblue">acroread(1)</font
></tt
> (logiciel exclusif), etc.
</p
><p align="justify">
<u>Traitement de texte</u
>.
Concept standard avec OpenOffice, Gnome Office, KOffice, etc.
Pour un usage plus avancé, essayez
<a href="http://www.texmacs.org">TeXmacs</a
>.
</p
><p align="justify">
<u>Textes Scientifiques</u
>:
Le standard pour l'écriture de textes scientifiques
est LaTeX, lui-même basé sur TeX.
Prévu pour produire du Postscript ou du PDF:
<tt><font color="darkblue">ps2pdf(1)</font
></tt
> vs <tt><font color="darkblue">pdflatex(1)</font
></tt
>.
Avec, on peut aussi faire du HTML:
<tt><font color="darkblue">hevea(1)</font
></tt
>, <tt><font color="darkblue">LaTeX2HTML(1)</font
></tt
>, <tt><font color="darkblue">tex2page(1)</font
></tt
>.
Notez que si vous ne voulez pas programmer dans un langage abscons,
je vous recommande l'outil graphique TeXmacs cité ci-dessus.
</p
><p align="justify">
<u>Documentation simplifiée</u
>.
Il existe de nombreux systèmes de documentation
facilement éditables et programmables,
qui permettent d'obtenir toute une gamme de sorties,
avec un système plus sympathique que LaTeX,
quoiqu'avec moins de fonctionnalités pour les cas tordus.
Voir par exemple
<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a
>,
<a href="http://www-sop.inria.fr/mimosa/fp/Scribe/">Scribe</a
>,
et tant d'autres.
(cl-typesetting?)
Éviter <tt><font color="darkblue">texinfo(1)</font
></tt
>, <tt><font color="darkblue">perlpod(1)</font
></tt
>.
</p
><p align="justify">
<u>Images</u
>.
JPG pour images lisses avec dégradés continus, comme une photo;
légère perte de qualité mais pas trop grave. Bonne compression.
PNG pour images très tranchées (texte et dessin sur fond blanc, etc.)
MNG pour images animées.
GIF: non! (mauvaise compression, brevets sur la compressions,
features en moins, pas de différenciation facile entre GIF animés ou pas, etc.)
&mdash; voir ci-dessous l'exercice sur le Burn All GIFs day.
Images vectorielles: pas vraiment de standard; selon votre application.
</p
><a name="SUBSECTION_5.3"></a
><font size="+1" face="sans-serif"><b>5.3 Correspondance rapide Windows vers Linux</b
></font
><p align="justify">
Windows a longtemps péché
par l'absence d'un outil de ligne de commande digne de ce nom,
avec l'exécrable <code><font color="darkblue">COMMAND.COM</font
></code
> de MS-DOS et le
<code><font color="darkblue">CMD.EXE</font
></code
> de Windows NT.
Pour ceux d'entre vous qui sont habitués à ces antiques lignes de commande
sous Windows ou MSDOS,
il existe des HOWTOs et pages webs donnant ces correspondances.

</p
><p align="justify">
Correspondances entre commandes.

</p
><p align="justify">
Notons qu'il est aussi possible d'installer sous Windows le sous-système Cygwin
qui permet d'utiliser toutes les fonctionnalités de Linux ou presque, avec ses shells
<tt><font color="darkblue">bash(1)</font
></tt
> ou <tt><font color="darkblue">zsh(1)</font
></tt
>.
</p
><p align="justify">
Enfin, notons que les toutes dernières versions de Windows
(pour développeurs seulement)
possèdent maintenant
le fameux Monad Shell,
dont la brillante conception devance celle des shells de Linux.
Chapeau à Microsoft!
</p
><a name="SUBSECTION_5.4"></a
><font size="+1" face="sans-serif"><b>5.4 Correspondance rapide MacOS vers Linux</b
></font
><p align="justify">

Pour ce qui est de l'UNIX sous-jacent à MacOS,
il s'agit d'une variante de BSD nommée Darwin.
Il y a un échange permanent de sources entre Darwin
et les autres BSD.
Voir la section suivante si vous êtes familiers
avec la ligne de commande sous MacOS X.
</p
><a name="SUBSECTION_5.5"></a
><font size="+1" face="sans-serif"><b>5.5 Différences rapides entre BSD vers Linux</b
></font
><p align="justify">
Les BSD sont l'autre grande famille de systèmes UNIX libres
(ou pas forcément libres, d'ailleurs).
Le principal du groupe est FreeBSD,
mais il y a aussi NetBSD qui tente de tourner partout,
et OpenBSD qui tente d'être aussi sécurisé que possible.
</p
><p align="justify">
Les outils BSD sont souvent plus minimalistes que les outils GNU,
n'ajoutant aux fonctionnalités standards que le strict nécessaire.
Tandis que les outils GNU et autres programmes qui tournent
au-dessus d'un noyau Linux forment un tout disparate,
chacun étant censé fonctionner dans de nombreux
systèmes et contextes différents,
et l'ensemble étant intégré par des gens différents des développeurs,
le noyau et les outils BSD proprement dit forment un tout intégré
développé par des groupes de personnes maintenant la cohérence du tout.
Au final, un système BSD de base aura légèrement moins de fonctionnalités
qu'un système GNU/Linux de base,
mais semblera plus simple, plus dépouillé, plus authentique;
mais ces différences s'estompent après avoir installé
tous les mêmes programmes que sous GNU/Linux
pour ce qui est des outils destinés aux utilisateurs finaux.
</p
><a name="SUBSECTION_5.6"></a
><font size="+1" face="sans-serif"><b>5.6 Différences rapides entre Linux et les UNIX propriétaires</b
></font
><p align="justify">
Sur un système UNIX de base,
<tt><font color="darkblue">sh(1)</font
></tt
> n'a pas d'édition de ligne,
<tt><font color="darkblue">mv(1)</font
></tt
> ne marche pas d'un file-system à l'autre,
<tt><font color="darkblue">mkdir(1)</font
></tt
> n'a pas d'option <code><font color="darkblue">-p</font
></code
>,
<tt><font color="darkblue">cp(1)</font
></tt
> n'a pas forcément d'option <code><font color="darkblue">-a</font
></code
> (mais <code><font color="darkblue">-r -p</font
></code
>),
les versions de <tt><font color="darkblue">patch(1)</font
></tt
> et de <tt><font color="darkblue">diff(1)</font
></tt
> peuvent être obsolètes
(quand elles sont disponibles),
les bugs dans les outils de base n'ont jamais été corrigés,
etc.
Bref, il y a à peine de quoi survivre.
Heureusement, on peut installer les outils GNU
en remplacement des outils de base.
</p
><p align="justify">
Par contre, les UNIX propriétaires offrent souvent
(contre espèces sonnantes et trébuchantes)
un matériel conçu spécialement pour fournir des serveurs robustes,
des compilateurs optimisant donnant du code de qualité supérieure,
un support technique garanti,
etc.
Toutefois, il est aussi possible d'acheter une licence
pour un tel compilateur et l'utiliser sous Linux,
et d'acheter le support technique sous Linux.
Bref, il s'agit pour une entreprise d'une question économique.
Pour un particulier, en général, il n'y a pas photo,
et la familiarité des particuliers avec Linux
contribue à abaisser le coût de Linux pour les entreprises.
</p
><a name="SECTION_6"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>6 Tout se complique</b
></font
></td
></tr
></table
><a name="SUBSECTION_6.1"></a
><font size="+1" face="sans-serif"><b>6.1 Disquettes, CD-ROMs, etc.</b
></font
><p align="justify">
Les distributions récentes ont souvent un système d'automontage
(par exemple avec <tt><font color="darkblue">automount(8)</font
></tt
>)
ou de montage à la volée quand on clique au bon endroit.
Sinon, on peut monter et démonter à la main avec
<tt><font color="darkblue">mount(8)</font
></tt
> et <tt><font color="darkblue">umount(8)</font
></tt
> (mais il faut être <code><font color="darkblue">root</font
></code
>).
</p
><p align="justify">
Pour utiliser plus simplement disquette formattée au format VFAT
(utilisé par MSDOS et Windows, lu par tout le monde),
il existe une interface accessible par tous les utilisateurs
qui ont accès au lecteur de disquette
(typiquement, en les mettant dans un groupe qui a accès à <code><font color="darkblue">/dev/fd0</font
></code
>):
<tt><font color="darkblue">mtools(1)</font
></tt
>, et ses commandes
(<tt><font color="darkblue">mdir(1)</font
></tt
>, <tt><font color="darkblue">mcopy(1)</font
></tt
>, <tt><font color="darkblue">mdel(1)</font
></tt
>, <tt><font color="darkblue">mcd(1)</font
></tt
>, <tt><font color="darkblue">mren(1)</font
></tt
>,
<tt><font color="darkblue">mformat(1)</font
></tt
>, etc.) qui mimiquent les commandes équivalentes sous DOS.
</p
><p align="justify">
On peut formatter physiquement une disquette avec <tt><font color="darkblue">superformat(1)</font
></tt
>
(ou avec son prédecesseur <tt><font color="darkblue">fdformat(8)</font
></tt
>).
Pour mettre dessus un système de fichier,
on peut utiliser <tt><font color="darkblue">mformat(1)</font
></tt
> pour le format VFAT,
ou sinon <tt><font color="darkblue">mkfs(8)</font
></tt
> et ses variantes spécialisées
(<tt><font color="darkblue">mkdosfs(8)</font
></tt
> pour le format VFAT,
<tt><font color="darkblue">mke2fs(8)</font
></tt
> pour le <code><font color="darkblue">ext2</font
></code
>, etc.).
</p
><p align="justify">
Pour les CD-ROMs et DVD-ROMs, on pourra utiliser <tt><font color="darkblue">k3b(1)</font
></tt
> et <tt><font color="darkblue">k9copy</font
></tt
>.
</p
><p align="justify">
Pour plus d'information, voir les HOWTOs appropriés.
</p
><a name="SUBSECTION_6.2"></a
><font size="+1" face="sans-serif"><b>6.2 Les bibliothèques à liaison dynamiques</b
></font
><p align="justify">
Pour partager des fonctionnalités entre de nombreux programmes,
Linux possède comme tous les systèmes d'exploitation moderne
un système de
<em>bibliothèques à liaison dynamique</em
> (anglais: <em>Dynamic Link Libraries</em
>),
aussi appelé système de <em>bibliothèques partagées</em
> (anglais: <em>Shared Libraries</em
>).
Cela permet de ne pas gâcher de la mémoire
en répliquant ces fonctionnalités dans chaque processus;
cela permet aussi la mise à jour de ces fonctionnalités
sans avoir à recompiler tous les programmes;
cela permet enfin de charger dynamiquement
des extensions et autres <i>plugins</i
>
compilées séparément des programmes qui les utilisent.
Mais cela nécessite parfois un peu de maintenance.
</p
><p align="justify">
Le processus normal:
<ul><li>
Linux voit que le programme <tt><font color="darkblue">execve(2)</font
></tt
>uté
est un programme à liaison dynamique <a name="footnoteref77"></a
><a href="#footnote77"><sup><font size="-1">[77]</font
></sup
></a
>.
</li
><li>
Linux charge le programme en mémoire
avec la bibliothèque spéciale <code><font color="darkblue">/lib/ld*.so*</font
></code
>,
qui s'occupe de faire la liaison des autres bibliothèques dynamiques
<a name="footnoteref78"></a
><a href="#footnote78"><sup><font size="-1">[78]</font
></sup
></a
>.
</li
><li>
Chaque programme se souvient du nom et du numéro de version majeure
de chacune des bibliothèques dont il a besoin
<a name="footnoteref79"></a
><a href="#footnote79"><sup><font size="-1">[79]</font
></sup
></a
>.
<tt><font color="darkblue">ld.so(8)</font
></tt
> va les chercher dans les chemins
définis selon sa configuration globale dans <code><font color="darkblue">/etc/ld.so.conf</font
></code
>
<a name="footnoteref80"></a
><a href="#footnote80"><sup><font size="-1">[80]</font
></sup
></a
>
<a name="footnoteref81"></a
><a href="#footnote81"><sup><font size="-1">[81]</font
></sup
></a
>.
Si le programme exécuté n'a pas de bit s,
alors <tt><font color="darkblue">ld.so(8)</font
></tt
> consultera <code><font color="darkblue">$LD_LIBRARY_PATH</font
></code
>
de préférence à <tt><font color="darkblue">ld.so.conf(5)</font
></tt
>.
</li
><li>
Si le programme n'a pas de bit s
et que la variable <code><font color="darkblue">LD_PRELOAD</font
></code
> est définie,
alors <tt><font color="darkblue">ld.so(8)</font
></tt
> charge la bibliothèque dynamique spécifiée,
qui pourra remplacer la définition de certains appels d'API.
Très pratique pour greffer des fonctionnalités à des programmes
<a name="footnoteref82"></a
><a href="#footnote82"><sup><font size="-1">[82]</font
></sup
></a
>.
</li
><li>
<tt><font color="darkblue">ld.so(8)</font
></tt
> utilise <tt><font color="darkblue">mmap(2)</font
></tt
>
pour rendre les bibliothèques accessibles au processus courant
et leur attribuer des zones de données
<a name="footnoteref83"></a
><a href="#footnote83"><sup><font size="-1">[83]</font
></sup
></a
>.
Puis il finalise la liaison en modifiant les bonnes variables,
et effectue les initialisations de chaque bibliothèque.
</li
></ul
>
</p
><p align="justify">
On peut examiner les appels API qu'effectue un programme
vers ses bibliothèques dynamiques grâce à l'utilitaire <tt><font color="darkblue">ltrace(1)</font
></tt
>
<a name="footnoteref84"></a
><a href="#footnote84"><sup><font size="-1">[84]</font
></sup
></a
>.
</p
><p align="justify">
API: cf. <tt><font color="darkblue">dlopen(3)</font
></tt
>, documentation du format de fichier ELF,
le <a href="http://www.tldp.org/HOWTO/Program-Library-HOWTO/">Program-Library-HOWTO</a
>,
etc.
</p
><p align="justify">
<u>Pertinence</u
>:
si des bibliothèques partagées requises pour un programme
ne sont pas présentes, ce programme ne fonctionnera pas.
Il faudra les installer.
Assurez-vous que les bibliothèques nécessaires
sont bien disponibles dans <code><font color="darkblue">/lib</font
></code
> et <code><font color="darkblue">/usr/lib</font
></code
> <a name="footnoteref85"></a
><a href="#footnote85"><sup><font size="-1">[85]</font
></sup
></a
>.
Les distributions modernes gèrent automatiquement les dépendances
entre les programmes qu'elles installent et leurs bibliothèques.
</p
><a name="SUBSECTION_6.3"></a
><font size="+1" face="sans-serif"><b>6.3 Gestion du temps</b
></font
><p align="justify">
Pour lancer des processus à intervalles réguliers: <tt><font color="darkblue">cron(8)</font
></tt
>.
Pour machines non allumées en permanence, voir aussi <tt><font color="darkblue">anacron(8)</font
></tt
>.
</p
><p align="justify">
Lancer un processus une seule fois: <tt><font color="darkblue">at(8)</font
></tt
>. Voire, <tt><font color="darkblue">sleep(1)</font
></tt
>.
</p
><p align="justify">
Agenda personnel, alarme de notification, etc.:
il y a une offre diversifiée qui a beaucoup évolué.
</p
><p align="justify">
Programme de base pour obtenir la date et l'heure: <tt><font color="darkblue">date(1)</font
></tt
>
<a name="footnoteref86"></a
><a href="#footnote86"><sup><font size="-1">[86]</font
></sup
></a
>.
Changer la date et l'heure, pour l'administrateur seulement:
option <code><font color="darkblue">-s</font
></code
>.
</p
><p align="justify">
Temps universel vs timezones.
lien symbolique <code><font color="darkblue">/etc/localtime</font
></code
>.
<code><font color="darkblue">TZ=Asia/Tokyo date</font
></code
>.
</p
><p align="justify">
Horloge système: <tt><font color="darkblue">hwclock(8)</font
></tt
>.
Temps universel ou non (option <code><font color="darkblue">-u</font
></code
>):
Problème de partage avec Windows ou MacOS (!).
</p
><p align="justify">
Temps réseau: protocole NTP,
usage ponctuel avec <tt><font color="darkblue">ntpdate(1)</font
></tt
>, démon <tt><font color="darkblue">ntp(1)</font
></tt
>.
</p
><p align="justify">
UNIX note le temps en seconde sur un entier signé 32 bits depuis début 1970
(l'année de la conception d'UNIX) <a name="footnoteref87"></a
><a href="#footnote87"><sup><font size="-1">[87]</font
></sup
></a
>.
Il n'y a donc pas de bug de l'an 2000, mais bug de l'an 2030 et quelques!
Exercice: trouver l'instant précis de la fin du monde, à la seconde près.
Hint: on pourra par exemple procéder par dichotomie,
grâce à des commandes du genre
<code><font color="darkblue">date -u -d '1970-01-01 00:00:00 UTC'</font
></code
>;
mais il existe une solution plus simple encore
<a name="footnoteref88"></a
><a href="#footnote88"><sup><font size="-1">[88]</font
></sup
></a
>.
</p
><p align="justify">
Tricher sur l'heure pour un processus
(bug de l'an 2000 ou 20xx, licence expirée, test):
c'est possible en interceptant les appels d'API qui donnent l'heure,
via <code><font color="darkblue">$LD_PRELOAD</font
></code
>
<a name="footnoteref89"></a
><a href="#footnote89"><sup><font size="-1">[89]</font
></sup
></a
>
(au pire, il faudra modifier le binaire s'il est statiquement lié,
en s'aidant de <tt><font color="darkblue">strace(1)</font
></tt
> et de <tt><font color="darkblue">gdb(1)</font
></tt
>).
</p
><p align="justify">
API du noyau: <tt><font color="darkblue">gettimeofday(2)</font
></tt
>, <tt><font color="darkblue">time(2)</font
></tt
>,
<tt><font color="darkblue">nanosleep(2)</font
></tt
>, <tt><font color="darkblue">setitimer(2)</font
></tt
>, etc.
Cf. <code><font color="darkblue">/usr/include/time.h</font
></code
> et consorts,
tels que listés dans les pages de manuel.
Voir surtout la documentation de votre langage de programmation favori.
</p
><a name="SUBSECTION_6.4"></a
><font size="+1" face="sans-serif"><b>6.4 Les terminaux</b
></font
><a name="SUBSUBSECTION_6.4.1"></a
><p align="left"><b>6.4.1 Principe du terminal</b
> </p
><p align="justify">
Dans le pas-si-bon vieux temps,
on accédait à ses machines via des terminaux
reliés à la machine par une ligne série.
Le terminal envoie à la machine
ce que l'on tape au clavier
sous forme du code ASCII des caractères tapés,
et reçoit ce qu'il doit afficher de la même façon
<a name="footnoteref90"></a
><a href="#footnote90"><sup><font size="-1">[90]</font
></sup
></a
>
<a name="footnoteref91"></a
><a href="#footnote91"><sup><font size="-1">[91]</font
></sup
></a
>.
Des <em>séquences d'échappement</em
> (anglais: <em>escape sequences</em
>)
de plusieurs caractères comprenant des caractères de contrôle,
sont employées pour obtenir des effets spéciaux;
par exemple, les touches flèches de direction
enverront chacune une séquence spécifique,
tandis que l'ordinateur enverra aussi des séquences
pour positionner le curseur dans la fenêtre,
écrire en gras, changer de couleur, etc.
<a name="footnoteref92"></a
><a href="#footnote92"><sup><font size="-1">[92]</font
></sup
></a
>
</p
><p align="justify">
Malgré la grande variété des terminaux,
le principe lui-même est devenu un standard de fait,
repris par tous les systèmes de type UNIX,
et conservé même à l'heure des interfaces graphiques.
S'il fallait faire le procès des terminaux,
voici ce que je retiendrais.
</p
><p align="justify">
Points négatifs:
<ul><li>
C'est vraiment moche.
C'est peu navigable, l'aide est difficile d'accès,
plantages et semi-plantages bizarres
pas de standard d'interface pour s'y reconnaître.
Il faut apprendre beaucoup de <em>détails peu ragoûtants</em
> (anglais: <em>gory details</em
>)
qu'on préféreraient ne jamais avoir rencontrés.
C'est (voix vibrante) l'horreur jaillie du fin fonds des années 1960.
<a href="http://www.cthulhu.org/">Cthulhu f'tagn</a
>
(rire sardonique).
En tout cas, ça ne vaut pas une interface graphique question ergonomie.
</li
><li>
On ne peut pas afficher simplement des graphiques voire pas du tout
<a name="footnoteref93"></a
><a href="#footnote93"><sup><font size="-1">[93]</font
></sup
></a
>,
alors que souvent une image vaut bien un long discours,
quand le discours est même possible <a name="footnoteref94"></a
><a href="#footnote94"><sup><font size="-1">[94]</font
></sup
></a
>!
</li
><li>
Obtenir une interface interactive correcte sur un terminal
n'est pas plus facile à programmer qu'une interface graphique
(c'est même assez horrible).
</li
><li>
Le copier-coller est limité à du texte, quand il est possible
<a name="footnoteref95"></a
><a href="#footnote95"><sup><font size="-1">[95]</font
></sup
></a
>.
</li
><li>
Les terminaux série sont lents.
La connexion par réseau internet peut être lente aussi.
M'enfin il est vrai que «&nbsp;lent&nbsp;»
est infiniment plus rapide que «&nbsp;pas possible du tout&nbsp;».
</li
></ul
>
Points positifs:
<ul><li>
Ça marche partout.
Ça permet de se connecter à distance de façon sécurisée par telnet ou SSH
(UNIX: ssh, Windows: PuTTY, MacOS 7 à 9: nifty telnet, Java: mindterm),
ou avec un câble série.
Ainsi, on peut administrer son matériel, déboguer ses routeurs,
ou consulter ses données,
sans avoir besoin d'attacher écran et clavier
et même sans être physiquement près de la machine.
Il est vrai qu'il y a possibilité d'avoir un affichage graphique déporté
sous Linux (VNC, client X, etc.), Windows (VNC, Citrix, etc.),
MacOS (VNC, etc.), mais le mode terminal demande moins de bande passante,
et surtout, il marche aussi sur des ordinateurs embarqués
qui n'ont pas d'interface graphique du tout,
et non pas seulement des gros serveurs ou stations de travail!
</li
><li>
Offre une interface très facile à programmer dans les cas simples.
La barre à franchir avant de pouvoir écrire un programme utile
est très très basse.
D'où profusion de petits programmes utiles,
grand foisonnement d'utilitaires d'où surgit parfois des perles.
</li
><li>
Si les programmes fonctionnent en ligne de commande,
ils sont faciles à diriger et combiner avec le shell
(avec une interface graphique, bonjour la galère!)
Même quand ils sont graphiques,
on peut quand même essayer avec <tt><font color="darkblue">expect(1)</font
></tt
>.
Le terminal incite à fournir des interfaces simples,
et programmables ou combinables.
Littérature vs transmission orale.
Voir l'article de Neal Stephenson déjà cité,
<a href="http://artlung.com/smorgasborg/C_R_Y_P_T_O_N_O_M_I_C_O_N.shtml"><i>In the beginning was the command line</i
></a
>
et notre discussion dans la section ci-dessous sur le terminal.
</li
><li>
Incite à séparer la logique du programme
et le frontal qui servira d'interface graphique
pour les néophytes et autres utilisateurs:
robustesse, netteté conceptuelle, facilité de déployer sur le réseau.
</li
><li>
Pas de perte de temps avec des interfaces grotesques
qui noient l'essentiel sous les détails tape-à-l'&oelig;il.
</li
></ul
>
</p
><a name="SUBSUBSECTION_6.4.2"></a
><p align="left"><b>6.4.2 Configuration du terminal</b
> </p
><p align="justify">
Il existe de très nombreux types de terminaux différents,
parfois subtilement différents,
sans parler des types de liaisons différentes
(câble série, modem, service télématique, services réseau,
couche d'émulation, etc.)
et des enchaînement de moyens de liaisons entre le terminal final
et la machine effective qui envoie les ordres,
sans parler des diverses options à configurer
à chaque étape de tels enchaînements.
Aussi, la configuration d'un terminal peut être extrêmement compliquée.
Heureusement, les cas simples,
comme par exemple se loguer sur la machine locale préconfigurée
par un intégrateur compétent,
marchent tout seuls sans effort.
</p
><p align="justify">
Le type de terminal utilisé: <code><font color="darkblue">echo $TERM</font
></code
> <a name="footnoteref96"></a
><a href="#footnote96"><sup><font size="-1">[96]</font
></sup
></a
>.
</p
><p align="justify">
La taille du terminal est dans <code><font color="darkblue">$ROWS</font
></code
> et <code><font color="darkblue">$COLUMNS</font
></code
>;
si ce n'est pas fait automatiquement,
on peut mettre ces variables à la bonne valeur
avec <code><font color="darkblue">eval $(/usr/bin/resize)</font
></code
> <a name="footnoteref97"></a
><a href="#footnote97"><sup><font size="-1">[97]</font
></sup
></a
>.
</p
><p align="justify">
Pour déterminer le nom du device auquel est connecté le programme actuel:
<tt><font color="darkblue">tty(1)</font
></tt
>.
Sous <tt><font color="darkblue">bash(1)</font
></tt
>: <code><font color="darkblue">echo $tty</font
></code
>.
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>: <code><font color="darkblue">echo $TTY</font
></code
>.
</p
><p align="justify">
Pour configurer la liaison série (réelle ou virtuelle)
entre le terminal et l'ordinateur
(du moins sur le tronçon géré par la machine actuelle),
la commande <tt><font color="darkblue">stty(1)</font
></tt
> est votre amie.
Par exemple, pour voir toute la configuration actuelle, <code><font color="darkblue">stty -a</font
></code
>.
</p
><p align="justify">
Pour configurer la <tt><font color="darkblue">locale(1)</font
></tt
> de votre terminal,
exportez les variables appropriées dans votre configuration shell.
On changera typiquement <code><font color="darkblue">LANG</font
></code
> et <code><font color="darkblue">LC_CTYPE</font
></code
>
ou bien <code><font color="darkblue">LANG</font
></code
> et <code><font color="darkblue">LC_ALL</font
></code
>.
Quelques valeurs possibles pour la langue:
<code><font color="darkblue">fr_FR</font
></code
>,
<code><font color="darkblue">de_DE</font
></code
>,
<code><font color="darkblue">fr_LU</font
></code
>,
<code><font color="darkblue">de_LU</font
></code
>,
<code><font color="darkblue">en_US</font
></code
>, etc.
Quelques valeurs possibles pour le jeu de caractères:
<code><font color="darkblue">iso-8859-1</font
></code
>,
<code><font color="darkblue">utf-8</font
></code
>.
En combinant les deux, on obtient des définitions telles que les suivantes:
<code><font color="darkblue">export LC_CTYPE=en_US.iso-8859-1</font
></code
>
ou
<code><font color="darkblue">export LC_ALL=de_DE.utf-8</font
></code
>.
Notons aussi les variantes euro:
<code><font color="darkblue">export LC_ALL=fr_LU@euro.iso-8859-15</font
></code
>.
(à ce jour, pas de locale définie pour <code><font color="darkblue">lb_LU@euro.iso-8859-15</font
></code
>.)
</p
><p align="justify">
Attention: le terminal peut avoir été lancé ou configuré
avec un codage de caractère différent de celui que vous déclarez aux programmes
que vous lancez dans ledit terminal.
À vous de veillez à ce que cela ne se produise pas,
ou à vous arranger avec le résultat (<tt><font color="darkblue">recode(1)</font
></tt
> peut aider).
Si vous avez un terminal graphique,
vérifier dans les menus le <em>codage des caractères</em
> (anglais: <em>character encoding</em
>);
Votre bureau graphique, GNOME ou KDE, gère sans doute ces histoires de locale.
Si vous utilisez la console Linux,
vos scripts de démarrage peuvent configurer la console;
à vous de voir selon votre distribution
<a name="footnoteref98"></a
><a href="#footnote98"><sup><font size="-1">[98]</font
></sup
></a
>.
Et si vous vous loguez à distance, utilisez un codage qui existe sur les deux machines.
L'un de ceux-ci devrait fonctionner:
<code><font color="darkblue">en_US.iso-8859-1</font
></code
>, <code><font color="darkblue">en_US.utf-8</font
></code
>;
au pire, <code><font color="darkblue">C</font
></code
> ou <code><font color="darkblue">POSIX</font
></code
> fonctionne partout,
et doit être plus ou moins équivalent à <code><font color="darkblue">en_US.ASCII</font
></code
>
et à <code><font color="darkblue">en_US.ANSI_X3.4-1968</font
></code
>.
</p
><a name="SUBSUBSECTION_6.4.3"></a
><p align="left"><b>6.4.3 Multiplexer son terminal</b
> </p
><p align="justify">
Programme très utile pour multiplexer un terminal
et avoir des sessions qu'on peut détacher et rattacher:
<tt><font color="darkblue">screen(1)</font
></tt
> <a name="footnoteref99"></a
><a href="#footnote99"><sup><font size="-1">[99]</font
></sup
></a
>.
</p
><p align="justify">
Emacs est aussi capable de lancer des programmes à l'intérieur
d'une fenêtre texte qu'il contrôle,
avec <code><font color="darkblue">M-x shell</font
></code
> et <code><font color="darkblue">M-x terminal</font
></code
>.
Le même Emacs peut aussi être lancé dans plusieurs fenêtres et/ou terminaux
grâce à <code><font color="darkblue">M-x gnuserv</font
></code
> et <tt><font color="darkblue">gnuclient(1)</font
></tt
>.
</p
><a name="SUBSUBSECTION_6.4.4"></a
><p align="left"><b>6.4.4 Programmer son terminal</b
> </p
><p align="justify">
Pour connaître l'ensemble des séquences d'échappement
reconnues par les divers terminaux, voir la base de données <tt><font color="darkblue">termcap(5)</font
></tt
>
et son successeur «&nbsp;moderne&nbsp;» <tt><font color="darkblue">terminfo(5)</font
></tt
>.
Pour le terminal que vous utilisez en particulier,
rien ne vaut le code source du programme en question.
Par exemple, les sources du noyau linux pour la console en mode texte,
ou les sources de <code><font color="darkblue">xterm</font
></code
> ou de <code><font color="darkblue">konsole</font
></code
>
pour un terminal en mode graphique, etc.
</p
><p align="justify">
Truc marrant: avec une séquence d'échappement appropriée,
on peut changer le titre du terminal
dans <code><font color="darkblue">xterm(1x)</font
></code
> ou <tt><font color="darkblue">screen(1)</font
></tt
>.
Exercice: lire la doc desdits programmes,
et mettre un message simple dans le titre.
Exercice plus long: changer son <code><font color="darkblue">.bashrc</font
></code
> ou <code><font color="darkblue">.zshrc</font
></code
>
pour mettre le chemin d'accès courant dans le titre de la fenêtre
<a name="footnoteref100"></a
><a href="#footnote100"><sup><font size="-1">[100]</font
></sup
></a
>.
</p
><p align="justify">
Mode d'entrée: le terminal possède de nombreux modes de fonctionnement.
Avec le mode brut
(littéralement <em>cru</em
> (anglais: <em>raw</em
>) en anglais,
utiliser <code><font color="darkblue">stty raw</font
></code
> ou <tt><font color="darkblue">cfmakeraw(2)</font
></tt
>,
ou sous <tt><font color="darkblue">zsh(1)</font
></tt
>, la commande interne <code><font color="darkblue">read -k</font
></code
>),
les processus connectés au terminal peuvent lire directement
tout caractère (ou toute séquence de caractères) saisi(e) au clavier.
Cependant, avec le mode par défaut, le mode préparé
(littéralement, <em>cuit</em
> (anglais: <em>cooked</em
>), <code><font color="darkblue">stty cooked</font
></code
>),
le gestionnaire de terminal inclus dans le noyau
gérera pour les programmes qui ne veulent pas s'en soucier
une édition de ligne rudimentaire et d'autres transformations utiles:
il n'enverra au programme lecteur le texte saisi
qu'après réception de la touche entrée;
cela lui permet de gérer l'effacement arrière (<tt><font color="brown">BackSpace</font
></tt
>)
et l'annulation de la ligne (<tt><font color="brown">C-u</font
></tt
>),
ainsi que le signal de fin de fichier (<tt><font color="brown">C-d</font
></tt
> en début de ligne).
</p
><p align="justify">
API pour Programmer son terminal.
Connexion: <tt><font color="darkblue">termios(3)</font
></tt
>.
édition de ligne de commande: <tt><font color="darkblue">readline(3)</font
></tt
>.
Écran texte adressable: <tt><font color="darkblue">ncurses(3)</font
></tt
>
(utilise la base de données <tt><font color="darkblue">terminfo(5)</font
></tt
>,
ou plus anciennement <tt><font color="darkblue">termcap(5)</font
></tt
>).
Souris: <tt><font color="darkblue">libgpm(3)</font
></tt
>.
Graphiques: <code><font color="darkblue">aalib</font
></code
> (essayer <tt><font color="darkblue">bb(1)</font
></tt
>).
Fenêtrage: utilitaires comme <tt><font color="darkblue">dialog(1)</font
></tt
>, plusieurs bibliothèques.
Fournir un pseudo-terminal: voir comment faire <tt><font color="darkblue">screen(1)</font
></tt
>.
</p
><a name="SUBSUBSECTION_6.4.5"></a
><p align="left"><b>6.4.5 Déboguer son terminal</b
> </p
><p align="justify">
Dans les cas simples,
remettre une configuration correcte du terminal
laissé en rade par un programme improprement interrompu:
<code><font color="darkblue">stty sane</font
></code
>.
</p
><p align="justify">
Remettre complètement à zéro son terminal
quand il est vraiment dans un sale état:
<code><font color="darkblue">/usr/bin/reset</font
></code
> &mdash; normalement, cela fait tout ce qu'il faut.
</p
><p align="justify">
Autres plantages fréquents, et solutions:
<ul><li>
Symptôme:
Deux programmes différents lisent sur le même terminal,
et les caractères tapés sont lus tantôt par l'un, tantôt par l'autre.
Solution:
tuer l'un des programmes
(par exemple depuis un autre terminal avec la commande <tt><font color="darkblue">kill(1)</font
></tt
>,
ou en mode cuit en lui envoyant une fin de fichier
avec un <tt><font color="brown">C-d</font
></tt
> en début de ligne).
</li
><li>
Symptôme:
Après une confusion quelconque où un autre programme a mis le terminal
en mode cuit, le programme interactif actuel croit être en mode cru
et ne réagit pas aux touches enfoncées.
En fait, le noyau attend que la touche entrée soit enfoncée
avant d'envoyer des données au programme.
Solution: effacer vos frappes vaines avec <tt><font color="brown">C-u</font
></tt
>,
taper une série de commandes valides pour quitter proprement votre programme
et la terminer par la touche entrée.
Autre solution: finir le programme avec <tt><font color="brown">C-c</font
></tt
>.
Autre solution: interrompre le programme avec <tt><font color="brown">C-z</font
></tt
>
puis le réactiver avec <code><font color="darkblue">fg</font
></code
>
en espérant qu'il remettra le terminal en mode cru;
s'il ne le fait pas, réinterrompre avec <tt><font color="brown">C-z</font
></tt
>,
puis changer le terminal en mode cru avec <code><font color="darkblue">stty raw</font
></code
>
avant de refaire <code><font color="darkblue">fg</font
></code
>
<a name="footnoteref101"></a
><a href="#footnote101"><sup><font size="-1">[101]</font
></sup
></a
>.
</li
><li>
Symptôme:
Les caractères du terminal passent, mais
le programme que vous utilisez est effectivement planté.
Solution:
Tuez-le avec <tt><font color="brown">C-c</font
></tt
>. S'il résiste, utilisez <tt><font color="brown">C-\</font
></tt
>,
ou <tt><font color="brown">C-c</font
></tt
> puis <code><font color="darkblue">kill</font
></code
>
<a name="footnoteref102"></a
><a href="#footnote102"><sup><font size="-1">[102]</font
></sup
></a
>.
Au pire, tuez-le depuis un autre terminal
avec <tt><font color="darkblue">kill(1)</font
></tt
>, <code><font color="darkblue">kill -1</font
></code
> voire <code><font color="darkblue">kill -9</font
></code
>,
ou fermez sa fenêtre.
</li
><li>
Symptôme:
Vous tapez quelque chose, mais les caractères ne passent pas.
Quand vous êtes connecté à distance, ce peut parfois être
un problème de connexion &mdash; tentez un <tt><font color="darkblue">ping(1)</font
></tt
> de la machine distante.
Mais parfois, c'est dû à ce que vous avez activé par mégarde,
le <em>contrôle de flux</em
> (anglais: <em>flow control</em
>).
Par exemple, vous avez enfoncé la touche <tt><font color="brown">Scroll-Lock</font
></tt
>.
Solution:
relancez le flux en réappuyant sur <tt><font color="brown">Scroll-Lock</font
></tt
>.
Variante:
si le flow control par XON/XOFF est activé
(par exemple avec <code><font color="darkblue">stty ixon</font
></code
>)
alors un caractère XON (<tt><font color="brown">C-s</font
></tt
>) bloque le terminal;
envoyer un XOFF (<tt><font color="brown">C-q</font
></tt
>) pour débloquer.
Utilisez <code><font color="darkblue">stty -ixon</font
></code
> pour désactiver le contrôle de flux par XON/XOFF,
ou <tt><font color="brown">C-a C-f</font
></tt
> sous <tt><font color="darkblue">screen(1)</font
></tt
> pour changer l'état de ce contrôle.
</li
><li>
Symptôme:
les allez-à-la-ligne vont à la ligne suivante
sans retourner au début de la ligne.
Solution:
Utiliser <code><font color="darkblue">stty sane</font
></code
>,
ou sous un <tt><font color="darkblue">stty(1)</font
></tt
> antique,
<code><font color="darkblue">stty -inlcr -igncr icrnl -ocrnl onlcr -onocr -onlret</font
></code
> (beuark).
</li
><li>
Symptôme:
après avoir envoyé un fichier binaire à l'écran,
les caractères sont devenus bizarres;
c'est le caractère <tt><font color="brown">C-n</font
></tt
> qui a mis le terminal dans ce mode.
Solution:
Remettez le terminal en mode normal avec un <tt><font color="brown">C-o</font
></tt
>,
par la commande <code><font color="darkblue">echo ^O</font
></code
>
(ce que le shell affichera <code><font color="darkblue">^O</font
></code
> est en fait un <tt><font color="brown">Contrôle-O</font
></tt
>;
tapez-le dans votre shell avec la séquence de touches <tt><font color="brown">C-v C-o</font
></tt
>).
</li
><li>
Symptôme:
sous la console Linux,
les caractères accentués donnent soudain un résultat bizarre.
Solution:
Utilisez les séquences <tt><font color="brown">ESC ( <i>$x</i
></font
></tt
>, avec <tt><font color="brown">$x</font
></tt
>
valant <tt><font color="brown">B</font
></tt
>, <tt><font color="brown">0</font
></tt
>, <tt><font color="brown">U</font
></tt
> ou <tt><font color="brown">K</font
></tt
>
pour changer le mode de traitement des caractères 8-bit.
(Utilisez <tt><font color="brown">C-v</font
></tt
> pour taper le <tt><font color="brown">ESC</font
></tt
> dans votre shell;
<tt><font color="brown">C-q</font
></tt
> si vous le tapez sous EMACS.)
Pour une explication, lire <code><font color="darkblue">/usr/src/linux*/Documentation/unicode.txt</font
></code
>.
</li
><li>
Symptôme:
Les caractères accentués sont systématiquement erronnés.
Solution:
s'assurer que la <tt><font color="darkblue">locale(1)</font
></tt
> est bien définie,
et/ou relancer le terminal avec la bonne <tt><font color="darkblue">locale(7)</font
></tt
>.
Voir ci-dessus la section sur configuration du terminal.
</li
><li>
Symptôme:
un de vos <tt><font color="darkblue">xterm(1x)</font
></tt
> monopolise le clavier pour le serveur X,
via l'option <code><font color="darkblue">Secure Keyboard</font
></code
> du menu accessible
avec <tt><font color="brown">Ctrl-bouton-gauche</font
></tt
>.
Solution:
désactiver cette option ou tuer le <code><font color="darkblue">xterm</font
></code
>.
(Note: il y a d'autres menus
sur <tt><font color="brown">Ctrl-bouton-milieu</font
></tt
> et <tt><font color="brown">Ctrl-bouton-droit</font
></tt
>.)
</li
></ul
>
</p
><p align="justify">
Slogans menteurs:
War is Peace.
Freedom is Slavery.
Ignorance is Strength. <a name="footnoteref103"></a
><a href="#footnote103"><sup><font size="-1">[103]</font
></sup
></a
>
<tt><font color="brown">BackSpace</font
></tt
> is <tt><font color="brown">Delete</font
></tt
> <a name="footnoteref104"></a
><a href="#footnote104"><sup><font size="-1">[104]</font
></sup
></a
>.
<tt><font color="brown">Alt</font
></tt
> is <tt><font color="brown">Meta</font
></tt
> <a name="footnoteref105"></a
><a href="#footnote105"><sup><font size="-1">[105]</font
></sup
></a
>.
<tt><font color="brown">Meta</font
></tt
> is <tt><font color="brown">Escape</font
></tt
> <a name="footnoteref106"></a
><a href="#footnote106"><sup><font size="-1">[106]</font
></sup
></a
>.

Your program is 8-bit clean
<a name="footnoteref107"></a
><a href="#footnote107"><sup><font size="-1">[107]</font
></sup
></a
>.
Your terminal is 8-bit clean
<a name="footnoteref108"></a
><a href="#footnote108"><sup><font size="-1">[108]</font
></sup
></a
>.
</p
><a name="SUBSECTION_6.5"></a
><font size="+1" face="sans-serif"><b>6.5 Connexion à distance</b
></font
><p align="justify">
Se connecter à distance: <tt><font color="darkblue">ssh(1)</font
></tt
>.
Clefs avec ou sans mot de passe.
Sessions pour ne taper sa clef qu'une fois:
<tt><font color="darkblue">ssh-agent(1)</font
></tt
>, <tt><font color="darkblue">ssh-add(1)</font
></tt
>.
ssh permet aussi de faire des redirections de ports
pour accéder à des services de part et d'autre de la connexion
(typiquement: accès sécurisé au serveur X
et à d'autres services non protégés).
</p
><p align="justify">
Si c'est pour interagir dans un terminal,
<tt><font color="darkblue">screen(1)</font
></tt
> non seulement vous permettra de multiplexer vos sessions,
mais aussi de les reprendre après que la connexion
soit interrompue et rétablie (indispensable sur des lignes peu fiables).
</p
><p align="justify">
Échange de fichiers: <tt><font color="darkblue">scp(1)</font
></tt
>.
<tt><font color="darkblue">rsync(1)</font
></tt
> met à jour en ne transmettant que le nécessaire.
<tt><font color="darkblue">unison(1)</font
></tt
> met à jour dans les deux sens.
</p
><p align="justify">
<tt><font color="darkblue">scp(1)</font
></tt
> et son équivalent plus interactif <tt><font color="darkblue">sftp(1)</font
></tt
>
est le moyen sécurisé de transmettre des fichiers personnels
(sous Windows: <code><font color="darkblue">WinSCP2</font
></code
>).
Le protocole <code><font color="darkblue">FTP</font
></code
> (mon client préféré: <tt><font color="darkblue">lftp(1)</font
></tt
>)
reste un moyen répandu de publier des données,
et est aussi utilisé par certains ISP pour des sites ouèbes personnels.
Sinon, vous pouvez aussi publier par <code><font color="darkblue">HTTP</font
></code
>,
et récupérer ainsi vos fichiers avec n'importe quel navigateur ouèbe.
</p
><p align="justify">
Au lieu de <tt><font color="darkblue">ssh(1)</font
></tt
> et consorts, il existait autrefois les programmes
<tt><font color="darkblue">rsh(1)</font
></tt
>, <tt><font color="darkblue">rcp(1)</font
></tt
>, <tt><font color="darkblue">rlogin(1)</font
></tt
>, <tt><font color="darkblue">telnet(1)</font
></tt
>.
Il ne faut plus les utiliser sur l'Internet,
parce qu'ils ne sont pas du tout sécurisés.
Cela dit, si vous osez utiliser NFS sur votre réseau local
pour rendre vos machines complètement accessibles les unes aux autres,
vous pouvez aussi utilisez <tt><font color="darkblue">rsh(1)</font
></tt
> et consorts.
Notez qu'il ne faut pas plus faire confiance au trafic WiFi
qu'au trafic externe.
Dans les cas où vous voulez faire confiance à l'intérieur de votre réseau,
soyez sûr d'avoir un pare-feu efficace aux frontières de votre réseau.
</p
><p align="justify">
Sécuriser une connexion:
enrober un service via SSL,
redirection sous SSH,
VPN (cas simple: tunnel PPP via <tt><font color="darkblue">ssh(1)</font
></tt
>),
IPSEC voire IPv6, etc.
Une fois prises ces précautions élémentaires,
la connexion n'est plus le maillon faible de la sécurité de votre installation
&mdash; mais ce maillon faible existe encore, quelque part, par définition!
</p
><a name="SUBSECTION_6.6"></a
><font size="+1" face="sans-serif"><b>6.6 Administration</b
></font
><p align="justify">
Un labyrinthe de fichiers de configuration, tous différents.
</p
><p align="justify">
Heureusement, solutions intégrées pour les cas courants.
SuSE: <tt><font color="darkblue">YaST2(8)</font
></tt
>.
<tt><font color="darkblue">webmin(8)</font
></tt
>.
etc.
(Sous Debian ne pas oublier <tt><font color="darkblue">dpkg-reconfigure(8)</font
></tt
>
<a name="footnoteref109"></a
><a href="#footnote109"><sup><font size="-1">[109]</font
></sup
></a
>.)
</p
><p align="justify">
Trouver un fichier de configuration:
selon votre distribution, <code><font color="darkblue">rpm -ql <i>foo</i
> | grep /etc</font
></code
>
ou <code><font color="darkblue">dpkg -L <i>foo</i
> | grep /etc</font
></code
>.
<a name="footnoteref110"></a
><a href="#footnote110"><sup><font size="-1">[110]</font
></sup
></a
>
</p
><p align="justify">
Pour bien commencer:
si vous avez une tâche qui requiert plus
que ne l'offre l'interface d'administration simplifiée,
alors commencez par chercher et lire un HOWTO adéquat
(exemple: le LDAP-HOWTO pour mettre vos utilisateurs sous LDAP),
ou sinon une FAQ.
</p
><p align="justify">
La bonne façon d'envisager les choses:
tous ces fichiers de configuration sont traditionnellement
dans un format texte, facilement manipulable
par des programmes écrits dans le langage de votre choix,
voire par des shells scripts.
D'où génération facile, traitement à base de regexp, etc.
C'est bien pourquoi perl et ses rivaux, qui manipulent si facilement du texte,
sont malgré tous leurs défauts les outils préférés des administrateurs UNIX!
Ainsi, on peut gérer semi-automatiquement une machine ou un parc de machine,
régénérant automatiquement la configuration de chaque machine
à partir de <i>templates</i
> manuellement configurées, etc.
</p
><p align="justify">
Il n'y a pas de «&nbsp;base de registre&nbsp;» comme sous Windows,
ce qui n'est pas forcément un mal, car cela permet aux programmes
d'avoir comme configuration des données plus structurées et plus riches
que celles qui sont exprimables en termes de «&nbsp;registres&nbsp;»
contenant chacun un entier, une chaîne, etc.
Cela permet aussi la sauvegarde séparée des fichiers,
leur traitement automatique
par les outils de manipulation de texte «&nbsp;habituels&nbsp;»
ou par des outils adaptés à chacun des programmes configurés, etc.
Et le seul avantage réel de la base de registre,
à savoir la sauvegarde globale, est toujours possible,
grâce au fait que tout est sous la hiérarchie <code><font color="darkblue">/etc</font
></code
>.
</p
><p align="justify">
<b>&#60;rant&#62;</b
>
Si vous développez des logiciels, SVP,
employez du texte simple pour la configuration.
Si cela ne suffit pas,
si vous avez besoin de structuration,
ou si vous cherchez une certaine uniformisation,
alors adoptez des S-expressions à la LISP (cf. isapnp).
Mais par pitié, n'utilisez pas du XML.
XML n'est qu'un métalangage,
un langage dans lequel définir des sous-langages,
au même titre que «&nbsp;fichier texte&nbsp;».
Et le peu que l'on gagne avec XML, on le perd mille fois en complexité.
Beaucoup ont essayé. Ils s'y sont cassé les dents.
S'ils ont persisté, le résultat est gros, lent, laid, horrible à utiliser.
<b>&#60;/rant&#62;</b
>
</p
><p align="justify">
Ne pas oublier que les fichiers personnels des utilisateurs (y compris <code><font color="darkblue">root</font
></code
>)
peuvent interférer avec la configuration globale de <code><font color="darkblue">/etc</font
></code
>.
Si vous avez un doute sur ce que fait un processus,
utilisez en fin de compte <tt><font color="darkblue">strace(1)</font
></tt
>.
</p
><a name="SUBSECTION_6.7"></a
><font size="+1" face="sans-serif"><b>6.7 Impression</b
></font
><p align="justify">
À la base, c'est simple, et ça peut être un plaisir:
administrer avec les outils intégrés à votre distribution (ouf!);
combiner des programmes avec des tuyaux pour produire du PostScript,
et l'envoyer en fin de compte dans <tt><font color="darkblue">lpr(1)</font
></tt
>
(avec <code><font color="darkblue">lpr -P<i>nom_de_l_imprimante</i
></font
></code
>
si on veut choisir une autre imprimante que celle par défaut,
que l'on peut personnaliser avec la variable d'environnement <code><font color="darkblue">PRINTER</font
></code
>).
Cool!
</p
><p align="justify">
Mais dès qu'on veut faire plus, c'est galère:
configurer avec CUPS vs LPRng vs BSD lpd;
interfacer avec Windows ou MacOS avec <tt><font color="darkblue">samba(7)</font
></tt
>, <code><font color="darkblue">netatalk</font
></code
>;
configurer un imprimante non PostScript,
voir une imprimante multifonction(!);
installer de nouvelles polices de caractères...
</p
><p align="justify">
Ah, les polices! L'horreur! Mais ça s'améliore au fil du temps.
Par contre, les problèmes de copyrights sur les polices...
</p
><p align="justify">
Pas d'API unifiée pour l'impression: chaque programme fait son manège.
Le seul standard, c'est de produire PostScript.
Essentiels: les utilitaires à tout faire comme
<tt><font color="darkblue">a2ps(1)</font
></tt
>, <tt><font color="darkblue">mpage(1)</font
></tt
>, <tt><font color="darkblue">psutils</font
></tt
>, etc.
GNOME, KDE, Java, proposent chacun leur propre API pour l'impression.
Beaucoup utilisent <code><font color="darkblue">(La)TeX</font
></code
>
comme backend pour produire du PostScript à partir de texte.
Sinon, voir comment font vos programmes favoris:
<a href="http://www.texmacs.org">TeXmacs</a
>,
<tt><font color="darkblue">a2ps(1)</font
></tt
>, <code><font color="darkblue">cl-typesetting</font
></code
>, etc.
</p
><a name="SUBSECTION_6.8"></a
><font size="+1" face="sans-serif"><b>6.8 Compiler un programme</b
></font
><p align="justify">
Savoir lire les <code><font color="darkblue">README</font
></code
>s et autres <code><font color="darkblue">INSTALL</font
></code
>.
</p
><p align="justify">
Dans les cas un peu plus compliqués,
il faudra comprendre un peu <tt><font color="darkblue">make(1)</font
></tt
>
et le fonctionnement d'un <code><font color="darkblue">Makefile</font
></code
>.
La connaissance de rudiments du shell pourra être utile.
</p
><p align="justify">
Bien gérer son <code><font color="darkblue">/usr/local</font
></code
> avec des liens symboliques:
utiliser <tt><font color="darkblue">stow(8)</font
></tt
> et similaires (et pour nettoyer, <tt><font color="darkblue">symlinks(1)</font
></tt
>).
</p
><a name="SUBSECTION_6.9"></a
><font size="+1" face="sans-serif"><b>6.9 Le noyau et ses modules</b
></font
><p align="justify">
Chercher d'abord une mise à jour sur sa distribution.
Ou de la documentation en relation avec votre distribution.
Consulter les HOWTO.
</p
><p align="justify">
Malheureusement,
certaines fonctionnalités nécessitent une recompilation à la main.
Toutefois, même là, il y aura des paquets de votre distribution
pour vous faciliter la tâche.
</p
><p align="justify">
Après avoir compilé votre noyau,
attention à bien mettre à jour LILO ou GRUB.
LILO plus «&nbsp;bas niveau&nbsp;» et statique que GRUB:
le relancer quand les fichiers cibles ont changé.
GRUB: à relancer seulement si GRUB a changé.
Avec liens symboliques, pas besoin de changer
le <code><font color="darkblue">/etc/lilo.conf</font
></code
> ou le <code><font color="darkblue">/boot/grub/menu.lst</font
></code
>.
Notez que sous SuSE, par exemple,
il faut aussi régénérer le ramdisk d'initialisation des modules avec
<tt><font color="darkblue">mkinitrd(8)</font
></tt
>.
</p
><p align="justify">
Précaution essentielle:
<em>Toujours garder une ancienne version dont on est sûr qu'elle marche!!!</em
>
Cela comprend le noyau, ses modules, fichiers de configuration,
et s'il le faut, entêtes, sources, patches, etc.
Votre distribution peut vous aider à empaqueter tout ça.
</p
><a name="SECTION_7"></a
><table width="100%"><tr><td valign="top" bgcolor="#FFC189"><font size="+1" face="sans-serif"><b>7 Quelques Exercices</b
></font
></td
></tr
></table
><p align="justify">
Voici quelques exercices à faire chez vous ou en cours.
Notez que le jour de l'examen,
il vous sera demandé de faire des exercices similaires.
</p
><a name="SUBSECTION_7.1"></a
><font size="+1" face="sans-serif"><b>7.1 Exercice permanent</b
></font
><p align="justify">
Ces notes de cours sont incomplètes: aidez à les compléter.
</p
><p align="justify">
Il manque des URL vers certains
concepts, programmes, documents et autres sites mentionnés.
Trouvez ces sites grâce à Google.
</p
><p align="justify">
Certains paragraphes nécessitent éclaircissements.
Notez quels paragraphes, et pour des points supplémentaires,
suggérez des éclaircissements après avoir lu la documentation
ou consulté Google.
</p
><p align="justify">
Certains paragraphes seraient bien illustrés avec des exemples.
Fournissez de tels exemples.
</p
><p align="justify">
Sauvez toutes vos suggestions dans un fichier texte,
et envoyez-les moi à la fin du cours à l'adresse:
<code><font color="darkblue">fare&#64;tunes.org</font
></code
>.
</p
><a name="SUBSECTION_7.2"></a
><font size="+1" face="sans-serif"><b>7.2 Exercice d'administration de base</b
></font
><p align="justify">
Créer un utilisateur <em>à votre nom</em
>
sur votre machine avec l'interface graphique ou <tt><font color="darkblue">useradd(8)</font
></tt
>.
Dupliquer <em>depuis <code><font color="darkblue">root</font
></code
></em
>
les fichiers de l'utilisateur <code><font color="darkblue">cepl1</font
></code
> du serveur
avec <code><font color="darkblue">cp -a</font
></code
>.
Note 1: si vous n'êtes pas <code><font color="darkblue">root</font
></code
>,
vous ne pourrez pas lire certains fichiers protégés.
Note 2: le répertoire où la configuration par défaut se trouve est
<code><font color="darkblue">/etc/skel</font
></code
>.
Utiliser un <tt><font color="darkblue">chown(1)</font
></tt
>
pour changer le possesseur de la nouvelle arborescence
et <tt><font color="darkblue">passwd(1)</font
></tt
> pour changer le mot de passe.
(Solution <a name="footnoteref111"></a
><a href="#footnote111"><sup><font size="-1">[111]</font
></sup
></a
>)</p
><p align="justify">
S'il n'existe pas encore, créer le groupe <code><font color="darkblue">cepl</font
></code
>.
Mettre votre utilisateur et les autres du genre cepl
dans le groupe <code><font color="darkblue">cepl</font
></code
>.
S'il n'y a pas d'utilisateur <code><font color="darkblue">cepl1</font
></code
>,
en créer un dans le groupe <code><font color="darkblue">cepl</font
></code
>.
(Indice <a name="footnoteref112"></a
><a href="#footnote112"><sup><font size="-1">[112]</font
></sup
></a
>)(Solution <a name="footnoteref113"></a
><a href="#footnote113"><sup><font size="-1">[113]</font
></sup
></a
>)</p
><p align="justify">
Installez de nouveaux paquets logiciels
depuis les sources déjà configurées sur votre machine
<a name="footnoteref114"></a
><a href="#footnote114"><sup><font size="-1">[114]</font
></sup
></a
>.
Ainsi par exemple, les paquets suivants vous seront utiles
pour la suite du cours:
<code><font color="darkblue">a2ps xv ImageMagick</font
></code
> 
<a name="footnoteref115"></a
><a href="#footnote115"><sup><font size="-1">[115]</font
></sup
></a
>.
</p
><a name="SUBSECTION_7.3"></a
><font size="+1" face="sans-serif"><b>7.3 Exercice de configuration graphique</b
></font
><p align="justify">
Aller dans le <i>control center</i
> de KDE, <code><font color="darkblue">kcontrol</font
></code
>.
</p
><p align="justify">
Activer ou désactiver l'<em>économiseur d'écran</em
> (anglais: <em>screensaver</em
>).
</p
><p align="justify">
Créer des bureaux virtuels.
</p
><p align="justify">
Faire mumuse avec les fontes.
</p
><p align="justify">
Activer le double clic au lieu du simple clic.
</p
><p align="justify">
S'amuser à découvrir les multiples tableaux de bords.
</p
><p align="justify">
À noter si vous déréglez la chose et voulez restaurer son état initial
que la <em>disposition</em
> (anglais: <em>layout</em
>) du clavier au Luxembourg
est celle du clavier Suisse français.
</p
><a name="SUBSECTION_7.4"></a
><font size="+1" face="sans-serif"><b>7.4 Copie d'écran</b
></font
><p align="justify">
Un outil graphique fort utile malgré son âge est <tt><font color="darkblue">xv(1)</font
></tt
>
<a name="footnoteref116"></a
><a href="#footnote116"><sup><font size="-1">[116]</font
></sup
></a
>.
Avec <tt><font color="darkblue">xv(1)</font
></tt
>, vous pouvez capturez des fenêtres avec le bouton grab
du menu disponible en cliquant sur la fenêtre avec le bouton droit.
Configurez les cases <em>délai</em
> (anglais: <em>Delay</em
>)
et <em>cacher les fenêtres de xv</em
> (anglais: <em>Hide xv windows</em
>)
et utilisez Grab ou AutoGrab selon que vous préférez
cliquer sur la fenêtre à capturer ou le laisser capturer la fenêtre
sur laquelle se trouvera la souris passé le delai.
Pointez sur le fond d'écran (s'il en reste)
pour obtenir une capture de l'ensemble de l'écran.
Une fois une fenêtre capturée, vous pouvez transformer l'image
et enfin utiliser le bouton de <em>sauvegarde</em
> (anglais: <em>Save</em
>) du menu
pour sauver l'image au format de votre choix.
</p
><p align="justify">
Un paquet logiciel contenant de nombreux outils graphiques est
<a href="http://www.imagemagick.org">ImageMagick</a
>.
Il comporte notamment un outil <tt><font color="darkblue">convert(1)</font
></tt
>
pour convertir les fichiers d'un format à un autre,
un outil <tt><font color="darkblue">display(1)</font
></tt
> pour afficher des images,
un outil <tt><font color="darkblue">import(1)</font
></tt
> pour les importer <a name="footnoteref117"></a
><a href="#footnote117"><sup><font size="-1">[117]</font
></sup
></a
>, et d'autres outils encore (voir <tt><font color="darkblue">ImageMagick(1)</font
></tt
>).
Vous pouvez ainsi faire une copie de tout l'écran avec
<code><font color="darkblue">import -window root toto.png</font
></code
>
que vous pouvez par exemple précéder d'un appel à <tt><font color="darkblue">sleep(1)</font
></tt
>
pour avoir le temps de mettre l'écran dans l'état souhaité:
<code><font color="darkblue">sleep 3;
import ...</font
></code
>
</p
><a name="SUBSECTION_7.5"></a
><font size="+1" face="sans-serif"><b>7.5 Burn All GIFs!</b
></font
><p align="justify">
Le but de ces exercices est d'apprendre à maîtriser
la programmation de shell scripts simples à base
de combinaison de petits utilitaires utilisant des expressions régulières.
</p
><p align="justify">
Ces manipulations seront illustrées sur un cas réel,
celui du <a href="http://burnallgifs.org">Burn All GIFs</a
>:
UNISYS, détenteur d'un brevet sur la technique de compression LZW,
telle qu'utilisée notamment par le format de fichier graphique GIF,
a décidé il y a quelques années de menacer de poursuites judiciaires
ceux qui créeraient les fichiers GIFs
et les publieraient sur leurs pages ouèbes
sans avoir acquis une licence à $5000.
En protestation, des activistes du logiciel libre ont organisé
le <a href="http://burnallgifs.org">Burn All GIFs day</a
>
(littéralement, «&nbsp;jour pour brûler tous les GIFs&nbsp;»)
durant lequel les participants furent conviés à remplacer tous leurs
fichiers GIFs par des fichiers équivalents au format PNG,
qui produit des fichiers de meilleure qualité et de taille plus petite.
<a name="footnoteref118"></a
><a href="#footnote118"><sup><font size="-1">[118]</font
></sup
></a
>
<a name="footnoteref119"></a
><a href="#footnote119"><sup><font size="-1">[119]</font
></sup
></a
>
</p
><p align="justify">
Nous allons vous proposer d'écrire un shell script de dix lignes
qui vous permettra d'économiser $5000 si jamais UNISYS
décide de vous envoyer une lettre comminatoire.
Le script comportera deux parties:
d'abord, trouver tous les fichiers GIF et les convertir en PNG;
ensuite, trouver tous les fichiers HTML,
et remplacer chaque référence à un fichier GIF
en une référence au fichier PNG correspondant.
</p
><p align="justify">
En préliminaire, vous récupérerez un petit site ouèbe sur lequel travailler.
Je vous propose de reprendre le
<a href="http://etna.int-evry.fr/COURS/UNIX/">Cours UNIX de l'INT EVRY</a
>.

J'ai mis ce cours sur le serveur <code><font color="darkblue">ltc-141-00</font
></code
>
dans le répertoire <code><font color="darkblue">/home/cepl1/tutoriel</font
></code
>,
et j'ai exporté le répertoire <code><font color="darkblue">/home</font
></code
> par NFS.
Récupérez le répertoire chez vous.
(Indice <a name="footnoteref120"></a
><a href="#footnote120"><sup><font size="-1">[120]</font
></sup
></a
>)(Solution <a name="footnoteref121"></a
><a href="#footnote121"><sup><font size="-1">[121]</font
></sup
></a
>)

Si vous êtes chez vous, vous pouvez vous aussi télécharger ce cours,
grâce à l'outil <tt><font color="darkblue">wget(1)</font
></tt
>.
(Solution <a name="footnoteref122"></a
><a href="#footnote122"><sup><font size="-1">[122]</font
></sup
></a
>)
</p
><p align="justify">

Votre première étape est donc de localiser tous les fichiers GIFs
dans l'arborescence du site ouèbe.
Pour simplifier, on supposera que la convention est respectée
selon laquelle leur nom se termine en <code><font color="darkblue">.gif</font
></code
>,
et que ce nom ne comporte pas d'espace ou de caractère spécial pour le shell.
(Indice <a name="footnoteref123"></a
><a href="#footnote123"><sup><font size="-1">[123]</font
></sup
></a
>)(Solution <a name="footnoteref124"></a
><a href="#footnote124"><sup><font size="-1">[124]</font
></sup
></a
>)
</p
><p align="justify">

Votre deuxième étape est d'itérer sur cette liste de fichiers,
c'est­à-dire de savoir effectuer une même opération
successivement sur chacun de ces fichiers.
L'opération pour le fichier <code><font color="darkblue"><i>FOO</i
></font
></code
> sera simplement d'afficher
<code><font color="darkblue">Nous traiterons le fichier <i>FOO</i
></font
></code
>.
(Indice <a name="footnoteref125"></a
><a href="#footnote125"><sup><font size="-1">[125]</font
></sup
></a
>)(Solution <a name="footnoteref126"></a
><a href="#footnote126"><sup><font size="-1">[126]</font
></sup
></a
>)
</p
><p align="justify">
La troisième étape sera d'arriver à obtenir automatiquement
un nom de fichier se terminant par <code><font color="darkblue">.png</font
></code
>
pour chaque fichier GIF dont le nom se terminait par <code><font color="darkblue">.gif</font
></code
>.
</p
><p align="justify">

D'abord, ce qui marchera même sous le shell antique d'un UNIX propriétaire,
vous utiliserez l'outil <tt><font color="darkblue">sed(1)</font
></tt
>, de la façon suivante:
<code><font color="darkblue">sed -e
's/expression régulière à remplacer/expression de remplacement/g'</font
></code
>
<a name="footnoteref127"></a
><a href="#footnote127"><sup><font size="-1">[127]</font
></sup
></a
>
pour transformer le nom de fichier GIF
(mis sur la sortie standard de <tt><font color="darkblue">sed(1)</font
></tt
>)
en nom de fichier PNG.
Ensuite, pour récupérer ce nom dans une commande du shell,
vous devrez utiliser les backquotes <code><font color="darkblue">`...`</font
></code
>.
(Solution <a name="footnoteref128"></a
><a href="#footnote128"><sup><font size="-1">[128]</font
></sup
></a
>)
</p
><p align="justify">
En fait, avec un shell non antique, on peut aussi écrire
	<code><font color="darkblue">${file%.gif}</font
></code
>
pour enlever la désinence <code><font color="darkblue">.gif</font
></code
>
du nom de fichier contenu dans la variable <code><font color="darkblue">file</font
></code
>.
Voir le manuel de votre shell pour les détails.
On peut ainsi écrire directement <code><font color="darkblue">newfile=${file%.gif}.png</font
></code
>.
<a name="footnoteref129"></a
><a href="#footnote129"><sup><font size="-1">[129]</font
></sup
></a
>
</p
><p align="justify">

Notez que pour les shells antiques,
il existe aussi des utilitaires <tt><font color="darkblue">basename(1)</font
></tt
> et <tt><font color="darkblue">dirname(1)</font
></tt
>
permettant d'extraire chemin et nom de base d'un fichier.
Exercice pour ceux qui veulent devenir des pros du shell:
réimplémenter les fonctionnalités de ces utilitaires
avec l'expansion de variable des shells modernes.
(Solution <a name="footnoteref130"></a
><a href="#footnote130"><sup><font size="-1">[130]</font
></sup
></a
>)
</p
><p align="justify">
Pour tester votre troisième étape,
essayez sans boucle de définir la variable <code><font color="darkblue">file</font
></code
> avec
<code><font color="darkblue">file=toto.gif</font
></code
> et d'appliquer votre recette
au contenu de la variable <code><font color="darkblue">file</font
></code
>.
Puis, vérifiez que vous savez bien combiner cette étape avec la précédente
en appliquant votre recette à tous les fichiers GIF trouvés.
</p
><p align="justify">
La quatrième étape sera de convertir le fichier GIF en fichier PNG,
en utilisant l'utilitaire <tt><font color="darkblue">convert(1)</font
></tt
> du paquet <code><font color="darkblue">ImageMagick</font
></code
>.
</p
><p align="justify">
La cinquième étape, optionnelle, sera de détruire le fichier GIF originel
après l'avoir converti en PNG.
(L'opération conservant a priori toute l'information,
il n'y a pas de danger particulier,
en dehors de la nécessité valable en tout temps
d'une sauvegarde régulière de vos données.)
Pour plus de sécurité, utiliser l'exécution conditionnelle du shell
pour que l'opération ne soit effectuée que si l'opération précédente
a été réalisée avec succès <a name="footnoteref131"></a
><a href="#footnote131"><sup><font size="-1">[131]</font
></sup
></a
>.
</p
><p align="justify">
Dans une deuxième partie,
commencez par vérifier que vous savez itérer sur les fichiers HTML,
de même que vous saviez itérer sur les GIF.
</p
><p align="justify">

L'opération à effectuer sur chaque fichier sera de remplacer
dans le texte toutes les occurrences de <code><font color="darkblue">.gif</font
></code
> en <code><font color="darkblue">.png</font
></code
>
<a name="footnoteref132"></a
><a href="#footnote132"><sup><font size="-1">[132]</font
></sup
></a
>.
(Indice <a name="footnoteref133"></a
><a href="#footnote133"><sup><font size="-1">[133]</font
></sup
></a
>)(Solution <a name="footnoteref134"></a
><a href="#footnote134"><sup><font size="-1">[134]</font
></sup
></a
>)
</p
><p align="justify">
Une fois que vous avez une commande qui marche,
il suffit de faire une redirection <code><font color="darkblue">&#60; $file &#62; $file.new</font
></code
>
puis, <em>si la commande n'a pas échoué</em
>,
remplacez l'ancien fichier par le nouveau avec <code><font color="darkblue">mv $file.new $file</font
></code
>
<a name="footnoteref135"></a
><a href="#footnote135"><sup><font size="-1">[135]</font
></sup
></a
>.
</p
><p align="justify">
Maintenant que vous savez tout faire, mettez-moi ça dans un script,
c'est-à-dire un fichier exécutable commençant
par <code><font color="darkblue">#!/bin/<i>interpréteur_de_commande</i
></font
></code
>.
Pour éviter d'aller trifouiller et faire de la recherche-remplacement
dans tout le système bien au-delà des fichiers visés
<a name="footnoteref136"></a
><a href="#footnote136"><sup><font size="-1">[136]</font
></sup
></a
>,
il est important de changer de répertoire au début du script,
et de quitter le script avec une erreur
si le changement de répertoire ne s'est pas effectué correctement.
</p
><p align="justify">
Notez que pour qu'un programme puisse être exécuté
sans donner son nom complet mais seulement son nom de fichier de base,
il doit être dans votre <code><font color="darkblue">PATH</font
></code
>.
Les personnes qui écrivent des scripts les rajoutent traditionnellement
dans leur <code><font color="darkblue">$HOME/bin</font
></code
> qu'ils rajoutent dans leur <code><font color="darkblue">PATH</font
></code
>
avec une ligne du genre <code><font color="darkblue">PATH="$HOME/bin:$PATH"</font
></code
>
dans leur <code><font color="darkblue">.profile</font
></code
> ou <code><font color="darkblue">.bashrc</font
></code
> ou équivalent pour leur shell.

Exercice: sauver le script de cette exercice dans votre <code><font color="darkblue">$HOME/bin</font
></code
>
et le mettre dans votre <code><font color="darkblue">PATH</font
></code
>.
(Solution <a name="footnoteref137"></a
><a href="#footnote137"><sup><font size="-1">[137]</font
></sup
></a
>)
</p
><p align="justify">
Enfin, vous pouvez tester le script obtenu dans diverses situations
<a name="footnoteref138"></a
><a href="#footnote138"><sup><font size="-1">[138]</font
></sup
></a
>.
</p
><p align="justify">
Bravo! vous venez d'écrire une dizaine de lignes de code
qui peuvent vous économiser $5000.
Maintenant, l'univers Linux est à vous,
car vous pouvez l'affronter sans crainte.
Apprenez par l'exemple, en lisant les scripts et programmes des autres,
et en partant vaillamment à la recherche de documentation,
tutoriels, manuels, HOWTOs, FAQs, etc.
La communauté des utilisateurs est là pour vous aider.
</p
><a name="SUBSECTION_7.6"></a
><font size="+1" face="sans-serif"><b>7.6 Pour les plus avancés...</b
></font
><p align="justify">
Outre le fait de compulser divers sites,
je vous invite à inspecter le système.
</p
><p align="justify">

Par exemple, repérez les exécutables dans votre <code><font color="darkblue">$PATH</font
></code
>,
et avec <tt><font color="darkblue">file(1)</font
></tt
>, identifiez parmi eux les scripts;
lisez ces scripts en commençant par le plus court,
et comprenez de quoi il s'agit.
(Solution <a name="footnoteref139"></a
><a href="#footnote139"><sup><font size="-1">[139]</font
></sup
></a
>)
</p
><p align="justify">
Apprendre à compiler et installer un programme
qui n'est pas déjà sur le système:
Télécharger décomprimer les sources dans <code><font color="darkblue">~/src</font
></code
> (ou ailleurs).
Lire le fichier
<code><font color="darkblue">INSTALL</font
></code
>, <code><font color="darkblue">README</font
></code
>, <code><font color="darkblue">LISEZMOI</font
></code
>, <code><font color="darkblue">00INSTALL</font
></code
>,
etc.
Suivre les instructions.
En l'absence d'instructions, essayer
<code><font color="darkblue">./configure ; make ; make install</font
></code
>.
</p
><p align="justify">
Utilisation de <tt><font color="darkblue">make(1)</font
></tt
>.
</p
><p align="justify">
Inspection de ce que font divers processus simples
avec <tt><font color="darkblue">strace(1)</font
></tt
>, <tt><font color="darkblue">lsof(8)</font
></tt
>, etc.
</p
><hr
/><h4>Notes</h4
><p align="justify"><a name="footnote1"></a
><a href="#footnoteref1">[1]</a
>: 
Si vous voulez avoir une vue à la fois simple et puissante
de ce en quoi consiste effectivement une machine de Von Neuman,
sans vous encombrer des détails inutiles,
mais en en suçant la substantifique moëlle
et en atteignant facilement des sommets,
je vous invite à apprendre le langage FORTH,
par exemple avec le petit livre <i>Thinking FORTH</i
> de Leo Brodie.
Si vous êtes fasciné par les détails des machines réelles,
que le progrès rapide des technologies rend aussi éphémères qu'abscons,
il sera toujours temps d'apprendre le langage d'assemblage de quelque machine.
Pour commencer, je vous déconseille fortement l'assembleur des ordinateurs PC
à base d'Intel IA-32 (x86);
préférez-y l'élégant assembleur des ARM, processeurs répandus
dans les matériels embarqués et PDA,
dont certains comme les Zaurus tournent sous Linux;
à défaut, choisissez le PowerPC des Macintosh.
</p
><p align="justify"><a name="footnote2"></a
><a href="#footnoteref2">[2]</a
>: 
Les informaticiens, qui comptent en base 2,
préfèrent compter avec les puissances dixièmes, vingtièmes et trentièmes de 2,
qui valent respectivement 1.024, 1.048.576 et 1.073.741.824.
</p
><p align="justify">
Autrefois, et parfois encore maintenant par approximation,
on employait et on emploie improprement les termes
kilooctets, mégaoctets, gigaoctets, etc.,
pour faire référence à ces quantités.
En fait, les préfixes
kilo-, Méga-, Giga-, etc., sont normalisés
comme représentant un facteur multiplicatif par une des puissances de 1.000.
Ainsi, un <em>kilooctets</em
> (anglais: <em>kilobyte</em
>),
noté ko (kB) ou souvent improprement Ko (KB), vaut 1.000 octets;
un <em>mégaoctets</em
> (anglais: <em>megabyte</em
>) noté Mo (MB) vaut 1.000.000 octets;
un <em>gigaoctets</em
> (anglais: <em>gigabyte</em
>) noté Go (GB) vaut 1.000.000.000 octets, etc.
</p
><p align="justify">
Pendant longtemps, les informaticiens utilisaient les mêmes préfixes
kilo, méga, giga, etc. en parlant de puissances de 1.024 ou de 1.000,
la chose étant claire selon le contexte.
C'est notamment toujours le cas quand ils parlent de tailles de mémoire vive.
Ce fut aussi longtemps le cas en parlant de taille de disques durs;
mais pour pouvoir gonfler leurs chiffres marketing de 7.3%,
les fabricants de disques durs se sont mis à utiliser
1 Go = 1.000.000.000 octets plutôt que 1 Go = 1.073.741.824 octets
comme les informaticiens s'y seraient attendus
(d'autant que traditionnellement, il était bien ancré
que dans l'usage courant 1 ko = 1.024 octets et 1 Mo = 1.048.576 octets,
même pour les disques durs).
</p
><p align="justify">
Pour éviter plus de confusion, et parce qu'il est effectivement
impropre de détourner kilo-, Méga-, Giga-, etc., de leur sens normalisé,
de nouveaux préfixes ont été inventés et normalisés
pour les variations binaires des préfixes précédents:
Kibi-, Mébi-, Gibi- et ainsi de suite
(remplaçant la deuxième syllabe par le bi de binaire),
qui désignent les multiplicateurs par puissance de 2^10 plutôt que de 10^3,
et qui s'écrivent dans les calculs en introduisant un -i- après le du préfixe
de la puissance de 10^3 correspondante.
Ainsi, les préfixes Ki-, Mi-, Gi-, Ti-, Pi-, etc.,
sont ainsi utilisés
pour 2^10, 2^20, 2^30, 2^40, 2^50, etc.,
par analogie et par contraste avec k-, M-, G-, T-, P-, E-, Z-, Y-, etc.,
qui sont dorénavant bien réservés
pour 10^3, 10^6, 10^9, 10^12, 10^15, etc.
(Notez que les informaticiens ont capitalisé le K de Ki
pour régulariser la majuscule qui était impropre dans le très courant KB).
Le noyau Linux utilise notamment ces préfixes,
de même que de nombreux logiciels libres,
et si possible tous les logiciels futurs, libres ou pas.
Toutefois, les logiciels et documents plus anciens
parlent encore à l'ancienne manière.
</p
><p align="justify">
Pour en savoir plus, voir:
<tt><font color="darkblue">units(7)</font
></tt
>, et les pages du
<a href="http://physics.nist.gov/cuu/Units/binary.html">NIST</a
>,
de l'<a href="http://www.iec.ch/zone/si/si_bytes.htm">IEC</a
>,
ou de <a href="http://en.wikipedia.org/wiki/Binary_prefixes">Wikipedia</a
>.
</p
><p align="justify"><a name="footnote3"></a
><a href="#footnoteref3">[3]</a
>: 
Dans les années 1960, le nom originel
du fait de pouvoir faire tourner plusieurs programmes à la fois
était <em>multiprogrammation</em
> (anglais: <em>multiprogramming</em
>).
Le mot multitâche s'est imposé avec la tradition Unix.
</p
><p align="justify"><a name="footnote4"></a
><a href="#footnoteref4">[4]</a
>: 
Certains systèmes ou surcouches logicielles gèrent
plus ou moins automatiquement
la <em>persistence</em
> (anglais: <em>persistence</em
>) des données;
on parle alors de <em>persistence orthogonale</em
> (anglais: <em>orthogonal persistence</em
>),
par opposition à une persistence explicite.
Mais comme une telle automatisation n'est pas généralisée,
même dans des systèmes «&nbsp;modernes&nbsp;» comme Linux, Windows XP ou Mac OS X,
il faut savoir utiliser la persistence explicite,
et comprendre son fonctionnement.
</p
><p align="justify"><a name="footnote5"></a
><a href="#footnoteref5">[5]</a
>: 
Le petit nombre entre parenthèses fait référence à la section du manuel
où on trouvera la documentation relative à la commande donnée.
Pour le manuel et la liste de ses sections, voir la commande <tt><font color="darkblue">man(1)</font
></tt
>:
<code><font color="darkblue">man 1 man</font
></code
>
(dans ce cas <code><font color="darkblue">man man</font
></code
> suffit,
cependant que pour accéder à la documentation
du format de fichiers de <tt><font color="darkblue">man(7)</font
></tt
>,
il faut faire <code><font color="darkblue">man 7 man</font
></code
>).
La commande <tt><font color="darkblue">whatis(1)</font
></tt
> donnera la liste des pages de manuel de même nom
dans des sections différentes.
</p
><p align="justify"><a name="footnote6"></a
><a href="#footnoteref6">[6]</a
>: 
Certains ordinateurs, des <em>multiprocesseurs</em
> (anglais: <em>multiprocessors</em
>)
contiennent plusieurs processeurs en même temps
qui partagent la même mémoire.
Dans de tels cas, le noyau se charge
de partager ces ressources supplémentaires entre les processus actifs.
Les programmes sont toujours écrits essentiellement
comme pour un seul processeur;
le noyau maintient la même illusion d'une
machine virtuelle isolée pour chaque processus,
quel que soit le nombre de processeurs disponibles.
</p
><p align="justify"><a name="footnote7"></a
><a href="#footnoteref7">[7]</a
>: 
Les appels systèmes sont spécifiés pour leur utilisation depuis le langage C.
Mais en fait, ont peut les utiliser quasi à l'identique voire en mieux
depuis à peu près n'importe quel langage.
Préférer Perl, Python, Ruby, Ocaml, Common Lisp, etc.
</p
><p align="justify"><a name="footnote8"></a
><a href="#footnoteref8">[8]</a
>: 
Le manuel de l'utilisateur est disponible avec la commande <tt><font color="darkblue">man(1)</font
></tt
>,
ou un navigateur graphique comme <code><font color="darkblue">khelpcenter</font
></code
>.
Il est aussi disponible en-ligne sur le ouèbe,
et il y a même des versions papier chez divers éditeurs.
</p
><p align="justify"><a name="footnote9"></a
><a href="#footnoteref9">[9]</a
>: 
Ainsi, si vous vous demandez «&nbsp;mais qu'est-ce que fait ce programme?&nbsp;»,
ou «&nbsp;mais comment ça marche?&nbsp;», utilisez
<code><font color="darkblue">strace -o strace.log <i>programme arguments...</i
></font
></code
>
puis (ou dans une autre fenêtre) inspectez le fichier <code><font color="darkblue">strace.log</font
></code
>.
C'est <em>très</em
> instructif sur le fonctionnement du noyau Linux.
</p
><p align="justify"><a name="footnote10"></a
><a href="#footnoteref10">[10]</a
>: 
Sous Linux, un <em>utilisateur</em
> (anglais: <em>user</em
>)
est identifié par son <em>numéro d'utilisateur</em
> (anglais: <em>UID</em
>),
un nombre entier positif plus petit que 4.294.967.295
(ou 65.535 sur les anciens systèmes).
Chaque utilisateur n'a que les droits
que l'administrateur système lui a accordé;
il ne peut typiquement contrôler complètement que les fichiers qu'il a créé,
n'ayant qu'un contrôle limité sur le reste du système.
La correspondance entre numéro d'utilisateur 
et nom de login et autres propriétés
n'est pas gérée par le noyau mais par la librairie standard
via ses appels d'API <tt><font color="darkblue">getpwent(3)</font
></tt
> et similaires.
Par défaut, cette correspondance se fait via le fichier <code><font color="darkblue">/etc/passwd</font
></code
>,
mais on peut la configurer autrement (LDAP, etc.) via le fichier
de configuration <code><font color="darkblue">/etc/nsswitch.conf</font
></code
>.
La description des fichiers de configuration sont dans la section 5 du manuel:
<code><font color="darkblue">man 5 passwd</font
></code
> ou <code><font color="darkblue">man 5 nsswitch.conf</font
></code
>.
</p
><p align="justify"><a name="footnote11"></a
><a href="#footnoteref11">[11]</a
>: 
D'où le nom de la commande standard <tt><font color="darkblue">su(1)</font
></tt
>
pour devenir super-utilisateur.
Dans le genre mais plus élaboré, voir aussi <tt><font color="darkblue">sudo(8)</font
></tt
>
et toute une floppée d'outils similaires.
</p
><p align="justify"><a name="footnote12"></a
><a href="#footnoteref12">[12]</a
>: 
Le pid est accessible avec l'appel système <tt><font color="darkblue">getpid(2)</font
></tt
>,
ou dans un shell avec la variable <code><font color="darkblue">$$</font
></code
>.
</p
><p align="justify"><a name="footnote13"></a
><a href="#footnoteref13">[13]</a
>: 
La mémoire est divisée en <em>pages</em
> (anglais: <em>pages</em
>)
(de 4 KiB sur les PC x86, souvent autant ou plus sur d'autres machines),
qui sont chacune <em>mappée</em
> (anglais: <em>mapped</em
>)
sur une partie d'un objet géré par le noyau.
Une partie de cette mémoire sera mappée en lecture seule
vers le <em>fichier exécutable</em
> (anglais: <em>executable file</em
>)
du programme lancé
et vers les <em>bibliothèques partagées</em
> (anglais: <em>shared libraries</em
>)
qu'il utilise.
Une autre sera mappée sur la mémoire privée du processus.
Le programme peut aussi mapper des segments de mémoire partagée
entre plusieurs processus, ou des fichiers de travail.
On peut examiner les zones de mémoires mappées par un processus avec
<code><font color="darkblue">cat /proc/$PID/maps</font
></code
> &mdash; essayez, c'est instructif.
Notez que <code><font color="darkblue">/proc/self/</font
></code
> correspond au processus
qui fait l'appel système
(qui n'est pas forcément le shell d'où une commande est lancée).
</p
><p align="justify">
On peut examiner l'état du calcul d'un processus grâce à l'appel système
<tt><font color="darkblue">ptrace(2)</font
></tt
>. Cet appel est notamment utilisé par des programmes comme
<tt><font color="darkblue">gdb(1)</font
></tt
> qui sert à déboguer une applications en cours d'exécution,
ou <tt><font color="darkblue">strace(1)</font
></tt
> qui sert à observer
les interactions d'un processus avec le reste du système.
</p
><p align="justify"><a name="footnote14"></a
><a href="#footnoteref14">[14]</a
>: 
Cet état peut être typiquement
<em>actif</em
> (anglais: <em>running</em
>), <em>endormi</em
> (anglais: <em>sleeping</em
>),
terminé (et avec un code résultat;
il sera détruit qu'après que le processus père lise ce code),
ou en attente de réponse du système,
voire <em>zombi</em
> (anglais: <em>zombie</em
>) si le processus
est presque mort mais pas tout à fait
(typiquement, il lui est arrivé malheur au beau milieu d'un appel système).
</p
><p align="justify">
On peut changer l'état du processus en lui envoyant
un <em>signal</em
> (anglais: <em>signal</em
>) avec la commande <tt><font color="darkblue">kill(1)</font
></tt
>.
Pour une liste des signaux, voir <tt><font color="darkblue">signal(7)</font
></tt
>.
Certains signaux peuvent aussi être interceptés par les processus,
et l'on peut parfois faire des choses avancées avec
(jouer avec la mémoire virtuelle protégée),
mais alors c'est une horreur à programmer,
et il y a parfois des bugs bizarres du noyau ou des bibliothèques standard,
notamment avec des signaux qui sont perdus
s'ils sont envoyés pendant qu'un signal précédent était en cours de traitement,
ce qui arrive souvent si le système est trop chargé, etc.
Bref, la façon dont fonctionne les signaux n'est pas toujours fiable
quand il s'agit de faire de la programmation avancée,
surtout si vous n'avez pas le bon processeur avec le bon noyau,
les bonnes bibliothèques, le bon programme.
Pour les utilisations simples, ils fonctionnent bien,
pour le reste, il faut être prêt à affronter les bugs du système.
</p
><p align="justify"><a name="footnote15"></a
><a href="#footnoteref15">[15]</a
>: 
Le noyau ne voit que des numéros d'uid et de gid,
qui sont donnés par l'administrateur
au moment où l'utilisateur se logue
(ou au moment où un démon est lancé),
d'après les tables du système à ce moment là
(fichiers <tt><font color="darkblue">passwd(5)</font
></tt
> et <tt><font color="darkblue">group(5)</font
></tt
>, etc.).
Si l'administrateur modifie le numéro d'un utilisateur
ou les noms ou les numéros des groupes associés,
les processus existant ne seront pas modifiés,
et il faudra que l'utilisateur se délogue et se relogue
(ou que les démons utilisant cette identité soient relancés),
pour que les processus correspondant voient les changements.
Voilà le genre de phénomènes qui ne s'explique bien
que si on comprend le modèle de base de fonctionnement du système.
</p
><p align="justify"><a name="footnote16"></a
><a href="#footnoteref16">[16]</a
>: 
Pour pouvoir permettre à d'autres utilisateurs
d'exécuter certains programmes en son nom,
un utilisateur (typiquement, <code><font color="darkblue">root</font
></code
>),
peut activer un attribut spécial de certains fichiers
exécutables, le <em>bit s</em
>
(voir la commande <tt><font color="darkblue">chmod(1)</font
></tt
>).
On dit que le programme est <code><font color="darkblue">setuid</font
></code
>
(du nom de l'appel système qui a l'effet de changer d'utilisateur,
quand la chose est autorisée).
Le programme peut alors jongler entre deux identités,
et un processus possède alors des uid et gid effectifs et de sauvegarde
(euid, egid, suid, sgid &mdash; voir les appels systèmes
<tt><font color="darkblue">seteuid(2)</font
></tt
>, <tt><font color="darkblue">setresuid(2)</font
></tt
>, etc.).
mais en général, l'exercice est dangereux voire casse-gueule,
un trou de sécurité étant si vite arrivé.
Dans la pratique, on vérifie les droits d'accès,
on vérifie les paramètres d'appels, on nettoie l'environnement,
et on exécute un programme après avoir complètement changé d'identité
et sécurisé l'environnement.
Exercice: utiliser la commande <tt><font color="darkblue">find(1)</font
></tt
>
pour trouver tous les fichiers setuid du système...
Application typique pour les programmes setuid:
écrire un programme qui permet à tous les utilisateurs de la salle
d'enlever les <em>travaux d'impression</em
> (anglais: <em>printing jobs</em
>)
d'une imprimante partagée.
Pour tout service plus compliqué que ça,
on préférera un démon qui écoute sur le réseau,
éventuellement contrôlé par <tt><font color="darkblue">inetd(8)</font
></tt
> (ou <tt><font color="darkblue">xinetd(8)</font
></tt
>):
c'est plus propre, plus contrôlable, plus sûr;
moins de risque d'erreur qui créerait un trou de sécurité.
</p
><p align="justify"><a name="footnote17"></a
><a href="#footnoteref17">[17]</a
>: 
Un autre attribut intéressant d'un processus est
qu'il peut avoir un répertoire racine différent du répertoire habituel,
grâce à l'appel système <tt><font color="darkblue">chroot(8)</font
></tt
>, réservé à l'administrateur.
L'administrateur peut ainsi donner des droits restreints à des processus
(notamment des serveurs),
ou permettre à des programmes installés
sur un autre disque ou provenant d'une autre distribution
de tourner «&nbsp;comme à la maison&nbsp;»,
par exemple, installer une Debian sous sa SuSE ou réciproquement,
ou corriger un système en mauvais état après avoir booté sur disquette.
Voir aussi le paquet <code><font color="darkblue">dchroot</font
></code
> sous Debian,
et les options <code><font color="darkblue">--bind</font
></code
> et <code><font color="darkblue">--rbind</font
></code
> de <tt><font color="darkblue">mount(8)</font
></tt
>.
</p
><p align="justify">
Dans ce dernier cas, certains programmes (par exemple <tt><font color="darkblue">ps(1)</font
></tt
>)
requerront que l'on monte aussi <code><font color="darkblue">/proc</font
></code
> en double
sous <code><font color="darkblue">/altroot</font
></code
> (ou quelque soit la nouvelle racine):
	<code><font color="darkblue">mount proc2 /altroot/proc -t proc</font
></code
>
Pour que le système n'ait pas de problème avec la table de montages
dans <code><font color="darkblue">/proc/mounts</font
></code
>, il peut être judicieux de faire aussi un
	<code><font color="darkblue">cd /altroot ; ln -s . altroot</font
></code
>
</p
><p align="justify"><a name="footnote18"></a
><a href="#footnoteref18">[18]</a
>: 
Pour une gestion plus fine des droits d'accès sur le système,
un processus peut posséder des capabilités qui lui permettent
d'accéder à certaines parties du système
(on peut aussi restreindre son accès davantage
que la normale, en lui accordant moins de capabilités que l'habitude).
C'est une <em>fonctionnalité</em
> (anglais: <em>feature</em
>)
disponible mais encore peu exploitée du système Linux.
</p
><p align="justify"><a name="footnote19"></a
><a href="#footnoteref19">[19]</a
>: 
Pour ouvrir diverses sortes d'objets systèmes,
voir dans la section 2 du manuel (<code><font color="darkblue">man 2 <i>toto</i
></font
></code
>)
les appels système suivants et les appels affiliés:
<tt><font color="darkblue">open(2)</font
></tt
> <tt><font color="darkblue">proc(5)</font
></tt
> <tt><font color="darkblue">pipe(2)</font
></tt
> <tt><font color="darkblue">mknod(2)</font
></tt
>
<tt><font color="darkblue">socketpair(2)</font
></tt
> <tt><font color="darkblue">socket(2)</font
></tt
> <tt><font color="darkblue">accept(2)</font
></tt
> <tt><font color="darkblue">bind(2)</font
></tt
>.
</p
><p align="justify"><a name="footnote20"></a
><a href="#footnoteref20">[20]</a
>: 
dans le shell, se change avec <code><font color="darkblue">cd</font
></code
> et s'interroge avec <code><font color="darkblue">pwd</font
></code
>.
</p
><p align="justify"><a name="footnote21"></a
><a href="#footnoteref21">[21]</a
>: 
Les enfants existent encore après terminaison, avec mémoire libérée, etc.,
jusqu'à ce que le parent lise le code de retour.
Typiquement, 0 quand tout s'est bien passé,
un code d'erreur entre 1 et 255 sinon.
</p
><p align="justify">
Les appels systèmes correspondants sont
<tt><font color="darkblue">fork(2)</font
></tt
>, <tt><font color="darkblue">execve(2)</font
></tt
>, <tt><font color="darkblue">wait(2)</font
></tt
>.
Pour communiquer avec les enfants, voir aussi <tt><font color="darkblue">pipe(2)</font
></tt
>, <tt><font color="darkblue">select(2)</font
></tt
>.
Voir aussi les fonctions de librairie <tt><font color="darkblue">system(3)</font
></tt
>, <tt><font color="darkblue">popen(3)</font
></tt
>, etc.
</p
><p align="justify">
La terminologie n'est pas claire pour savoir si les processus
sont mâles ou femelles, pères ou mères, fils ou filles;
tous les cas se rencontrent. Voir aussi les pages de manuel
<tt><font color="darkblue">sex(6)</font
></tt
> et <tt><font color="darkblue">condom(1)</font
></tt
>.
</p
><p align="justify"><a name="footnote22"></a
><a href="#footnoteref22">[22]</a
>: 
Par exemple, une priorité,
que l'on peut changer avec <tt><font color="darkblue">nice(1)</font
></tt
> ou <tt><font color="darkblue">renice(8)</font
></tt
>.
Ou encore des moyens de communication inter-processus
selon les protocoles définis par la norme Unix Système V (SYSV IPC) &mdash;
<code><font color="darkblue">man 2 ipc</font
></code
>.
Pour vraiment <em>tout</em
> savoir sur les processus,
le seul moyen est de lire les sources du noyau Linux,
dont diverses versions sont largement documentées
dans divers livres en-ligne ou papier. (Demander à Google Linux.)
(Certains disent que les sources des systèmes BSD
sont souvent plus compréhensibles et mieux documentés.)
</p
><p align="justify"><a name="footnote23"></a
><a href="#footnoteref23">[23]</a
>: 
À vrai dire, il est possible de lire (mais pas d'écrire)
l'environnement d'un autre processus via <code><font color="darkblue">/proc/$PID/environ</font
></code
>,
et s'échanger des droits d'accès et des descripteurs de fichiers via les
"ancillary data" de <tt><font color="darkblue">sendmsg(2)</font
></tt
> et <tt><font color="darkblue">recvmsg(2)</font
></tt
>
(fonctionnalité obscure documentée dans <tt><font color="darkblue">unix(7)</font
></tt
>).
Mais cela suppose que les processus partagent déjà une socket de domaine unix,
et pour le <em>contact initial</em
> entre deux processus,
on est donc ramené au problème précédent:
ou bien ils l'ont hérité d'un parent qui aurait utilisé
<tt><font color="darkblue">socketpair(2)</font
></tt
> ou autre,
ou bien le serveur a une socket nommée,
qu'il a rendue visible sur le système de fichier
avec une commande du genre
<code><font color="darkblue">bind(3, {sa_family=AF_UNIX, path="/tmp/.X11-unix/X0"}, 19)</font
></code
>
(exemple extrait du <tt><font color="darkblue">strace(1)</font
></tt
> de l'exécution d'un serveur X).
</p
><p align="justify"><a name="footnote24"></a
><a href="#footnoteref24">[24]</a
>: Appels systèmes <tt><font color="darkblue">fork(2)</font
></tt
> puis <tt><font color="darkblue">execve(2)</font
></tt
>.</p
><p align="justify"><a name="footnote25"></a
><a href="#footnoteref25">[25]</a
>: 
Dans le langage C autour duquel Unix est défini,
le comportement d'une commande à son lancement est spécifié
par une fonction <code><font color="darkblue">main</font
></code
>, qui prend
en argument le nombre des paramètres et un tableau contenant ces paramètres.
En raison d'une convention de programmation en C,
le caractère de numéro 0 n'est pas représentable
dans les chaînes de caractère standards du C (il sert de terminateur),
et ne peut donc être présent dans les paramètres d'une commande.
</p
><p align="justify">
Notez qu'en tout premier argument, l'argument 0,
nommé <code><font color="darkblue">$0</font
></code
> dans les shell-scripts,
il y a le nom du programme appelé tel que fourni par le programme appelant.
Il s'agit par convention du chemin menant effectivement au programme appelé,
mais l'appelant peut spécifier ce qu'il désire.
La plupart des programmes ne consultent pas
ce nom sous lequel ils sont invoqués,
et ne s'occupent que des véritables paramètres.
Toutefois, certains programmes changent leur comportement
selon le nom sous lequel ils sont invoqués:
ainsi, l'outil à tout faire pour systèmes embarqués <tt><font color="darkblue">busybox(1)</font
></tt
>
change de personnalité selon son nom d'invocation;
un shell détectera s'il est shell de login avec la convention que
le programme <tt><font color="darkblue">login(8)</font
></tt
> précèdera son nom d'un caractère '-';
certains programmes notamment des shells ont des «&nbsp;modes de compatibilité&nbsp;»
qui s'activent quand ils sont appelés avec le nom d'un ancien programme
qu'ils savent remplacer.
</p
><p align="justify"><a name="footnote26"></a
><a href="#footnoteref26">[26]</a
>: 
Toutes les variables d'environnement sont internées
comme variables disponibles dans le shell.
Mais toutes les variables internes du shell ne sont pas forcément visibles
comme variables d'environnement pour les commandes exécutées:
pour cela, il faut les définir <code><font color="darkblue">FOO=toto</font
></code
>
<em>puis</em
> les <em>exporter</em
> (anglais: <em>to export</em
>)
avec <code><font color="darkblue">export FOO</font
></code
> dans le shell POSIX de base,
ou les définir et les exporter d'un seul coup <code><font color="darkblue">export FOO=toto</font
></code
>
avec <tt><font color="darkblue">bash(1)</font
></tt
>, <tt><font color="darkblue">zsh(1)</font
></tt
> ou <tt><font color="darkblue">ksh(1)</font
></tt
>,
ou avec <code><font color="darkblue">setenv</font
></code
> pour <tt><font color="darkblue">csh(1)</font
></tt
> et <tt><font color="darkblue">tcsh(1)</font
></tt
>.
En C, voir les appels d'API <tt><font color="darkblue">getenv(3)</font
></tt
> et <tt><font color="darkblue">putenv(3)</font
></tt
>
et l'appel système <tt><font color="darkblue">execve(2)</font
></tt
>.
Pour votre langage préféré, consulter la documentation adéquate.
</p
><p align="justify"><a name="footnote27"></a
><a href="#footnoteref27">[27]</a
>: 
On peut distinguer un fichier dont le commençant par <tt><font color="brown">-</font
></tt
> d'une option
en précédent le nom du fichier d'un chemin d'accès,
par exemple <code><font color="darkblue">./-foo</font
></code
> pour le fichier <code><font color="darkblue">-foo</font
></code
> du répertoire actuel.
Ainsi, si vous créez par erreur un fichier <code><font color="darkblue">-foo</font
></code
>,
vous pouvez l'effacer avec <code><font color="darkblue">rm ./-foo</font
></code
>.
</p
><p align="justify"><a name="footnote28"></a
><a href="#footnoteref28">[28]</a
>: 
Ainsi, si vous créez par erreur un fichier <code><font color="darkblue">-foo</font
></code
>,
vous pouvez aussi l'effacer avec <code><font color="darkblue">rm -- -foo</font
></code
>.
</p
><p align="justify"><a name="footnote29"></a
><a href="#footnoteref29">[29]</a
>: 
Consultez le <a href="http://www.catb.org/~esr/jargon/">jargon</a
>
ou le <a href="http://www.linux-france.org/prj/jargonf/">jargon français</a
>
pour la signification de mots bizarres comme «&nbsp;foo&nbsp;».
</p
><p align="justify"><a name="footnote30"></a
><a href="#footnoteref30">[30]</a
>: 
Toutefois, quand on accède à un système de fichier du monde Windows,
le noyau va faire en sorte que
les noms de fichiers correspondant à majuscule ou minuscule près
vont magiquement correspondre au même fichier ou répertoire.
</p
><p align="justify"><a name="footnote31"></a
><a href="#footnoteref31">[31]</a
>: 
Attention qu'avec les liens symboliques,
le père d'un sous-répertoire n'est pas forcément le répertoire actuel,
si ledit sous-répertoire est en fait un lien symbolique.
</p
><p align="justify"><a name="footnote32"></a
><a href="#footnoteref32">[32]</a
>: 
Ou avec l'appel système <tt><font color="darkblue">stat(2)</font
></tt
>.
</p
><p align="justify"><a name="footnote33"></a
><a href="#footnoteref33">[33]</a
>: 
Cela évite le risque d'avoir à gérer le cas où on couperait
de la racine une arborescence qui serait liée en boucle, par exemple:
<code><font color="darkblue">mkdir foo ; cd foo ; ln . bar ; cd .. ; rm -rf foo</font
></code
>
</p
><p align="justify"><a name="footnote34"></a
><a href="#footnoteref34">[34]</a
>: 
Pour éviter un plantage en cas de liens circulaires,
le noyau ne suit les liens que jusqu'à une certaine profondeur limitée.
</p
><p align="justify"><a name="footnote35"></a
><a href="#footnoteref35">[35]</a
>: 
Ainsi, on pourra par exemple monter la partition <code><font color="darkblue">/</font
></code
>
en lecture seule et faire un lien symbolique de <code><font color="darkblue">/tmp</font
></code
>
vers <code><font color="darkblue">/var/tmp</font
></code
> où <code><font color="darkblue">/var</font
></code
> a été monté en lecture-écriture.
Ou encore, on pourra monter de nombreux fichiers par NFS
sur un n&oelig;ud au nom physique <code><font color="darkblue">/serveur</font
></code
> et faire des liens
de <code><font color="darkblue">/home</font
></code
> vers <code><font color="darkblue">/serveur</font
></code
>, etc.
Pour le cas où <code><font color="darkblue">/serveur</font
></code
> serait indisponible,
on peut aussi créer des liens sous le n&oelig;ud où <code><font color="darkblue">/serveur</font
></code
> est monté
pour pointer vers une location <em>par défaut</em
>
où chercher quelques fichiers essentiels de remplacement.
</p
><p align="justify"><a name="footnote36"></a
><a href="#footnoteref36">[36]</a
>: 
Exemple d'utilisation des liens durs pour créer plusieurs versions:
<pre>tar zxvf $ARCHIVE/v1.0.tar.gz
chmod a-w v1.0/**/*(.)
cp -al v1.0 v1.1
cd v1.1 ; zcat $ARCHIVE/v1.0-v1.1.diff.gz | patch -p1 -E
chmod a-w v1.1/**/*(.)
cp -al v1.1 v1.2
cd v1.2 ; zcat $ARCHIVE/v1.0-v1.1.diff.gz | patch -p1 -E
cp -al v1.1 v1.1-localfork
cd v1.2 ; bzcat $ARCHIVE/v1.1-localfork.diff.bz2 | patch -p1 -E
cp -al v1.2 courant</pre
>
On peut alors modifier la version 1.2
pour lui apporter les modifications correspondant
à ce qu'on avait fait subir à la version 1.1
dans la branche locale v1.1-localfork.
Les outils <tt><font color="darkblue">diff(1)</font
></tt
> et <tt><font color="darkblue">diff3(1)</font
></tt
> peuvent se révéler très utiles,
de même que <tt><font color="darkblue">patch(1)</font
></tt
>.
</p
><p align="justify">
Notons que cet exemple fonctionne bien
parce que <tt><font color="darkblue">patch(1)</font
></tt
> ne modifie pas l'original
(qui peut donc être partagé), mais le remplace par une copie modifiée;
un tel partage par lien dur ne donnera par les résultats escomptés
si certains programmes modifient directement
des fichiers partagés par d'autres versions.
</p
><p align="justify"><a name="footnote37"></a
><a href="#footnoteref37">[37]</a
>: 
Affichez les droits du répertoire <code><font color="darkblue">/tmp</font
></code
>, avec <code><font color="darkblue">ls -ld /tmp</font
></code
>)
et voyez le bit sticky noté par <code><font color="darkblue">t</font
></code
> à la fin des droits
Le répertoire <tt>/tmp</tt
>
et son éventuel petit copain, <tt>/var/tmp</tt
>
(qui est parfois un lien vers <tt>/tmp</tt
> ou vice-versa),
voire plus rarement <tt>/usr/tmp</tt
>
(qui s'il existe est souvent un lien symbolique vers <tt>/var/tmp</tt
>),
sont des endroits dans lequel par convention
les programmes stoquent des fichiers temporaires.
Ainsi par exemple, quand on compile,
des fichiers produits par le préprocesseur
ou donnés à l'assembleur ou à l'éditeur de lien y sont stoqués.
Tout le monde a donc les droits d'écriture sur ce répertoire.
Sans le sticky bit, documenté notamment dans la page de <tt><font color="darkblue">chmod(1)</font
></tt
>,
un utilisateur mal intentionné pourrait alors
détruire le fichier temporaire d'un autre
et le remplacer par un fichier au contenu maléfique (ver, virus, etc.).
Mais avec ce bit (noté <code><font color="darkblue">t</font
></code
> comme temporaire, justement?),
seul le propriétaire du fichier ou celui du répertoire (ou <code><font color="darkblue">root</font
></code
>)
peut effacer ou renommer ledit fichier.
Cela bouche ainsi un trou de sécurité béant qui existait originellement.
Si par mégarde vous effacez <code><font color="darkblue">/tmp</font
></code
> et le recréez,
n'oubliez donc pas un
<code><font color="darkblue">chown root.root /tmp ;
chmod 1777 /tmp</font
></code
>
</p
><p align="justify"><a name="footnote38"></a
><a href="#footnoteref38">[38]</a
>: 
voir la commande <tt><font color="darkblue">mount(8)</font
></tt
>
et les fichiers <tt><font color="darkblue">fstab(5)</font
></tt
>, <code><font color="darkblue">/etc/mtab</font
></code
>, <code><font color="darkblue">/proc/mounts</font
></code
>.
</p
><p align="justify"><a name="footnote39"></a
><a href="#footnoteref39">[39]</a
>: 
voir les commandes <code><font color="darkblue">ls -l</font
></code
>, <code><font color="darkblue">ln -s</font
></code
>,
les appels système <tt><font color="darkblue">readlink(2)</font
></tt
> et <tt><font color="darkblue">lstat(2)</font
></tt
>.
Pour détecter et nettoyer les liens cassés,
il y a aussi l'utilitaire <tt><font color="darkblue">symlink(1)</font
></tt
>
</p
><p align="justify"><a name="footnote40"></a
><a href="#footnoteref40">[40]</a
>: 
<tt><font color="darkblue">apropos(1)</font
></tt
> est identique à <code><font color="darkblue">man -k</font
></code
>.
</p
><p align="justify"><a name="footnote41"></a
><a href="#footnoteref41">[41]</a
>: 
À noter que les réseaux sous Windows utilisent TCP/IP,
et que Linux peut être un serveur grâce à <tt><font color="darkblue">samba(7)</font
></tt
>,
ou un client grâce à <tt><font color="darkblue">smbclient(1)</font
></tt
> ou <tt><font color="darkblue">smbmount(8)</font
></tt
>.
</p
><p align="justify"><a name="footnote42"></a
><a href="#footnoteref42">[42]</a
>: 
Un processus sait en général à quel serveur s'adresser
par la variable d'environnement <code><font color="darkblue">DISPLAY</font
></code
>.
Avec votre shell: <code><font color="darkblue">echo $DISPLAY</font
></code
>.
Pour dire à votre commandes d'utiliser le premier (et par défaut le seul)
serveur de la machine courante, utiliser <code><font color="darkblue">export DISPLAY=:0</font
></code
>.
Pour la gestion des droits d'accès,
voir les commandes <code><font color="darkblue">xhost(1x)</font
></code
>, <code><font color="darkblue">xauth(1x)</font
></code
>.
Souvent, le serveur n'est configuré
pour n'accepter que des connexions locales;
pour les connexions distantes, redirection par <tt><font color="darkblue">ssh(1)</font
></tt
>,
ou changer la configuration dans <code><font color="darkblue">/etc/X11/</font
></code
>.
Si vous utilisez la mire automatique <code><font color="darkblue">xdm</font
></code
>, <code><font color="darkblue">kdm</font
></code
> ou <tt><font color="darkblue">gdm(8)</font
></tt
>,
allez voir dans le répertoire correspondant.
</p
><p align="justify"><a name="footnote43"></a
><a href="#footnoteref43">[43]</a
>: 
<code><font color="darkblue">startx(1x)</font
></code
> est un shell script qui appelle la commande <code><font color="darkblue">xinit(1x)</font
></code
>
(regardez un peu voir son source avec <code><font color="darkblue">less `which startx`</font
></code
>
ou sous <tt><font color="darkblue">zsh(1)</font
></tt
>, <code><font color="darkblue">less =startx</font
></code
>).
En configurant proprement les bonnes commandes,
on peut aussi lancer plusieurs serveurs X,
chacun sur sa console virtuelle.
</p
><p align="justify">
Si vous jouez à lancer des serveurs X à la main,
ou avant que le système soit complètement initialisé,
attention que si plusieurs processus son ouverts
sur la même console virtuelle et utilisent des modes clavier différents,
votre clavier peut devenir non-fonctionnel.
Un serveur X gravement planter (mauvais driver de carte graphique)
peut aussi laisser votre clavier dans le mauvais mode.
Si votre clavier est dans le mauvais mode,
depuis un <tt><font color="darkblue">ssh(1)</font
></tt
> distant
ou en survivant en copiant-collant avec la souris,
utiliser <tt><font color="darkblue">kbd_mode(1)</font
></tt
> pour remettre le clavier dans le bon mode.
Notez qu'avec le copy-paste de la souris,
vous pouvez parfois entrer dans un shell assez de commandes
pour reconfigurer le clavier
(ou changer de console virtuelle avec <tt><font color="darkblue">chvt(1)</font
></tt
>).
Autre solution: les touches magiques du noyau Linux,
voir <code><font color="darkblue">/usr/src/linux*/Documentation/sysrq.txt</font
></code
>.
</p
><p align="justify"><a name="footnote44"></a
><a href="#footnoteref44">[44]</a
>: 
Ceux d'entre vous qui ont le c&oelig;ur bien accroché
pouvez aussi consulter mes fichiers de configuration personnels
qui sont disponibles dans toute leur horreur
<a href="http://fare.tunes.org/cgi-bin/viewcvs.cgi/">par CVS</a
>.
Diverses écoles d'ingénieur fournissent aussi
des configurations utilisateur par défaut dont vous pouvez vous inspirer.
Dernière note: pensez à consulter
la configuration par défaut de votre shell dans <code><font color="darkblue">/etc</font
></code
>
avant toute une personnalisation sérieuse;
j'ai souvent eu à désactiver la <code><font color="darkblue">@$^#%&#38;!</font
></code
> de configuration
fournie par défaut sur ma machine.
</p
><p align="justify"><a name="footnote45"></a
><a href="#footnoteref45">[45]</a
>: 
Ces shells sont typiquement des shells POSIX assez minimaux,
mais pouvant être statiquement liés,
et intégrant les fonctionnalités de nombreux programmes
comme <tt><font color="darkblue">ls(1)</font
></tt
>, <tt><font color="darkblue">mv(1)</font
></tt
>, etc.,
ce qui leur permet de récupérer un système
dont le mécanisme de bibliothèques partagées
est cassé par une mauvaise manipulation,
ou de fournir le plus possible des outils habituels
dans le moins possible de place
pour déploiement dans des systèmes embarqués limités en mémoire.
Pour la récupération de système en tout confort,
il est aussi possible de compiler statiquement <tt><font color="darkblue">zsh(1)</font
></tt
>.
</p
><p align="justify"><a name="footnote46"></a
><a href="#footnoteref46">[46]</a
>: 
Attention:
si le shell n'est pas parmi ceux listés dans <tt><font color="darkblue">shells(5)</font
></tt
>
alors divers services vont considérer l'utilisateur
comme ayant des droits restreints.
Solution: si vous êtes administrateur, ajoutez votre shell dedans.
Sinon, avoir <code><font color="darkblue">/bin/sh</font
></code
> comme shell officiel,
et terminer votre <code><font color="darkblue">.profile</font
></code
>
par un <code><font color="darkblue">exec /path/to/your/favorite/shell</font
></code
>.
Les précautions d'usage s'imposent quand vous faites cela.
</p
><p align="justify"><a name="footnote47"></a
><a href="#footnoteref47">[47]</a
>: 
Dans le cas rare mais fort gênant où deux administrateurs
tentent simultanément d'éditer ledit fichier,
il peut y avoir des étincelles et des plantages graves.
Pour prévenir une telle catastrophe, l'utilitaire <tt><font color="darkblue">vipw(8)</font
></tt
>
est censé lancer votre éditeur favori
(tel que spécifié dans <code><font color="darkblue">$EDITOR</font
></code
> ou par défaut <tt><font color="darkblue">vi(1)</font
></tt
>)
sur le fichier avec un verrou qui évitera de tels désagréments.
Si vous êtes le seul administrateur de la machine,
cette précaution peut paraître superflue,
mais elle peut néanmoins être un bon réflexe à acquérir
si vous comptez jamais devenir administrateur
d'un système multi-administrateur.
</p
><p align="justify"><a name="footnote48"></a
><a href="#footnoteref48">[48]</a
>: 
Sous <tt><font color="darkblue">zsh(1)</font
></tt
> voir aussi la variable <code><font color="darkblue">RPROMPT</font
></code
>.
</p
><p align="justify"><a name="footnote49"></a
><a href="#footnoteref49">[49]</a
>: 
La touche <tt><font color="brown">BackSpace</font
></tt
> est souvent vue
comme <tt><font color="brown">C-h</font
></tt
> ou <tt><font color="brown">C-?</font
></tt
> ou le caractère ASCII 127;
La touche <tt><font color="brown">Delete</font
></tt
> est souvent égale à <tt><font color="brown">C-?</font
></tt
>
ou une séquence d'échappement du genre <tt><font color="brown">^[[3~</font
></tt
>.
Voir la discussion dans la section sur les terminaux.
</p
><p align="justify"><a name="footnote50"></a
><a href="#footnoteref50">[50]</a
>: 
Si on est au milieu d'une ligne, on pourra utiliser <tt><font color="brown">C-k</font
></tt
>
pour se mettre en fin de ligne en effaçant ce qui suit,
et <tt><font color="brown">C-y</font
></tt
> pour récupérer ce qui suit après avoir fini la complétion.
</p
><p align="justify"><a name="footnote51"></a
><a href="#footnoteref51">[51]</a
>: 
Pour ne pas avoir à payer le coût d'une recherche dans tout le <code><font color="darkblue">$PATH</font
></code
>
à chaque commande, le shell se souvient du contenu des répertoires indiqués
après la première recherche.
Pour le forcer à regarder à nouveau, on peut utiliser la commande interne
<code><font color="darkblue">hash -r</font
></code
>.
</p
><p align="justify"><a name="footnote52"></a
><a href="#footnoteref52">[52]</a
>: 
Parfois, le shell peut vous dire que l'exécutable n'est pas trouvé,
alors que le programme existe visiblement;
ce peut alors être dû au fait que le programme en question est un script
(dont la première ligne commence par le signe <code><font color="darkblue">#!</font
></code
>
suivi de la commande à lancer pour invoquer un interpréteur de script)
mais que l'interpréteur spécifié lui n'est pas trouvé.
</p
><p align="justify"><a name="footnote53"></a
><a href="#footnoteref53">[53]</a
>: 
La commande <tt><font color="darkblue">rm(1)</font
></tt
> efface sans rémission.
Une fois supprimé le dernier lien dur vers un fichier,
ledit fichier n'existe plus et il n'y a pas de <code><font color="darkblue">undelete</font
></code
> possible.
Pour éviter des erreurs trop faciles, le shell permet parfois
d'insérer automatiquement l'option <code><font color="darkblue">-i</font
></code
>
(avec <code><font color="darkblue">alias rm='rm -i'</font
></code
>)
ou de demander confirmation avant un <code><font color="darkblue">rm *</font
></code
>,
mais ce sont des pis-aller.
</p
><p align="justify">
Il existe d'autres programmes plus sympathiques
pour déplacer un fichier vers une zone intermédiaire
(comme la <em>corbeille</em
> (anglais: <em>trash can</em
>) de MacOS ou Windows),
mais aucun n'est un standard présent dans tout le monde UNIX,
et ces divers programmes n'interopèrent pas.
Notez toutefois que l'interface graphique de KDE ou celle de GNOME
offrent les deux options distinctes, mettre à la corbeille et supprimer.
</p
><p align="justify">
La seule solution «&nbsp;standard&nbsp;» et «&nbsp;fiable&nbsp;»
pour éviter de perdre des données par mégarde
est d'avoir des backups réguliers.
Et cette solution, si elle est bien réalisée
(copie dans un lieu sûr loin de l'ordinateur lui-même),
vous couvre contre bien plus
qu'une erreur humaine somme toute infréquente:
elle vous couvre contre un plantage du disque dur, un incendie, un vol, etc.
Pour les sauvegardes, voir la commande <tt><font color="darkblue">tar(1)</font
></tt
>,
ou pour un système de fichier entier, la commande <tt><font color="darkblue">dump(8)</font
></tt
>;
dans un autre genre,
les commandes <tt><font color="darkblue">rsync(1)</font
></tt
> et <tt><font color="darkblue">unison(1)</font
></tt
>
peuvent aussi s'avérer précieuses.
</p
><p align="justify">
Il peut aussi être de bon ton de mettre ses fichiers importants
sous un système de gestion de versions, comme <tt><font color="darkblue">cvs(1)</font
></tt
>,
ou ses remplaçants plus modernes
(voir section ci-dessus "Habitudes élémentaires de précaution").
Ce qui n'empêche pas de faire une sauvegarde
des fichiers de <tt><font color="darkblue">cvs(1)</font
></tt
> ou autre.
</p
><p align="justify"><a name="footnote54"></a
><a href="#footnoteref54">[54]</a
>: 
Concernant le souci d'effacer vraiment un fichier
de façon fiable sans rémission aucune possible
(pour raison de confidentialité, avant de vous séparer d'un disque
ayant contenu des données sensibles),
notez que quelqu'un disposant du disque et de plusieurs milliers d'euros
et pourra toujours demander à des ingénieurs équipés
d'une platine haute précision dans chambre blanche
de récupérer les données sur votre disque même
après que le système ait écrasé vos fichiers
et écrit par dessus deux ou trois fois.

</p
><p align="justify">
Si vous tenez à la confidentialité, utilisez une commande appropriée
comme <tt><font color="darkblue">shred(1)</font
></tt
>, sur votre fichier (si le système de fichier le permet)
ou sur toute la partition (sinon).
Peut-être les systèmes de fichiers journalisés les plus modernes
ont-ils un mécanisme spécial pour spécifier que certains fichiers
doivent se comporter de façon à permettre un tel effacement sûr;
en tout cas, se méfier de ce que si les données ont été écrites
<em>avant</em
> qu'un tel mécanisme ait été utilisé,
alors elles sont potentiellement lisibles
à moins d'effacer de façon sûre toute la partition.
</p
><p align="justify">
Si vous en êtes à de telles considérations,
vous devriez songer à crypter l'ensemble de vos données,
ce qui sous Linux peut se faire en utilisant
<a href="http://www.saout.de/misc/dm-crypt/">dm-crypt</a
> ou
<a href="http://deb.riseup.net/storage/encryption/loop-aes/">loop-aes</a
>.
</p
><p align="justify"><a name="footnote55"></a
><a href="#footnoteref55">[55]</a
>: 
Voici pour déboguer un script qui affiche ses arguments:
<pre><font color="darkblue">#!/bin/zsh -f
# Ceci est un commentaire
# L'option -f est utile pour un script, voir la page de manuel.
print -r "ARGC=$#"      # Afficher le nombre d'arguments
print -r "argv[0]=$0"   # Afficher le nom sous lequel le programme est appelé
i=1                       # initialiser la boucle
while [ "$i" -le "$#" ] ; do # tant qu'on a pas vu tous les arguments
  print -r "argv[$i]=$*[$i]"   # afficher l'argument actuel
  i=$[i+1]                       # passer à l'argument suivant
done                             # retour en boucle</font
></pre
>
En voici un autre, utilisant bash
<pre><font color="darkblue">#!/bin/bash
# Ceci est un commentaire
echo "ARGC=$#"      # Afficher le nombre d'arguments
echo "argv[0]=$0"   # Afficher le nom sous lequel le programme est appelé
x=1                   # initialiser le compteur d'arguments
for i ; do            # pour chacun des arguments donnés
  echo "argv[$x]=$i"	         # afficher l'argument actuel
  i=$((i+1))                     # incrémenter le compteur d'argument
done                             # retour en boucle</font
></pre
>
En voilà un dernier, n'utilisant que des fonctionnalités standard POSIX:
<pre><font color="darkblue">#!/bin/sh
# Ceci est un commentaire
echo "ARGC=$#"      # Afficher le nombre d'arguments
echo "argv[0]=$0"   # Afficher le nom sous lequel le programme est appelé
x=1                   # initialiser le compteur d'arguments
while [ "$#" -ne 0 ] ; do        # tant qu'il y a encore des arguments
  echo "argv[$x]=$1"	         # afficher le premier argument
  x=`expr $x + 1`                # incrémenter le compteur d'argument
  shift				 # laisser tomber le premier argument
done                             # retour en boucle</font
></pre
>
Pour afficher les arguments d'une commande en cours d'exécution, essayer:
<code><font color="darkblue">cat /proc/$PID/cmdline | tr '\0' '\n'</font
></code
>
</p
><p align="justify"><a name="footnote56"></a
><a href="#footnoteref56">[56]</a
>: 
Solution:
<code><font color="darkblue">echo image{{0-9},{1-9}{0-9},1{0-9}{0-9},2{0-4}{0-9},25{0-5}}.gif</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote57"></a
><a href="#footnoteref57">[57]</a
>: 
La convention est que <code><font color="darkblue">login</font
></code
> invoquera le shell avec un tiret '-'
devant le chemin de son binaire comme argument numéro 0.
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, on peut invoquer un programme
avec un argument 0 différent du chemin d'accès
grâce à la variable <code><font color="darkblue">ARGV0</font
></code
> &mdash; <code><font color="darkblue">man zshparam</font
></code
>.
</p
><p align="justify"><a name="footnote58"></a
><a href="#footnoteref58">[58]</a
>: 
Voir la commande <tt><font color="darkblue">tty(1)</font
></tt
>.
Voir sous <tt><font color="darkblue">bash(1)</font
></tt
> la variable <code><font color="darkblue">$tty</font
></code
>
ou sous <tt><font color="darkblue">zsh(1)</font
></tt
> la variable <code><font color="darkblue">$TTY</font
></code
>.
</p
><p align="justify"><a name="footnote59"></a
><a href="#footnoteref59">[59]</a
>: 
Voir par exemple mon choix d'options pour <tt><font color="darkblue">zsh(1)</font
></tt
> dans mon
<a href="http://fare.tunes.org/cgi-bin/viewcvs.cgi/etc/zsh/zshrc.opts"><code><font color="darkblue">zshrc.opts</font
></code
></a
>.
</p
><p align="justify"><a name="footnote60"></a
><a href="#footnoteref60">[60]</a
>: 
L'historique des commandes peut être fort utile,
mais peut aussi être une source de vulnérabilité,
car des ennemis peuvent espionner vos habitudes,
les maladresses que vous commettez,
vos manquements aux règles de sécurité,
les mots de passe que vous auriez tapé au mauvais endroit,
etc.
En général, je conseille de désactiver la fonctionnalité
qui sauve l'historique dans un fichier,
sauf ponctuellement pour enregistrer explicitement une session.
</p
><p align="justify"><a name="footnote61"></a
><a href="#footnoteref61">[61]</a
>: 
Utiliser <tt><font color="darkblue">cut(1)</font
></tt
> pour isoler le champ idoine du fichier <tt><font color="darkblue">passwd(5)</font
></tt
>
puis utiliser le tri de <tt><font color="darkblue">sort(1)</font
></tt
> avec l'option d'unicité
pour éliminer les doublons.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote62"></a
><a href="#footnoteref62">[62]</a
>: 
<code><font color="darkblue">&#60; /etc/passwd cut -d: -f7 | sort -u</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote63"></a
><a href="#footnoteref63">[63]</a
>: 
Utilisez la commande <tt><font color="darkblue">cut(1)</font
></tt
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote64"></a
><a href="#footnoteref64">[64]</a
>: 
<code><font color="darkblue">find . -type f | cut -c 3-</font
></code
> <br
/>
Sous <tt><font color="darkblue">zsh(1)</font
></tt
>, avec le globbing étendu, il suffit de <code><font color="darkblue">**/*(.)</font
></code
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote65"></a
><a href="#footnoteref65">[65]</a
>: 
Un script robuste doit être capable de traiter
des noms de fichiers contenant espacements et retour à la ligne;
on utilisera alors <code><font color="darkblue">find ... -print0</font
></code
>, <code><font color="darkblue">xargs -0 ...</font
></code
>
et sous <tt><font color="darkblue">zsh(1)</font
></tt
>, <code><font color="darkblue">print -N ...</font
></code
>.
</p
><p align="justify"><a name="footnote66"></a
><a href="#footnoteref66">[66]</a
>: 
Dans le genre pager alternatif, voir aussi <tt><font color="darkblue">most(1)</font
></tt
>,
et bien sûr <tt><font color="darkblue">w3m</font
></tt
> pour le HTML.
</p
><p align="justify"><a name="footnote67"></a
><a href="#footnoteref67">[67]</a
>: 
<tt><font color="darkblue">mail(1)</font
></tt
> est un programme UNIX très ancien (début des années 1980),
et chaque distribution Linux utilise un des nombreux programmes
qui réimplémente le <tt><font color="darkblue">mail</font
></tt
> original
(tel que vu sur des UNIX propriétaires)
en l'enrichissant de nombreuses options.
Toutefois, l'interface pour envoyer des attachements par exemple
n'est pas standardisée,
aussi la version répandue <tt><font color="darkblue">mailx(1)</font
></tt
> installée sous Debian
ne les connaît pas,
tandis que l'implémentation <tt><font color="darkblue">nail(1)</font
></tt
> installée sous SuSE, les connaît.
Si vous voulez envoyer des attachements depuis un script portable,
appelez explicitement <tt><font color="darkblue">nail(1)</font
></tt
>, <tt><font color="darkblue">mutt(1)</font
></tt
> ou autre
plutôt que <tt><font color="darkblue">mail(1)</font
></tt
> qui sur une machine ou une autre
ne réagira pas selon vos attentes.
</p
><p align="justify"><a name="footnote68"></a
><a href="#footnoteref68">[68]</a
>: 
<tt><font color="darkblue">gzip(1)</font
></tt
> (fichiers <code><font color="darkblue">.gz</font
></code
> ou pour des vieilles versions, <code><font color="darkblue">.z</font
></code
>,
même compression que le programme <tt><font color="darkblue">zip(1)</font
></tt
>),
mais aussi
<tt><font color="darkblue">bzip2(1)</font
></tt
> (fichiers <code><font color="darkblue">.bz2</font
></code
>, successeur de <tt><font color="darkblue">bzip(1)</font
></tt
>,
sans brevets logiciels),
<tt><font color="darkblue">lzop(1)</font
></tt
> (fichiers <code><font color="darkblue">.lzo</font
></code
>,
légèrement moins bon mais plus rapide que <tt><font color="darkblue">gzip(1)</font
></tt
>),
<tt><font color="darkblue">bzip(1)</font
></tt
> (fichiers <code><font color="darkblue">.bz</font
></code
>,
prédécesseur de <code><font color="darkblue">bzip2</font
></code
> arrêté à cause de brevets logiciels),
<tt><font color="darkblue">tzip(1)</font
></tt
> (fichiers <code><font color="darkblue">.tz</font
></code
>,
n'a jamais eu le succès de <code><font color="darkblue">bzip2</font
></code
>),
<tt><font color="darkblue">compress(1)</font
></tt
> (fichiers <code><font color="darkblue">.Z</font
></code
>,
ancien programme de mauvaise qualité avec problèmes de brevets logiciels,
mais longtemps standard officiel sous UNIX),
<tt><font color="darkblue">pack(1)</font
></tt
> (fichiers <code><font color="darkblue">.z</font
></code
>, programme antique peu performant)
etc.
</p
><p align="justify"><a name="footnote69"></a
><a href="#footnoteref69">[69]</a
>: 
Comprimés en <code><font color="darkblue">.tar.bz2</font
></code
> ou <code><font color="darkblue">.tar.gz</font
></code
> ou <code><font color="darkblue">.tar.Z</font
></code
>
(souvent appelés plus simplement
<code><font color="darkblue">.tb2</font
></code
>, <code><font color="darkblue">.tbz</font
></code
>, <code><font color="darkblue">.tgz</font
></code
>, <code><font color="darkblue">.taz</font
></code
>, <code><font color="darkblue">.trz</font
></code
>),
etc.
Autres types d'archives:
<tt><font color="darkblue">pax(1)</font
></tt
> (fichiers <code><font color="darkblue">.pax</font
></code
>),
<tt><font color="darkblue">cpio(1)</font
></tt
> (fichiers <code><font color="darkblue">.cpio</font
></code
>),
<tt><font color="darkblue">ar(1)</font
></tt
> (fichiers <code><font color="darkblue">.a</font
></code
>),
<tt><font color="darkblue">shar(1)</font
></tt
> (fichiers <code><font color="darkblue">.shar</font
></code
>
&mdash; exécutables par un shell, attention aux virus shell).
Et archives déjà comprimées:
<tt><font color="darkblue">unzip(1)</font
></tt
> (fichiers <code><font color="darkblue">.zip</font
></code
>)
<tt><font color="darkblue">zoo(1)</font
></tt
> (fichiers <code><font color="darkblue">.zoo</font
></code
>),
<tt><font color="darkblue">lha(1)</font
></tt
> (fichiers <code><font color="darkblue">.lzh</font
></code
>),
<tt><font color="darkblue">unarj(1)</font
></tt
> (fichiers <code><font color="darkblue">.arj</font
></code
>),
<tt><font color="darkblue">rar(1)</font
></tt
> (fichiers <code><font color="darkblue">.rar</font
></code
>),
etc.
Connaître aussi <tt><font color="darkblue">uuencode(1)</font
></tt
> (ou des variantes comme <tt><font color="darkblue">xxencode(1)</font
></tt
>,
rendus obsolètes maintenant par le standard MIME pour l'email
(cf. le programme <tt><font color="darkblue">mimencode(1)</font
></tt
>).
</p
><p align="justify"><a name="footnote70"></a
><a href="#footnoteref70">[70]</a
>: 
Notez que par tradition,
et comme exception aux conventions habituelles,
les options de tar ne nécessitent pas de tiret
quand elles sont en première position.
Vous pouvez le rajouter si vous êtes courageux.
</p
><p align="justify">
Notez aussi que la version de <tt><font color="darkblue">tar(1)</font
></tt
> du projet GNU, utilisée par défaut sous Linux,
reconnaît aussi les fichiers comprimés avec <tt><font color="darkblue">bzip2(1)</font
></tt
> via l'option <code><font color="darkblue">j</font
></code
>
plutôt que <code><font color="darkblue">z</font
></code
>.
</p
><p align="justify"><a name="footnote71"></a
><a href="#footnoteref71">[71]</a
>: 
Pour les amateurs de mathématiques,
il y a une jolie théorie des langages réguliers,
des automates à états finis, etc.
Voir
<a href="http://fr.wikipedia.org/wiki/Expression_r%E9guli%E8re">Wikipédia</a
>.
</p
><p align="justify"><a name="footnote72"></a
><a href="#footnoteref72">[72]</a
>: 
<code><font color="darkblue">grep attention cepl-linux.html</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote73"></a
><a href="#footnoteref73">[73]</a
>: 
<code><font color="darkblue">grep -l cepl /etc/*</font
></code
> &mdash;
pour éviter les messages d'erreur
de <tt><font color="darkblue">grep(1)</font
></tt
> tentant de lire un répertoire comme un fichier,
utiliser plutôt
<code><font color="darkblue">grep -l cepl /etc/* 2&#62; /dev/null</font
></code
>
(ou, sous <tt><font color="darkblue">zsh(1)</font
></tt
>,
<code><font color="darkblue">grep -l cepl /etc/*(.)</font
></code
>)
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote74"></a
><a href="#footnoteref74">[74]</a
>: 
On pourra combiner <tt><font color="darkblue">grep(1)</font
></tt
> et <tt><font color="darkblue">wc(1)</font
></tt
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote75"></a
><a href="#footnoteref75">[75]</a
>: 
On peut compter le nombre de lignes
où apparaît le mot «&nbsp;foo&nbsp;» dans le fichier <code><font color="darkblue">cepl-linux.html</font
></code
>
avec la commande <code><font color="darkblue">grep foo &#60; cepl-linux.html | wc -l</font
></code
>.
Notez que si on voulait compter les occurrences du mot foo
en comptant les répétitions sur la même ligne,
il faudrait utiliser un programme un peu plus compliqué,
comme par exemple celui-ci
<code><font color="darkblue">
perl -e 'while (&#60;&#62;) { while ( s/.*?foo// ) { $x++; } } ; print "$x\n" ;'
</font
></code
>.
Voir un tutoriel de perl pour en savoir plus.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote76"></a
><a href="#footnoteref76">[76]</a
>: Je suis peut-être le seul à encore utiliser netscape 3.</p
><p align="justify"><a name="footnote77"></a
><a href="#footnoteref77">[77]</a
>: 
La commande <tt><font color="darkblue">file(1)</font
></tt
> permet de déterminer le type d'un fichier:
<code><font color="darkblue">file /bin/ls</font
></code
>, ou <code><font color="darkblue">file `which ls`</font
></code
>
ou sous <tt><font color="darkblue">zsh(1)</font
></tt
> avec <code><font color="darkblue">setopt MAGIC_EQUAL_SUBST</font
></code
>,
<code><font color="darkblue">file =ls</font
></code
>.
</p
><p align="justify"><a name="footnote78"></a
><a href="#footnoteref78">[78]</a
>: 
La version de <tt><font color="darkblue">ld.so(8)</font
></tt
>, comme celle des autres bibliothèques chargées,
dépend de ce qui a été utilisé lors de la compilation du programme.
Utiliser <tt><font color="darkblue">ldd(1)</font
></tt
> pour voir quelles bibliothèques
sont demandées par le programme.
Notez que le nom <code><font color="darkblue">.so</font
></code
> signifie
<em>composant exécutable partagé</em
> (anglais: <em>shared object</em
>).
</p
><p align="justify"><a name="footnote79"></a
><a href="#footnoteref79">[79]</a
>: 
Voir aussi avec <tt><font color="darkblue">ldd(1)</font
></tt
>.
Les bibliothèques dynamiques sont censées rester compatibles
tant qu'elles ont le même numéro de version majeure,
et changer de numéro de version majeure (ou carrément de nom)
quand un changement incompatible est fait à l'API.
Ainsi, on peut mettre à jour les bibliothèques
et faire profiter tous les programmes
des corrections de bugs et de trous de sécurité,
tout en faisant coexister des programmes
qui utilisent des versions incompatibles des bibliothèques dynamiques
(avec des noms ou numéro majeur de version différent).
Par exemple, sous Linux i386, <code><font color="darkblue">libc.so.6</font
></code
> est
la version 6 de l'API binaire de la bibliothèque standard
pour tous les programmes C
(qui correspond pour le source de cette bibliothèque
à la GNU libc version 2, ou glibc2).
</p
><p align="justify"><a name="footnote80"></a
><a href="#footnoteref80">[80]</a
>: 
Le répertoire <code><font color="darkblue">/lib</font
></code
> contient les bibliothèques essentielles
pour les programmes indispensables du système.
Le répertoire <code><font color="darkblue">/usr/lib</font
></code
> contient les bibliothèques
pour le reste des programmes.
Le fichier <tt><font color="darkblue">ld.so.conf(5)</font
></tt
> peut préciser des chemins additionnels.
</p
><p align="justify"><a name="footnote81"></a
><a href="#footnoteref81">[81]</a
>: 
Pour accélérer la recherche, il y a un cache dans <code><font color="darkblue">/etc/ld.so.cache</font
></code
>,
qu'on doit régénérer avec <tt><font color="darkblue">ldconfig(8)</font
></tt
>
quand on modifie l'installation des bibliothèques partagées.
Normalement, votre distribution lance cette commande au bon moment,
mais c'est bon à savoir si vous trafiquez les choses manuellement.
</p
><p align="justify"><a name="footnote82"></a
><a href="#footnoteref82">[82]</a
>: 
Exemple: la bibliothèque SOCKS,
qui permet de centraliser les accès à travers
un pare-feu ou tunnel, utilise ce mécanisme.
</p
><p align="justify"><a name="footnote83"></a
><a href="#footnoteref83">[83]</a
>: 
Vous pouvez consultez les mappings mémoire d'un processus avec
<code><font color="darkblue">cat /proc/$PID/maps</font
></code
> 
(exemple: pour le processus <tt><font color="darkblue">cat(1)</font
></tt
> lui-même,
<code><font color="darkblue">cat /proc/self/maps</font
></code
>).
</p
><p align="justify"><a name="footnote84"></a
><a href="#footnoteref84">[84]</a
>: 
Notez la différence de niveau d'abstraction par rapport à <tt><font color="darkblue">strace(1)</font
></tt
>:
dans un cas, on regarde ce qui se passe au niveau de l'API,
dans l'autre, au niveau du noyau.
Notez aussi que si on en fait l'effort, il est possible de tricher avec l'API,
en la court-circuitant pour certains appels systèmes,
ou en triturant manuellement les mécanismes de liaison dynamique;
mais il n'est pas possible de tricher avec le noyau.
</p
><p align="justify"><a name="footnote85"></a
><a href="#footnoteref85">[85]</a
>: 
Si vous faites une manipulation qui déplace ou efface <code><font color="darkblue">/lib</font
></code
>,
assurez-vous qu'un programme déjà chargé
saura en remettre immédiatement après un nouveau qui marche,
ou gardez un shell <em>statiquement lié</em
> (anglais: <em>statically linked</em
>)
(i.e. qui marche sans avoir besoin de bibliothèque partagée)
et/ou des un shell déjà ouvert et des versions statiquement liées
des programmes <tt><font color="darkblue">cp(1)</font
></tt
>, <tt><font color="darkblue">mv(1)</font
></tt
> et <tt><font color="darkblue">ln(1)</font
></tt
>.
Ce sera notamment le cas quand vous remplacerez «&nbsp;à chaud&nbsp;»
une distribution par une autre que vous aurez installée en <tt><font color="darkblue">chroot(8)</font
></tt
>.
</p
><p align="justify"><a name="footnote86"></a
><a href="#footnoteref86">[86]</a
>: 
On peut changer le format de sortie.
Ainsi, pour mes logs j'utilise parfois: <code><font color="darkblue">date +"%Y-%m-%d %H:%M:%S"</font
></code
>.
</p
><p align="justify"><a name="footnote87"></a
><a href="#footnoteref87">[87]</a
>: 
La date à la seconde près est accessible avec <code><font color="darkblue">date +%s</font
></code
>.
C'est utile pour faire des comparaisons simples d'antériorité
dans des shells scripts,
notamment en conjonction avec l'option <code><font color="darkblue">-r</font
></code
> de <tt><font color="darkblue">date(1)</font
></tt
>.
</p
><p align="justify"><a name="footnote88"></a
><a href="#footnoteref88">[88]</a
>: 
La fin du monde aura lieu très précisément à la fin de la seconde indiquée par
<code><font color="darkblue">date -u -d "1970-01-01 00:00:00 UTC + $((2 ** 31 - 1)) seconds"</font
></code
>.
(Pourquoi se casser la nénette à faire de la dichotomie soi-même
quand l'ordinateur est là pour faire tout le travail?)
D'ici là, les stations de travail seront toutes 64 bits,
ce qui nous laissera du temps pour voir venir
lors du prochain milliard de siècles;

mais il y aura peut-être des problèmes
avec les applications <i>legacy</i
>
et avec des antiques systèmes embarqués,
sans parler des programmes
que nous ferons tourner avec émotion nostalgique dans des émulateurs.
Mais que feront donc les conservateurs des musées informatiques
dans 100 voire 1000 ans?
</p
><p align="justify"><a name="footnote89"></a
><a href="#footnoteref89">[89]</a
>: 
Voir par exemple un simple programme que j'ai écrit en ce sens:
<a href="http://fare.tunes.org/cgi-bin/viewcvs.cgi/fare/util/"><tt>faketime</tt
></a
>.
</p
><p align="justify"><a name="footnote90"></a
><a href="#footnoteref90">[90]</a
>: 
Certaines machines antiques et même certaines moins antiques de chez IBM,
utilisent d'autres codes que le code ASCII.
Les machines de chez IBM utilisent notamment l'EBCDIC,
codage optimisé pour le système à cartes perforées
qui a fait la fortune du fondateur d'IBM au XIX<sup>e</sup
> siècle.
Nous jetterons un voile pudique sur de telles pratiques.
</p
><p align="justify">
Notons l'usage du programme <tt><font color="darkblue">recode(1)</font
></tt
> pour transcoder les caractères
entre les multiples codages existant.
</p
><p align="justify"><a name="footnote91"></a
><a href="#footnoteref91">[91]</a
>: 
Sous UNIX et les autres systèmes moderne, ASCII est omniprésent;
par contre, entre tous ces systèmes, les variantes d'ASCII sont nombreuses
pour gérer les caractères accentués et autres spécialités locales.
Dans les pays occidentaux comme le Luxembourg,
le codage sur 8-bit selon la norme ISO-8859-1 (Latin 1)
est le plus répandu, quoique le ISO-8859-15 (Latin 9)
est aussi utilisé depuis l'introduction de l'EURO.
Mais le codage sur taille variable UTF-8 de la norme ISO-10646-1 (Unicode)
s'implante lentement mais sûrement à l'échelle mondiale,
car il permet de traiter tous les caractères de tous les pays du monde.
</p
><p align="justify">
Le choix de la langue et du jeu de caractères affichable se fait principalement
(mais pas uniquement) via les variables d'environnement définissant la <tt><font color="darkblue">locale(1)</font
></tt
>.
</p
><p align="justify"><a name="footnote92"></a
><a href="#footnoteref92">[92]</a
>: 
Ceux qui connaissent cette spécificité française
reconnaîtront peut-être là le principe familiarisé par le minitel.
</p
><p align="justify"><a name="footnote93"></a
><a href="#footnoteref93">[93]</a
>: 
Même quand on peut, par exemple avec le mode Tektronix de <code><font color="darkblue">xterm(1x)</font
></code
>,
c'est complexe de mise en &oelig;uvre pour un résultat décevant et pas portable,
donc personne n'utilise.
Il y a quand même des hacks sympathiques
comme <code><font color="darkblue">w3m-img</font
></code
> ou <code><font color="darkblue">aaview</font
></code
>,
chacun dans leur genre particulier.
</p
><p align="justify"><a name="footnote94"></a
><a href="#footnoteref94">[94]</a
>: 
Toutefois, la chose vaut en sens inverse:
la plupart des discours ne peuvent pas être traduits en graphiques.
Une interface entièrement graphique serait complètement inutilisable.
Le mode graphique est meilleur que le mode texte
<em>précisément</em
> par qu'on peut <em>aussi</em
> faire du texte,
et <em>en mieux</em
>
(avec fontes de diverses polices, taille, couleurs, etc.)
en mode dit «&nbsp;graphique&nbsp;».
</p
><p align="justify"><a name="footnote95"></a
><a href="#footnoteref95">[95]</a
>: 
Les terminaux X comme
<code><font color="darkblue">xterm</font
></code
>, <code><font color="darkblue">konsole</font
></code
>, <code><font color="darkblue">gnome-terminal</font
></code
>, <code><font color="darkblue">Eterm</font
></code
>, etc.
permettent de copier-coller à la souris.
Sous la console Linux, le démon <tt><font color="darkblue">gpm(8)</font
></tt
> aussi.
Sinon, <tt><font color="darkblue">screen(1)</font
></tt
> ou <tt><font color="darkblue">emacs(1)</font
></tt
>
permettent de copier-coller au clavier.
</p
><p align="justify">
La configuration est pénible et malaisé,
se faisant en partie dans les paramètres de chaque application,
en partie dans les variables d'environnement
(et donc dans les fichiers de démarrage du shell),
en partie dans divers fichiers systèmes,
qui peuvent varier d'une distribution à l'autre.
</p
><p align="justify"><a name="footnote96"></a
><a href="#footnoteref96">[96]</a
>: 
Normalement, <code><font color="darkblue">TERM</font
></code
> est géré automatiquement par Linux.
Toutefois, il peut y avoir des problèmes quand vous vous loguez
sur Linux depuis une machine dont le terminal est mal configuré,
ou quand vous vous loguez depuis Linux (ou autre)
sur une machine mal configurée dont vous n'êtes pas administrateur.
Le terminal de référence: <code><font color="darkblue">export TERM=vt100</font
></code
>.
Le terminal le plus stupide possible: <code><font color="darkblue">export TERM=dumb</font
></code
>.
Entre les deux, consultez le fichier <code><font color="darkblue">/etc/termcap</font
></code
>,
ou sa version sur Internet. 
Si votre terminal n'est pas reconnu par le système distant
où vous vous loguez sans être administrateur,
configurer la variable <code><font color="darkblue">$TERMINFO</font
></code
> ou <code><font color="darkblue">$TERMCAP</font
></code
>
selon ce qu'utilise ledit système,
voire recompiler votre propre sous-système GNU avec <tt><font color="darkblue">terminfo(1)</font
></tt
>, etc.
</p
><p align="justify"><a name="footnote97"></a
><a href="#footnoteref97">[97]</a
>: 
Si un programme qui sait d'habitude gérer la taille de la fenêtre du terminal
n'a pas pris conscience qu'elle a changé, on peut lui envoyer le signal
<code><font color="darkblue">SIGWINCH</font
></code
> avec <code><font color="darkblue">kill -WINCH $PID</font
></code
>.
Voir aussi les options <code><font color="darkblue">rows</font
></code
>, <code><font color="darkblue">columns</font
></code
> et <code><font color="darkblue">-a</font
></code
> de <code><font color="darkblue">stty</font
></code
>.
</p
><p align="justify"><a name="footnote98"></a
><a href="#footnoteref98">[98]</a
>: 
Ainsi, sous Debian, le fichier <code><font color="darkblue">/etc/environment</font
></code
>
est consulté par d'aucuns scripts de <code><font color="darkblue">/etc/init.d</font
></code
>
qui l'utilisent pour initialiser la console.
<tt><font color="darkblue">grep(1)</font
></tt
> est votre ami pour trouver lesquels.
</p
><p align="justify"><a name="footnote99"></a
><a href="#footnoteref99">[99]</a
>: 
Truc marrant à essayer: on peut rattacher plusieurs fois la même session,
dans plusieurs fenêtres, par plusieurs personnes.
</p
><p align="justify"><a name="footnote100"></a
><a href="#footnoteref100">[100]</a
>: 
Solution: voir mon
<a href="http://fare.tunes.org/cgi-bin/viewcvs.cgi/etc/zsh/zshrc.tty"><code><font color="darkblue">zshrc.tty</font
></code
></a
>.
</p
><p align="justify"><a name="footnote101"></a
><a href="#footnoteref101">[101]</a
>: 
Les shells modernes sauvent l'état du terminal à chaque fois,
et s'ils utilisent pour eux-mêmes le mode cru,
ils remettront le mode que vous aurez défini
avec <code><font color="darkblue">stty</font
></code
> et autres programmes
quand vous exécutez des commandes externes.
</p
><p align="justify"><a name="footnote102"></a
><a href="#footnoteref102">[102]</a
>: 
Ces caractères sont configurables ou désactivables
via <tt><font color="darkblue">stty(1)</font
></tt
> ou l'équivalent par <tt><font color="darkblue">termios(3)</font
></tt
>.
Il est déconseillé que vous les modifiiez,
mais certains programmes interactifs le font,
et il faut savoir reconnaître la chose.
Emacs utilise notamment <tt><font color="brown">C-g</font
></tt
> au lieu de <tt><font color="brown">C-c</font
></tt
>
pour se faire envoyer le signal <code><font color="darkblue">SIGINT</font
></code
>.
</p
><p align="justify"><a name="footnote103"></a
><a href="#footnoteref103">[103]</a
>: 
Pour les trois slogans précédents, lire 
<a href="http://orwell.ru/library/novels/1984/index.htm"><i>1984</i
></a
> de George Orwell.
</p
><p align="justify"><a name="footnote104"></a
><a href="#footnoteref104">[104]</a
>: 
Il y a deux conventions principales pour les codes des touches
<tt><font color="brown">BackSpace</font
></tt
> et <tt><font color="brown">Delete</font
></tt
>.
Parfois, <tt><font color="brown">BackSpace</font
></tt
> est <tt><font color="brown">C-h</font
></tt
>,
et <tt><font color="brown">Delete</font
></tt
> est le code ASCII 127.
Parfois, <tt><font color="brown">BackSpace</font
></tt
> est <tt><font color="brown">C-?</font
></tt
>,
et <tt><font color="brown">Delete</font
></tt
> est le code ASCII 127.
Parfois, <tt><font color="brown">BackSpace</font
></tt
> est <tt><font color="brown">C-h</font
></tt
>,
et <tt><font color="brown">Delete</font
></tt
> est le caractère <tt><font color="brown">C-?</font
></tt
>.
Parfois, <tt><font color="brown">BackSpace</font
></tt
> est <tt><font color="brown">C-?</font
></tt
>,
et <tt><font color="brown">Delete</font
></tt
> est la séquence <tt><font color="brown">ESC [ 3 ~</font
></tt
>.
Bref, tout le monde n'est pas d'accord.
Normalement, l'intégrateur qui a préparé votre distribution
a choisi une convention et s'y est tenu.
Mais des programmes que vous installerez par la suite,
ou situés sur une machine distance, etc.,
pourraient n'être pas d'accord.
</p
><p align="justify"><a name="footnote105"></a
><a href="#footnoteref105">[105]</a
>: 
Pour des raisons historiques, dans les configurations des claviers PC.
la touche perçue par le système comme la touche <tt><font color="brown">Meta</font
></tt
>
est celle qui porte le symbole <tt><font color="brown">Alt</font
></tt
>.
La touche perçue par le système comme la touche <tt><font color="brown">Alt</font
></tt
>
est alors la touche (d'apparition plus récente) portant le symbole de Windows.
</p
><p align="justify"><a name="footnote106"></a
><a href="#footnoteref106">[106]</a
>: 
Le fait que la touche <tt><font color="brown">Meta</font
></tt
> soit enfoncée
est en général représenté par le terminal
en envoyant le caractère <tt><font color="brown">ESC</font
></tt
> (ASCII 27, hexadécimal 0x1B, octal 033)
avant la séquence habituelle de la touche.
Quoique parfois, dans de vieilles configurations
datant d'avant l'usage répandu des caractères accentués,
ça envoie le caractère avec le bit 8 changé.
</p
><p align="justify"><a name="footnote107"></a
><a href="#footnoteref107">[107]</a
>: 
Les vieux terminaux étaient 7-bit et n'acceptaient
que les caractères sans accents du jeu ASCII de base.
Du coup, les vieux programmes utilisaient parfois le huitième bit
pour quelques astuces diverses.
Les programmes modernes ne font pas ça.
Par contre, ils peuvent ne pas traiter correctement le caractère <tt><font color="brown">NUL</font
></tt
>
(de code ASCII 0), ou se comporter bizarrement avec d'autres caractères
(par exemple, shells scripts se plantant quand il y a des espaces
ou autres caractères spéciaux dans un nom de fichier, etc.).
</p
><p align="justify"><a name="footnote108"></a
><a href="#footnoteref108">[108]</a
>: 
Tous les terminaux ne laissent pas tout passer.
Un <tt><font color="darkblue">rlogin(1)</font
></tt
> ou <tt><font color="darkblue">ssh(1)</font
></tt
>
par défaut accepte des commandes spéciales
avec un <tt><font color="brown">~</font
></tt
> au début de la ligne.
Pour <tt><font color="darkblue">telnet(1)</font
></tt
> c'est plutôt <tt><font color="brown">C-]</font
></tt
>.
Pour un modem, c'est typiquement <tt><font color="brown">A T</font
></tt
> au début de la ligne,
éventuellement suivi d'une attente de trois secondes.
Avec les bonnes options, on peut désactiver tout cela.
Sans parler des séquences d'échappement, etc.,
qui font que certains caractères ne sont accessibles
qu'avec des séquences magiques.
</p
><p align="justify"><a name="footnote109"></a
><a href="#footnoteref109">[109]</a
>: 
Si problème de la configuration de Debian unstable,
pour le paquet <code><font color="darkblue"><i>foo</i
></font
></code
>, modifier <code><font color="darkblue">/var/lib/<code><font color="darkblue">foo</font
></code
>.*</font
></code
>.
Pour éviter tout tel désagrément, utiliser stable ou testing.
</p
><p align="justify"><a name="footnote110"></a
><a href="#footnoteref110">[110]</a
>: 
Pour les utilisateurs avancés:
si tout le reste échoue,
utiliser <code><font color="darkblue">strings <i>foo</i
> | less -p /etc</font
></code
> sur le binaire
ou observer le programme avec <tt><font color="darkblue">strace(1)</font
></tt
>.
Au pire, lire les sources.
</p
><p align="justify"><a name="footnote111"></a
><a href="#footnoteref111">[111]</a
>: 
<pre>useradd <i>toto</i
> -d /home/<i>toto</i
>
cp -a /mnt/cepl1/. /home/<i>toto</i
>/.
chown -R <code><font color="darkblue">toto</font
></code
> /home/<code><font color="darkblue">toto</font
></code
>
passwd <code><font color="darkblue">toto</font
></code
></pre
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote112"></a
><a href="#footnoteref112">[112]</a
>: 
Utiliser l'outil graphique <code><font color="darkblue">YaST2</font
></code
>,
ou utiliser interactivement <tt><font color="darkblue">addgroup(8)</font
></tt
> puis <tt><font color="darkblue">adduser(8)</font
></tt
>,
voire appeler <tt><font color="darkblue">groupadd(8)</font
></tt
> puis <tt><font color="darkblue">useradd(8)</font
></tt
>
avec la bonne ligne de commande.
sans oublier l'option <code><font color="darkblue">-m</font
></code
>.
Si vous voulez, vous pouvez aussi éditer à la main les fichiers
<tt><font color="darkblue">passwd(5)</font
></tt
> <tt><font color="darkblue">shadow(5)</font
></tt
> <tt><font color="darkblue">group(5)</font
></tt
> <tt><font color="darkblue">gshadow(5)</font
></tt
>
et dupliquer à la main une entrée.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote113"></a
><a href="#footnoteref113">[113]</a
>: 
<pre>groupadd cepl
useradd cepl1 -m -g cepl
</pre
></p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote114"></a
><a href="#footnoteref114">[114]</a
>: 
Sur les machines du LTC, il s'agit de
<code><font color="darkblue">nfs://172.16.141.0/suse/cd1</font
></code
>
jusqu'à
<code><font color="darkblue">nfs://172.16.141.0/suse/cd4</font
></code
>.
</p
><p align="justify"><a name="footnote115"></a
><a href="#footnoteref115">[115]</a
>: 
Je vous rappelle que pour savoir si un paquet est installé,
vous pouvez utiliser <code><font color="darkblue">rpm -qa | less -p <i>foo</i
></font
></code
>,
et que pour avoir des informations sur le paquet foo,
il y a <code><font color="darkblue">rpm -qi foo</font
></code
> et <code><font color="darkblue">rpm -ql foo</font
></code
>.
J'attire aussi votre attention sur l'option <code><font color="darkblue">-i</font
></code
>
de <tt><font color="darkblue">less(1)</font
></tt
> et de <tt><font color="darkblue">grep(1)</font
></tt
>.
Si la page de manuel ne vous simplifiait pas la tâche,
vous pourriez aussi repérer tous les programmes du paquet ImageMagick avec
<code><font color="darkblue">rpm -ql ImageMagick | grep /bin</font
></code
>
de même que vous pouvez repérer les fichiers de configuration avec
<code><font color="darkblue">rpm -ql ImageMagick | grep /etc</font
></code
>.
</p
><p align="justify"><a name="footnote116"></a
><a href="#footnoteref116">[116]</a
>: 
Simple, petit, robuste, rapide, avec toutes les fonctionnalités essentielles,
<tt><font color="darkblue">xv(1)</font
></tt
> est un logiciel encore très pratique de nos jours,
même si le fait qu'il ne soit pas vraiment un logiciel libre
fait que son développement est arrêté depuis 1994,
et que cela se ressent quant à son interface.
</p
><p align="justify">
La documentation de <tt><font color="darkblue">xv(1)</font
></tt
> est dans un fichier PostScript
(à imprimer ou visionner avec <tt><font color="darkblue">gv(1)</font
></tt
>
ou l'un des logiciels cités dans la section précédente appropriée),
parfois distribuée dans un paquet à part &mdash;
dans la distribution Debian, le paquet <code><font color="darkblue">xv-doc</font
></code
>.
</p
><p align="justify">
Votre distribution vient sans doute avec de nombreux logiciels plus récents,
comme <tt><font color="darkblue">gimp(1)</font
></tt
>, Electric Eyes, etc.,
et bien sûr <tt><font color="darkblue">imagemagick(1)</font
></tt
> dont il est question plus loin.
</p
><p align="justify"><a name="footnote117"></a
><a href="#footnoteref117">[117]</a
>: 
Notez qu'on pourrait obtenir la fonctionnalité d'import
en combinant <tt><font color="darkblue">xwd(1)</font
></tt
> et <tt><font color="darkblue">convert(1)</font
></tt
>:
	<code><font color="darkblue">import toto.png</font
></code
> est équivalent à
	<code><font color="darkblue">xwd | convert xwd:- toto.png</font
></code
>.
</p
><p align="justify">
Cependant, 
sur ma station de travail,
la version de <tt><font color="darkblue">xwd(1)</font
></tt
> que j'utilise (issue de XFree86 4.3.0)
ne fonctionne pas sur l'écran entier quand je suis en mode TrueColor 16 bits.
Par contre, <tt><font color="darkblue">import(1)</font
></tt
> marche correctement;
il y a donc un bug de <tt><font color="darkblue">xwd(1)</font
></tt
>.
Bug que personne ne prend le temps de corriger
parce que personne n'utilise plus trop <tt><font color="darkblue">xwd(1)</font
></tt
>.
Mais si quelqu'un en ressentait le besoin,
il pourrait facilement corriger ce bug
(s'il existe encore à l'heure où vous lisez ces notes):
c'est un avantage des logiciels libres que si un bug vous dérange,
vous pouvez le corriger vous-même
ou le faire corriger par l'expert de votre choix
au prix du marché,
sans être en situation de dépendance face à un fournisseur
en situation de monopole de droit.
</p
><p align="justify"><a name="footnote118"></a
><a href="#footnoteref118">[118]</a
>: 
Un problème du format PNG était
qu'il n'est pas supporté par tous les anciens navigateurs:
il est reconnu par Netscape 4 et IE 4.5 (?), mais pas les versions antérieures.
De plus, on me dit que la transparence, qui est bien définie en PNG,
ne fonctionne pas avec Netscape 4, ni avec IE 5 (voire 6?)... à tester.
En tout cas, Mozilla et Konqueror n'ont pas de problème avec.
</p
><p align="justify"><a name="footnote119"></a
><a href="#footnoteref119">[119]</a
>: 
À cause de ce même brevet,
les systèmes libres ne livrent pas dans leur version de base
l'outil standard <tt><font color="darkblue">compress(1)</font
></tt
> des UNIX propriétaires,
remplacé par l'outil <tt><font color="darkblue">gzip(1)</font
></tt
>, de meilleure qualité.
Notez que <tt><font color="darkblue">gunzip(1)</font
></tt
> sait décomprimer
les fichiers produits par <tt><font color="darkblue">compress(1)</font
></tt
>.
Dans les années 1990, PKware a dû de même cesser de vendre
sont logiciel à succès PKARC et le remplacer par PKZIP.
<tt><font color="darkblue">gzip(1)</font
></tt
> et <tt><font color="darkblue">png(5)</font
></tt
> utilisent tous deux
le même algorithme de compression que PKZIP et son successeur WinZip,
qui a accédé au statut de standard de l'Internet avec la RFC 1951 de mai 1996.
</p
><p align="justify">
Le brevet est expiré depuis 2003 aux États-Unis,
où UNISYS dispose encore de 3 ans pour poursuivre
les personnes l'ayant utilisé sans sa permission.
En Europe, le brevet n'est pas encore expiré,
mais la situation légale est telle qu'il n'y aura sans doute pas poursuites.
Ailleurs dans le monde, il y a sans doute des pays où le brevet est valide.
Donc il n'est pas impossible
que vous ayiez un jour à faire une telle opération.
À moins qu'une opération similaire ne soit rendue nécessaire
à cause d'un autre brevet, comme celui sur les MP3
que vous aurez alors peut-être à transformer massivement en Ogg Vorbis, etc.
</p
><p align="justify">
De toute façon, c'est un acte symbolique fort
pour signifier votre refus de l'extorsion
que constitue les brevets logiciels.
(Sur ce dernier sujet, voir mon article
<a href="http://fare.tunes.org/articles/patents.html">Patents are an Economic Absurdity</a
>.)
</p
><p align="justify"><a name="footnote120"></a
><a href="#footnoteref120">[120]</a
>: 
Utiliser l'outil YaST2 pour faire le montage,
puis Konqueror pour faire la copie.
À la ligne de commande, utilisez <tt><font color="darkblue">mount(8)</font
></tt
> puis <tt><font color="darkblue">cp(1)</font
></tt
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote121"></a
><a href="#footnoteref121">[121]</a
>: 
<code><font color="darkblue">mount ltc-141-00:/home /mnt ;
cp -a /mnt/cepl1/tutoriel ~/</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote122"></a
><a href="#footnoteref122">[122]</a
>: 
<code><font color="darkblue">wget -r http://etna.int-evry.fr/COURS/UNIX/</font
></code
>
<br
/>
Notez toutefois que <tt><font color="darkblue">wget(1)</font
></tt
> est assez rudimentaire,
et que pour aspirer des sites nécessitant plus de subtilité,
l'outil <tt><font color="darkblue">w3mir(1)</font
></tt
> est plus configurable.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote123"></a
><a href="#footnoteref123">[123]</a
>: 
Utiliser l'outil <tt><font color="darkblue">find(1)</font
></tt
>, ou sous <tt><font color="darkblue">zsh(1)</font
></tt
>, le globbing.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote124"></a
><a href="#footnoteref124">[124]</a
>: 
bash: <code><font color="darkblue">find . -name '*.gif' -print</font
></code
> <br
/>
En fait, le <code><font color="darkblue">-print</font
></code
> est optionnel
sous les versions modernes de <tt><font color="darkblue">find(1)</font
></tt
>. <br
/>
zsh: <code><font color="darkblue">print -l **/*.gif</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote125"></a
><a href="#footnoteref125">[125]</a
>: 
Pour itérer, utiliser <code><font color="darkblue">for file in ... ; do ... ; done</font
></code
>. <br
/>
Plus délicat, pour récupérer la sortie d'un programme
comme argument d'une commande shell, utiliser <code><font color="darkblue">$(...)</font
></code
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote126"></a
><a href="#footnoteref126">[126]</a
>: 
<pre><font color="darkblue">
for file in $(find . -name '*.gif') ; do
  echo "Nous traiterons le fichier $file" ;
done</font
></pre
>
Sous zsh, ceci marche aussi:
<pre><font color="darkblue">
for file ( **/*.gif ) { echo "Nous traiterons le fichier $file" }
</font
></pre
>
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote127"></a
><a href="#footnoteref127">[127]</a
>: 
Le <code><font color="darkblue">g</font
></code
> final indique
qu'il ne faut pas s'arrêter au premier remplacement possible sur une ligne.
Sans cette option, la recherche et remplacement ne ferait qu'un seul
remplacement sur une ligne comportant plusieurs fois la chaîne <code><font color="darkblue">.gif</font
></code
>.
</p
><p align="justify"><a name="footnote128"></a
><a href="#footnoteref128">[128]</a
>: 
<pre><font color="darkblue">newfile=` echo $file | sed -e 's/\.gif$/.png/' `</font
></pre
>
Notez bien le <code><font color="darkblue">$</font
></code
> pour être sûr de remplacer une désinence.
En fait, il ne serait pas indispensable,
si vous êtiez sûr que <code><font color="darkblue">.gif</font
></code
>
n'apparaît pas ailleurs que dans le nom d'un fichier.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote129"></a
><a href="#footnoteref129">[129]</a
>: 
En fait, sur un shell non-antique, la commande
<code><font color="darkblue">newfile=${file//.gif/.png}</font
></code
>
effectuera le remplacement désiré avec une expression régulière.
</p
><p align="justify"><a name="footnote130"></a
><a href="#footnoteref130">[130]</a
>: 
On a l'effet de <code><font color="darkblue">b="$(basename $i $foo)"</font
></code
> avec
<code><font color="darkblue">temp="${i%$foo}" ; b="${temp##*/}"</font
></code
>
et de <code><font color="darkblue">d=$(dirname $i)</font
></code
> avec
<code><font color="darkblue">case $i in */*) d=${i%/*} ;; *) d=. ;; esac</font
></code
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote131"></a
><a href="#footnoteref131">[131]</a
>: 
Une erreur possible dans une telle opération est que le disque soit plein
ce qui aura pour effet que vous ne puissiez pas créer
les fichiers PNG, mais que vous puissiez effacer les fichiers GIF.
Le résultat d'une suppression inconditionnelle du fichier GIF
serait donc une perte pure et simple de vos données!
(Et le recours coûteux en temps à une sauvegarde,
si tant est que vous en avez une.)
</p
><p align="justify"><a name="footnote132"></a
><a href="#footnoteref132">[132]</a
>: 
(Encore une fois, cela marche tant que l'on connaît de quoi il s'agit,
qu'il n'y a pas de liens à conserver vers des GIFs externes,
car les images sur d'autres sites n'auront pas été converties,
ou de texte (comme cette phrase même!)
contenant des allusions spécifiques à des fichiers <code><font color="darkblue"><i>foo</i
>.gif</font
></code
>
par opposition à un simple pointeur vers une image locale.
</p
><p align="justify"><a name="footnote133"></a
><a href="#footnoteref133">[133]</a
>: 
Pour tester votre opération de remplacement par expression régulière
sur un fichier <code><font color="darkblue">foo</font
></code
>, vous pouvez utiliser
<code><font color="darkblue">sed -e '...' <i>foo</i
> | less</font
></code
>, voire mieux
<code><font color="darkblue">sed -e '...' <i>foo</i
> | diff -u - <i>foo</i
> | less</font
></code
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote134"></a
><a href="#footnoteref134">[134]</a
>: 
Une solution simple est <code><font color="darkblue">sed -e 's/\.gif/.png/'</font
></code
>.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote135"></a
><a href="#footnoteref135">[135]</a
>: 
Notez qu'en interactif, si <code><font color="darkblue">mv</font
></code
> est un alias pour <code><font color="darkblue">mv -i</font
></code
>,
vous devrez éviter l'alias avec <code><font color="darkblue">\mv</font
></code
>
ou appeler directement l'exécutable <code><font color="darkblue">/bin/mv</font
></code
>
(ou <code><font color="darkblue">=mv</font
></code
> avec zsh)
pour ne pas avoir à confirmer à chaque fois.
</p
><p align="justify"><a name="footnote136"></a
><a href="#footnoteref136">[136]</a
>: 
Pour éviter de faire de grosses bévues,
il vaut aussi mieux ne pas expérimenter avec des commandes
pendant que vous êtes logué comme <code><font color="darkblue">root</font
></code
>.
Comme dit le proverbe:
<i>il y a deux sortes d'administrateurs système,
ceux qui ont déjà fait une grosse connerie sur leur machine,
et ceux pour qui ça ne va pas tarder.</i
>
</p
><p align="justify"><a name="footnote137"></a
><a href="#footnoteref137">[137]</a
>: 
Rien de bien méchant, mais n'oubliez pas de faire un
<pre><font color="darkblue">echo 'PATH="$HOME/bin:$PATH"' &#62;&#62; ~/.bashrc</font
></pre
>
et de relancer un shell ou de faire <code><font color="darkblue">source ~/.bashrc</font
></code
>
pour que la modification soit prise en compte.
</p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><p align="justify"><a name="footnote138"></a
><a href="#footnoteref138">[138]</a
>: 
Voici une version du script:
<pre><font color="darkblue">#!/bin/sh

cd /home/test/tutoriel || exit 42

for gif in $(find . -name '*.gif') ;
do
   png=`echo "$gif" | sed -e 's/\.gif$/.png/'`
   convert $gif $png &#38;&#38;
   /bin/rm $gif
done

for html in $(find . -name '*.html') ;
do
   sed -e 's/.gif/.png/g' &#60; $html &#62; $html.new &#38;&#38;
   /bin/mv $html.new $html
done</font
></pre
>
</p
><p align="justify">
Vous pouvez le tester par exemple aussi dans un répertoire
avec une image <code><font color="darkblue">linux.gif</font
></code
> trouvée sur
<a href="http://images.google.com">Google Images</a
>
et le ficher <code><font color="darkblue">index.html</font
></code
> comme suit:
<pre><font color="darkblue">Voici une image: &#60;img src="linux.gif" alt="manchot linux"&#62;</font
></pre
>
</p
><p align="justify">
Avec zsh, on peut simplifier le script ainsi:
<pre><font color="darkblue">#!/bin/zsh -f
cd "$1" || { echo "Usage: $0 répertoire" &#62;&#38; 2 ; exit 42 }
for file in **/*.gif ; do
   convert $file ${file%.gif}.png &#38;&#38; \rm $file
done
for file in **/*.html ; do
   sed -e 's/\.gif/.png/g' &#60; $file &#62; $file.new &#38;&#38; \mv $file.new $file
done</font
></pre
>
</p
><p align="justify">
Zut! J'aurais dû déposer un brevet sur ce script,
et vendre ce brevet à UNISYS, pendant qu'il en était encore temps.
Amers regrets.
</p
><p align="justify"><a name="footnote139"></a
><a href="#footnoteref139">[139]</a
>: 
Avec <tt><font color="darkblue">bash(1)</font
></tt
>,
<pre><font color="darkblue">PROGRAMS="$(find ${PATH//:/} -xtype f -maxdepth 1 -perm +111)" ;
SCRIPTS="$(file $PROGRAMS | grep script | cut -d: -f1)" ;
SORTED="$(ls --sort=size --reverse $SCRIPTS)" ;
echo "$SORTED"| less</font
></pre
>
Passez au fichier suivant (next) avec <tt><font color="brown">:n</font
></tt
>
et au précédent (previous) avec <tt><font color="brown">:p</font
></tt
>.
Notez que vous auriez aussi pu utiliser
<code><font color="darkblue">SORTED=$(ls -lL $SCRIPTS | sort -k 5 | cut -c61-)</font
></code
>,
et que sous zsh, vous utiliserez plutôt:
<pre><font color="darkblue">PROGRAMS=( $(find $path -xtype f -maxdepth 1 -perm +111) );
SCRIPTS=( $(file $PROGRAMS | grep script | cut -d: -f1) ) ;
SORTED=( $(ls --sort=size --reverse $SCRIPTS)
print -l $SORTED | less )</font
></pre
></p
><p align="justify"><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/><br
/></p
><hr
/>

<font size="-1"><table width="100%"><tr><td align="left" width="25%"><a href="http://fare.tunes.org/">Faré Rideau</a
></td
><td align="center" width="50%"><b><a href="http://www.cepl.luCours CEPL.html">CEPL</a
></b
></td
><td align="right" width="25%">Site by <a href="http://fare.tunes.org/">Faré Rideau</a
> — <a href="http://fare.tunes.org/donate.html">Donate</a
>:
   <a href="bitcoin:1fareF6wCNYYiLPGmyQjrd3AQdHBb1CJ6">bitcoins</a
>
   <img alt="1fareF6wCNYYiLPGmyQjrd3AQdHBb1CJ6" valign="top" align="right" src="http://fare.tunes.org/files/pics/fare-btc1.png"
/>
   or
   <a href="https://paypal.com/">paypal</a
> to <tt>fahree&#64;gmail.com</tt
></td
></tr
></table
></font
></body></html>

