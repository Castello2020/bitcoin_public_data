http://spritesmods.com/?art=rpi_arcade&page=5
HTTP/1.1 200 OK
Date: Wed, 23 Jul 2014 15:42:56 GMT
Server: Apache/2.2.22 (Debian)
X-Powered-By: PHP/5.4.4-14+deb7u12
Vary: Accept-Encoding
Content-Encoding: gzip
Content-Length: 6271
Connection: close
Content-Type: text/html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>Sprites mods - Raspberry Pi micro arcade machine - Power supply</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="style/style-new.css" />
<link rel="stylesheet" type="text/css" href="style/print.css" media="print" />
<link type="application/rss+xml" rel="alternate" title="Sprites Mods" href="http://spritesmods.com/rss.php" />
</head>
<body>

<div id="header"><span id="sitename"><span id="sitenamebig">SpritesMods</span>.com</span><h1>Raspberry Pi micro arcade machine - Power supply</h1></div>


<div id="left">
<p />
<a href="?art=main">Welcome</a><br /><ul id="mainmenu"><li><a href="?art=hardware">Hardware stuff</a><ul id="submenu"><li><a href="?art=rpi_arcade">Raspberry Pi micro arcade machine</a></li><li><a href="?art=mcportal">USB Minecraft portal</a></li><li><a href="?art=gbamidi">GameBoy Advance as a MIDI synthesizer</a></li><li><a href="?art=spitft">Connecting an LCD to a non-video-capable Linux device</a></li><li><a href="?art=lineccdts">Scanner CCD touchscreen conversion</a></li><li><a href="?art=bwidow_fpga">Black Widow in an FPGA</a></li><li><a href="?art=imx233-ws2811">WS2812 LEDs controlled by an iMX233</a></li><li><a href="?art=magnmicrobots">Duplicating the SRI magnet micro-robots</a></li><li><a href="?art=thermchromclk">Thermochromic paint clock</a></li><li><a href="?art=engarde">En Garde, a classifying capacitive touch sensor</a></li><li><a href="?art=avrfmtx">AVR-based FM-transmitter</a></li><li><a href="?art=stdalonejtag">Standalone JTAG programmer</a></li><li><a href="?art=avrcpm">CP/M on an AVR</a></li><li><a href="?art=doorbell">Wav-playing doorbell</a></li><li><a href="?art=rgbwall">Wall-lighting with RGB-leds</a></li><li><a href="?art=t5325_satapex">Adding SATA and PCIE to a HP T5325 thin client</a></li><li><a href="?art=ftdinand">FT2232H NAND flash reader</a></li><li><a href="?art=virtwiibar">Virtual Wii Sensor-bar</a></li><li><a href="?art=quizbtn">Quizshow buttons on the cheap</a></li><li><a href="?art=macsearm">Macintosh SE/arm</a></li><li><a href="?art=ledboardsolari">Solari ledboard controller</a></li><li><a href="?art=jello3dprinter">3d Jello printer</a></li><li><a href="?art=inker">Electronic Stamp</a></li><li><a href="?art=wcterror">Toilet terror alert</a></li><li><a href="?art=ledfanclock">Clock using a fan and a LED</a></li><li><a href="?art=streeplijst">Electronic beer tallier</a></li><li><a href="?art=knock2open">Knock to open</a></li><li><a href="?art=mechctr">Mechanical webpage hitcounter</a></li><li><a href="?art=ddrmat">Stealth DDR-mat</a></li><li><a href="?art=yamaharenewed">CM: Yamaha Renewed</a></li><li><a href="?art=bristlebot">Controllable bristlebot</a></li><li><a href="?art=novemini">NoveMini</a></li><li><a href="?art=xpad">Real HID for Xbox-controller</a></li><li><a href="?art=ledmatrix">96x48 LED-board</a></li><li><a href="?art=ucboost">Run an uC from an AA-battery</a></li><li><a href="?art=rocketlogger">Rocket acceleration logger</a></li><li><a href="?art=autobaud">Automatic baudrate converter</a></li><li><a href="?art=wtcpled">Temperature led for Weller WTCPs</a></li><li><a href="?art=minimalism">Electronic minimalism</a></li><li><a href="?art=rgbledlamp">RGB ledlamp</a></li><li><a href="?art=vfdcontroller">Simple VFD-controller</a></li><li><a href="?art=whiteboard">Online whiteboard</a></li></ul></li><li><a href="?art=hacks">Hacks</a></li><li><a href="?art=software">Software</a></li><li><a href="?art=consoles">Console hacking</a></li><li><a href="?art=security">Security</a></li><li><a href="?art=nabaztag">Nabaztag</a></li><li><a href="?art=about">About Spritesmods</a></li></ul></div>

<div id="right">
<div id="righttop">
<p /><a href="?art=rpi_arcade&amp;page=1"><strong>Page 1</strong><br /></a>Intro<p /><a href="?art=rpi_arcade&amp;page=2"><strong>Page 2</strong><br /></a>Connecting an LCD<p /><a href="?art=rpi_arcade&amp;page=3"><strong>Page 3</strong><br /></a>A case<p /><a href="?art=rpi_arcade&amp;page=4"><strong>Page 4</strong><br /></a>Joystick, buttons, audio<p /><strong>Page 5</strong><br />Power supply<p /><a href="?art=rpi_arcade&amp;page=6"><strong>Page 6</strong><br /></a>Marquee<p /><a href="?art=rpi_arcade&amp;page=7"><strong>Page 7</strong><br /></a>End result (+ discussion / remarks)<p>
</p>
</div>
<div id="rightbottom">
<p>
Do you like my hacking? If so, please consider leaving something in the<br />
</p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_donations">
<input type="hidden" name="business" value="AWHK8LYRDDS3C">
<input type="hidden" name="lc" value="GB">
<input type="hidden" name="item_name" value="Spritesmods.com">
<input type="hidden" name="no_note" value="0">
<input type="hidden" name="cn" value="Remarks">
<input type="hidden" name="no_shipping" value="1">
<input type="hidden" name="rm" value="1">
<input type="hidden" name="return" value="http://spritesmods.com/?art=main&amp;thanks=1">
<input type="hidden" name="currency_code" value="EUR">
<input type="hidden" name="bn" value="PP-DonationsBF:donate.png:NonHosted">
<input type="image" src="http://spritesmods.com/donate.png" border="0" name="submit" alt="PayPal, de veilige en complete manier van online betalen.">
<!--
<img alt="" border="0" src="https://www.paypalobjects.com/nl_NL/i/scr/pixel.gif" width="1" height="1">
-->
</form>

<p>
Or use Bitcoins:<br />
<script src="btc/coin.js"></script>
<script>
CoinWidgetCom.go({
	wallet_address: "16wKm29FmTLmYSrDtBXB4zLYGsqfrTwcEC"
	, currency: "bitcoin"
	, counter: "count"
	, alignment: "bl"
	, qrcode: true
	, auto_show: false
	, lbl_button: "Donate"
	, lbl_address: "My Bitcoin Address:"
	, lbl_count: "donations"
	, lbl_amount: "BTC"
});
</script>
</p>


<p>
<br />Current contents:
<br />EUR181 (about $240.73) and a bunch of cool hardware.
</p>


<p>
Follow Spritesmods on <a href="http://twitter.com/SpritesMods">Twitter</a>!
</p>
</div>
</div>
<div id="center">
<p><h1>Power supply
</h1>
</p>
<!-- google_ad_section_start -->
<p>One of the disadvantages of having an arcade machine that small is that it usually 
doesn't stay in place: the best way to play is to pick it up and hold it in your hands,
with two digits controlling the joystick and buttons. The problem with the Raspberry 
Pi is that it needs 5V, and until now, I've fed it that using the mini-USB-input of the
serial-to-USB-converter board. This is less than ideal: the Raspberry Pi isn't specced
to run off any USB input voltage and can eat up more power than a USB port is specified
to deliver. Plus, having a USB-cable means it can get disconnected, resulting in file
system corruption.</p>

<p>I decided to build myself a nice battery powered 5V source. Because I didn't have any
battery compartments designed into the arcade cabinet case, I couldn't just throw
replacable AA-batteries against the problem... whatever batteries I chose had to 
remain inside the case while being used and while being recharged. That meant I
also had to devise a way to be able to replenish the power as soon as the arcade
machine was out of juice.</p>

<a href="http://meuk.spritesserver.nl/foto/foto/misc15/IMG_0877.JPG"><img src="http://meuk.spritesserver.nl/foto/foto/misc15/tmb-IMG_0877.JPG" /></a>
<p>I still had two Nokia BL-5J batteries lying around. They weren't exactly new anymore, 
but could still hold enough charge to allow the Raspberry Pi to run for a fair while.
These batteries also have some protection in them: you shouldn't be able to blow
them up by applying too high a voltage or running too much current through them.</p>

<p>That was something I could use, because I was planning on making the charger / 5V PSU
myself, with standard components. It would mean a mistake on my side has a much lower 
risk of blowing up the batteries and causing mishap. <strong>If you're going to build
this, at least make sure your batteries are protected too. Also, double-check your work.
And my schematics and code. Y'know what, if these warnings actually tell you something
new, don't build it at all. I'm not responsible for any mess-ups resulting from anything
on this page by the way.</strong> Also, if you're going to connect LiIons in parallel,
make sure they're charged to the same voltage first.</p>

<p>With that being said: here's the schematic:<br />
<img src="rpi_arcade/schem_full.png"><br />
A few notes about the parts: The LiIon is the two Nokia batteries (still with their 
protection circuits intact!) in parallel. The diodes are random 2A Schottkys I still
had. The mosfets come as two IRF9952s, which are a N-channel and a P-channel
mosfet in one package. Unfortunately, I have no idea what the specs of the coil are:
I just grabbed one that seemed powerful enough from my parts bin and it seems to do
the trick.</p>

<p>So, how does it work? It's not directly clear from the schematic, because some components
and lines are used multiple times over. Basically, the circuit has three modes of
operations: idle (off), generating 5V (on) and charging. The idle state is the easiest to
explain: the AVR will receive 3.7V from the batteries via the inductor, diode and 10 ohm resistor. It has
its IO set to levels where none of the mosfets are conducting, and will try to eat up
as little power as possible. Every second, it'll wake up to see if the power button has
been pressed or a charger is connected.</p>

<p>If the power button is pressed, the AVR will wake up and start generating and regulating
5V by means of a <a href="http://en.wikipedia.org/wiki/Boost_converter">boost converter</a>. 
It'll generate a square wave on PB4, basically letting currents flow like this:<br />
<img src="rpi_arcade/schem_5vgen.png"><br />
When PB4 is high, the current will run along the red line: from the battery through
the inductor (which will generate a magnetic field) via the mosfet to ground. As soon
as PB4 is made low again, the current will run along the green line: because the magnetic
field collapses, the coil will force a current from the battery through itself and the 
schottky diode into the 2200uF capacitor, charging it to a voltage above the battery voltage.
By varying the duty cycle, the AVR 
can adjust how quickly the capacitor charges. The AVR itself is powered using this capacitor:
aside from the 10 ohm resistor and 100nF capacitor (which form a low-pass filter, to
filter out spikes) the AVR is almost directly connected with its Vcc-pin to the
capacitor voltage. The ATTiny85 has a way to measure its own supply voltage and uses this
to make sure the voltage remains at 5 volts. As soon as the capacitor is filled enough,
the AVR will also lower PB0, making the connected mosfet convey the 5V to the Raspberry Pi,
which will happily boot.</p>

<p>If, on the other hand, 5V is detected on the USB-port, the device will go into
charging mode. In this mode, it'll charge the LiIon-battery by feeding it 500mA of
current or 4.2V of voltage, whatever is the highest.<br />
<img src="rpi_arcade/schem_charge.png"><br />
The AVR can detect the presence of a charger because the 10K resistor will lead the 
5V via the dotted line to PB1. This pin also is one input of the AVRs internal 
comparator. The other side of the comparator is connected to Vcc. As soon as the 
comparator detects a higher voltage on PB1, it knows a charger is connected and
will switch on a square wave on PB1. In this configuration, the device works as a 
<a href="http://en.wikipedia.org/wiki/Buck_converter">buck converter</a>,
with the power to the battery coming either from the 5V input (red line) or from
the collapse of the magnetic field in the inductor (green line). The AVR can regulate
the voltage generated by modifying the duty cycle of the square wave on PB1.</p>
<p>
To control the generated voltage in a correct way, the AVR will need to measure both
the battery voltage and the current through the battery. The current is measured by
grabbing the voltage over the 0.25 ohm shunt resistor. The voltage can be measured by
AD'ing the value on PB0.</p>
Measuring the battery voltage  needs a trick (just as measuring the 5V
line does when generating the power for the Raspberry Pi): the reference voltage in the
AVR is either 1.1V or 2.56V, which are both too low to measure the 4.2V battery 
voltage. PB0, however, can be used as a reference voltage, just like Vcc can. If that
reference is used to measure the 1.1V internal reference (which can be switched to be
an input), it's possible to measure voltages >2.56V without needing external resistor
dividers.</p>
<p>Two parts of the schematic haven't been explained yet. The first is the part around
the 3V6 zener diodes: this is a crowbar-like protection circuit. As soon as a voltage
of about 9V is detected on the 5V line (e.g. because of a bug in the code), the
mosfet will pull down the reset-line of the AVR, hopefully shutting down whatever process
let the voltage get that high. 9V may seem a bit high for a protection voltage, but
just one spike has to get that high; the average voltage probably is lower when that
happens.</p>
<p>The other part is the bit around the button and LED: this is a combined charge
indicator, power switch and soft-power-off. When charging, the AVR will blink the
LED, indicating how far the charging process is. When powered on, the Raspberry
Pi can detect if the button is pressed for a short while; the AVR will ignore this.
When the button is pressed for longer than 4 seconds, however, the AVR will immediately
shut down power to the Raspberry Pi. For this to work, the 'RPi poweroff' line
should be connected to Raspberri Pi GPIO30, and the 'power' program (included in the
download) should run.</p>
<p>This allows for a complete soft-power bootup and shutdown: Press the button once
to power on the Raspberry Pi. Go play a game. When done, press the button once more.
The Raspberry Pi will detect this and shut down. At the end of this process, it
will make the line to PB2 low, simulating a long press of the button; this will
cut the power to the Pi again. If something goes wrong, you can manually hold the
button for 4 seconds and perform a hard powerdown that way.</p>
<p>
All this logic still fits on a small PCB about as big as the batteries it takes care of:<br />
<a href="http://meuk.spritesserver.nl/foto/foto/misc15/IMG_0920.JPG"><img src="http://meuk.spritesserver.nl/foto/foto/misc15/tmb-IMG_0920.JPG" /></a>
</p>
<p>
The software for the AVR and the small daemon that watches for button presses and
can shutdown the power can be downloaded <a href="rpi_arcade/rpiliionpsu.tgz">here</a>.
</p>



<!-- google_ad_section_end -->
<p>	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- singlebigad -->
	<ins class="adsbygoogle"
	     style="display:inline-block;width:728px;height:90px"
	     data-ad-client="ca-pub-6055011648930388"
	     data-ad-slot="3668631373"></ins>
	<script>
	(adsbygoogle = window.adsbygoogle || []).push({});
	</script>
	</p><p id="prevnext"><a href="?art=rpi_arcade&amp;page=4">&laquo Prev</a>&nbsp;5&nbsp;<a href="?art=rpi_arcade&amp;page=6">Next &raquo;</a></p><br /><div class="copy">&copy; 2006-2013 Sprite_tm - <a href="?art=contact&amp;af=Raspberry Pi micro arcade machine">Contact</a></div></div>
</body>
</html>

