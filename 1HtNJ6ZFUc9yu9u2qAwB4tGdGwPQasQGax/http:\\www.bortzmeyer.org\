http://www.bortzmeyer.org/
HTTP/1.1 200 OK
Date: Thu, 24 Jul 2014 10:40:41 GMT
Server: Apache/2.2.22 (Debian)
Last-Modified: Wed, 23 Jul 2014 19:22:00 GMT
ETag: "23a5d-4c2fb-4fee141178600"
Accept-Ranges: bytes
Vary: Accept-Encoding
Content-Encoding: gzip
Link: <http://www.gnu.org/copyleft/fdl.html>; rel="license"; title="GFDL"
Connection: close
Content-Type: text/html; charset=UTF-8

<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="fr" lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Generated on tyrion on 2014-07-23T15:21 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="robots" content="noindex,follow"/>
<link rel="stylesheet" type="text/css" href="screen.css" media="screen"/>
<link rel="stylesheet" type="text/css" href="print.css" media="print"/>
<link rel="openid2.provider" href="https://openid.stackexchange.com/openid/provider">
<link rel="openid2.local_id" href="https://openid.stackexchange.com/user/ce28a43a-5060-423a-8574-25e24a8f096e">
<!-- TODO: add META tags from the text of the entry, for instance keywords ? -->
<link rel="alternate" type="application/atom+xml" title="Atom syndication feed - summaries" href="feed.atom" />
<link rel="alternate" type="application/atom+xml" title="Atom syndication feed - full content" href="feed-full.atom" />
<link rel="search"
           type="application/opensearchdescription+xml" 
           href="http://www.bortzmeyer.org/others/add-search-engine.xml"
           title="Blog Bortzmeyer" />
<link rel="author" href="http://www.bortzmeyer.org/static/moi.html"/>
<link rel="privacy-policy" href="/privacy-policy.html"/>
<title>
Blog Stéphane Bortzmeyer: Accueil

</title>
</head>

<body>

<div id="page-container">
<div id="masthead">
<div class="inside">
			<h1><a href="index.html">Mon blog</a></h1>
			<hr class="hide" />
</div>
</div>
<div id="outer-column-container">
<div id="inner-column-container">
<div id="source-order-container">
<div id="left-column">
<div id="leftmenu" class="inside">
<h3>Autres trucs</h3>
<p><a href="index.html">Accueil</a></p>
<p><a href="rfcs.html">Seulement les RFC</a></p>
<p><a href="ficheslecture.html">Seulement les fiches de lecture</a></p>
<p><a href="http://echoping.sourceforge.net/">echoping</a></p>
<p><a href="http://www.demaziere.fr/eve/">Ève</a></p>
<form action="/search"><p>Recherche dans ce blog : <input type="text" name="pattern" style="width:100%"/>
</p>
</form>
</div>
</div> <!-- End of left-column -->
<div id="middle-column">
<div class="inside">

<p>Ce blog n'a d'autre prétention que de me permettre de mettre à la
disposition de tous des petits textes que j'écris. On y parle surtout
d'informatique mais d'autres sujets apparaissent parfois.</p>

<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7290.txt">RFC 7290</a>: Test Plan and Results for Advancing RFC 2680 on the Standards Track</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : L. Ciavattone (AT&amp;T Labs), R. Geib
(Deutsche Telekom), A. Morton (AT&amp;T
Labs), M. Wieser (Technical University
Darmstadt)<br/>Pour information<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/ippm">ippm</a></b><br/>Première rédaction de cet article le 23 juillet 2014<br/></p><hr/>
<div class="para"><p>Le <a href="2680.html" class="rfc" title="Consultez l'analyse du RFC 2680">RFC 2680</a> normalise une
<b class="emphasis">métrique</b> utile à l'analyse des performances des
réseaux informatiques, le taux de perte de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Paquet%20(r%C3%A9seau)" title="Consultez l'article &quot;Paquet (réseau)&quot; de l'encyclopédie libre Wikipedia">paquets</a></b> (mesuré sur un aller simple). Pour
faire avancer ce <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> sur le chemin des normes,
pour qu'il accède au statut de « norme tout court », il faut une
évaluation : la description du RFC est-elle claire et complète ? Les
mises en œuvres logicielles sont-elles équivalentes ? C'est ce travail
d'évaluation que ce nouveau RFC documente.</p></div>
<div class="para"><p>Évaluer la norme d'une métrique est un peu plus compliqué
qu'évaluer un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Protocole%20de%20communication" title="Consultez l'article &quot;Protocole de communication&quot; de l'encyclopédie libre Wikipedia">protocole</a></b>. La méthode
traditionnelle à l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> pour évaluer un
protocole est de regarder si deux mises en œuvre différentes peuvent
interopérer. Pour une métrique, ce n'est pas possible et on utilise
donc une autre méthode, regarder si deux mises en œuvre différentes
d'une métrique, confrontées au même trafic, produisent des résultats
compatibles (pas forcément identiques : les mesures ne sont jamais
parfaitement précises).</p></div>
<div class="para"><p>Le groupe de travail <a href="https://tools.ietf.org/wg/ippm">IPPM</a> de
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> travaille depuis longtemps sur ce
problème d'avancement des métriques sur le chemin des normes. Les
principes de l'évaluation d'une métrique ont été décrits dans le <a href="6576.html" class="rfc" title="Consultez l'analyse du RFC 6576">RFC 6576</a> et ont déjà été mis en pratique dans le <a href="6808.html" class="rfc" title="Consultez l'analyse du RFC 6808">RFC 6808</a>, pour la métrique « délai d'acheminement
d'un paquet (en aller simple) ». L'idée de base est que, si deux
mesures, par des mises
en œuvre différentes, donnent des résultats suffisamment proches,
c'est que la métrique était correctement définie, claire et sans
ambiguité. Cette évaluation permet aussi de voir quelles options de la
métrique n'ont jamais été implémentées, et sont donc candidates à être
supprimées dans une future révision de la norme.</p></div>
<div class="para"><p>En suivant le même plan que le <a href="6808.html" class="rfc" title="Consultez l'analyse du RFC 6808">RFC 6808</a>,
voici donc l'évaluation du <a href="2680.html" class="rfc" title="Consultez l'analyse du RFC 2680">RFC 2680</a> en
pratique. La configuration de test est décrite en section 3 : les deux
mises en œuvre testées étaient un <a href="http://www.net-probe.com/">NetProbe</a> (ce qu'utilise <a href="http://ipnetwork.bgtmo.ip.att.net/pws/index.html">WIPM</a>),
utilisant des paquets <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b> avec une distribution
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Fonction%20p%C3%A9riodique" title="Consultez l'article &quot;Fonction périodique&quot; de l'encyclopédie libre Wikipedia">périodique</a></b> (<a href="http://www.rfc-editor.org/rfc/rfc3432.txt" class="rfc" title="Consultez le texte intégral du RFC 3432">RFC 3432</a>) ou de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Loi%20de%20Poisson" title="Consultez l'article &quot;Loi de Poisson&quot; de l'encyclopédie libre Wikipedia">Poisson</a></b> (<a href="2330.html" class="rfc" title="Consultez l'analyse du RFC 2330">RFC 2330</a>), et un
Perfas+ (description <a href="http://www.itg523.de/oeffentlich/01nov/Heidemann_QOS_Messverfahren.pdf">en
allemand</a>), également avec UDP. Dans les deux cas, on passait
par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Tunnel%20(r%C3%A9seau%20informatique)" title="Consultez l'article &quot;Tunnel (réseau informatique)&quot; de l'encyclopédie libre Wikipedia">tunnel</a></b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Layer%202%20Tunneling%20Protocol" title="Consultez l'article &quot;Layer 2 Tunneling Protocol&quot; de l'encyclopédie libre Wikipedia">L2TP</a></b> (<a href="3931.html" class="rfc" title="Consultez l'analyse du RFC 3931">RFC 3931</a>), pour dissimuler aux équipements intermédiaires les
adresses IP et ports des équipements de tests (autrement, le trafic
risquerait de passer par des chemins différents pour les deux
tests). À l'extrémité du tunnel, le trafic est renvoyé donc cela
permet d'avoir l'émetteur et le récepteur au même endroit, tout en
faisant une mesure unidirectionnelle sur une longue distance. Pour
introduire des phénomènes rigolos comme des pertes de paquet, un
émulateur <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/netem">Netem</a>
est installé sur une machine <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Fedora%20(Linux)" title="Consultez l'article &quot;Fedora (Linux)&quot; de l'encyclopédie libre Wikipedia">Fedora</a></b>, qui assure
la communication entre le tunnel et un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/R%C3%A9seau%20local%20virtuel" title="Consultez l'article &quot;Réseau local virtuel&quot; de l'encyclopédie libre Wikipedia">VLAN</a></b> où
se trouve l'équipement de test, via un lien
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Ethernet#Fast_Ethernet_.28100.C2.A0Mbit.2Fs.29" title="Consultez l'article &quot;Ethernet&quot; de l'encyclopédie libre Wikipedia">FastEthernet</a></b>. Les équipements testés ont envoyé
des flots à 1 et 10 p/s, avec des centaines de paquets, de tailles variables (de 64
à 500
octets). Le type-P (cf. <a href="2680.html" class="rfc" title="Consultez l'analyse du RFC 2680">RFC 2680</a>, section 2.8.1)
des paquets était « UDP avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Differentiated%20Services%20Code%20Point" title="Consultez l'article &quot;Differentiated Services Code Point&quot; de l'encyclopédie libre Wikipedia">DSCP</a></b> <i class="foreign" xml:lang="en">best
effort</i> » (de toute façon, l'encapsulation dans le tunnel
L2TP fait que ces bits DSCP ont probablement été ignorés).</p></div>
<div class="para"><p>La section 4 de notre RFC décrit
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/%C3%A9talonnage" title="Consultez l'article &quot;étalonnage&quot; de l'encyclopédie libre Wikipedia">étalonnage</a></b> (vérifier les horloges, par exemple).</p></div>
<div class="para"><p>On l'a dit, c'est bien joli de comparer deux programmes mais que
doit être le résultat de la comparaison ? Une égalité rigoureuse ? Ce
n'est pas possible. La section 5 indique les critères de comparaison :
on fait de l'<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Anderson%E2%80%93Darling%20test" title="Consultez l'article &quot;Anderson–Darling test&quot; de l'encyclopédie libre Wikipedia (en anglais)">ADK</a></b> avec un facteur de confiance à
0,95 (et de l'<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Goodness%20of%20fit" title="Consultez l'article &quot;Goodness of fit&quot; de l'encyclopédie libre Wikipedia (en anglais)">adéquation
à la loi de distribution</a></b>).</p></div>
<div class="para"><p>Enfin, après toutes ces précautions méthodologiques, la section 6
contient les résultats. Par exemple, en périodique, les deux systèmes
mesurés donnent des résultats largement compatibles mais, en distribution de
Poisson, les résultats sont tous juste acceptables. Les mesures ont
bien résisté à des tests comme celui du délai maximal d'attente (avant
de déclarer un paquet perdu) ou comme celui du désordonnement des
paquets (lorsqu'un paquet est tellement en retard qu'il arrive après
un paquet parti après).</p></div>
<div class="para"><p>Conclusions (section 7) : les deux mises en œuvre sont compatibles,
ce qui indique que le <a href="2680.html" class="rfc" title="Consultez l'analyse du RFC 2680">RFC 2680</a> est suffisamment
clair et précis. Le processus de test a toutefois noté quelques points
où le <a href="2680.html" class="rfc" title="Consultez l'analyse du RFC 2680">RFC 2680</a> pouvait être rendu plus clair
(sans compter les <a href="http://www.rfc-editor.org/errata_search.php?rfc=2680&amp;rec_status=15&amp;presentation=table">erreurs
connues du RFC</a>).</p></div>
<div class="para"><p>Pour les fanas, la section 10 rassemble toutes les commandes de
configuration des équipements qui ont été utilisées. Par exemple,
Netem a été configuré avec <b><a href="http://phpunixman.sourceforge.net/index.php/man/tc" title="Consultez la page de manuel Unix &quot;tc&quot; ">tc</a></b> (ici, pour ajouter un
retard variable et en prime 10 % de perte de paquets) :
</p><pre>
tc qdisc change dev eth1 root netem delay 2000ms 1000ms loss 10%
</pre></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7290.txt">Téléchargez le RFC 7290</a></p>
<br />
<a href="7290.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="fr">Un petit galop d'essai avec le système Haka (filtrage, sécurité, paquets, protocoles, etc)</h2><p>Première rédaction de cet article le 20 juillet 2014<br/></p><hr/><div xml:lang="fr">
<div class="para"><p>Le 10 juillet dernier, lors des <a href="https://2014.rmll.info/">RMLL</a> à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Montpellier" title="Consultez l'article &quot;Montpellier&quot; de l'encyclopédie libre Wikipedia">Montpellier</a></b>, j'ai eu le plaisir de participer à
l'« Atelier HAKA : un langage <i class="foreign" xml:lang="en">open source</i> [sic] de
sécurité réseau ». <a href="http://haka-security.org/">Haka</a> est un langage permettant d'analyser les
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Paquet%20(r%C3%A9seau)" title="Consultez l'article &quot;Paquet (réseau)&quot; de l'encyclopédie libre Wikipedia">paquets</a></b>, de réagir à certaines caractéristiques
des paquets et de générer des réponses diverses. Cela permet entre
autres de faire des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feux</a></b> très souples car
complètement programmables.</p></div>
<div class="para"><p><a href="http://haka-security.org/">Haka</a> est fondé sur
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Lua" title="Consultez l'article &quot;Lua&quot; de l'encyclopédie libre Wikipedia">Lua</a></b> et il faut donc un peu réviser ses
connaissances Lua avant de pratiquer l'atelier. (J'ai déjà écrit <a href="lua-sur-machine-generaliste.html" title="Consultez ce blog à propos de &quot;lua-sur-machine-generaliste&quot;">ici</a> et <a href="evolution-de-lua.html" title="Consultez ce blog à propos de &quot;evolution-de-lua&quot;">là</a> sur Lua et réalisé un <a href="unicode-to-sql">tout petit programme avec</a>.) Haka étend Lua
en ajoutant au langage de base des extensions permettant de tripoter
les paquets réseau facilement. Je ne vais pas vous faire un cours sur
Haka (il y en a <a href="http://doc.haka-security.org/haka/release/v0.1/doc/user/userindex.html">un
en ligne</a> et les transparents de l'atelier sont <a href="https://hakasecurity.files.wordpress.com/2014/07/haka-rmll-2014-slides.pdf">disponibles
en ligne</a>), juste documenter mon expérience.</p></div>
<div class="para"><p>L'atelier se faisait dans une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Machine%20virtuelle" title="Consultez l'article &quot;Machine virtuelle&quot; de l'encyclopédie libre Wikipedia">machine
virtuelle</a></b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Debian" title="Consultez l'article &quot;Debian&quot; de l'encyclopédie libre Wikipedia">Debian</a></b> dans <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Oracle%20VM%20VirtualBox" title="Consultez l'article &quot;Oracle VM VirtualBox&quot; de l'encyclopédie libre Wikipedia">VirtualBox</a></b>. 
La machine virtuelle utilisée peut être téléchargée en <a href="https://hakasecurity.files.wordpress.com/2014/07/haka-live-iso.zip"><code>https://hakasecurity.files.wordpress.com/2014/07/haka-live-iso.zip</code></a>. (Je
n'ai pas encore essayé d'installer Haka moi-même.) Une
fois la machine démarrée, il faut faire un
<code>setxkbmap fr</code> dans un terminal pour passer en
AZERTY, le clavier par défaut étant QWERTY. Si vous éditez les sources
Lua avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Emacs" title="Consultez l'article &quot;Emacs&quot; de l'encyclopédie libre Wikipedia">Emacs</a></b>, notez qu'il n'y a pas de mode
Lua pour Emacs dans la machine virtuelle. Bon, on s'en passe, sinon,
on le télécharge avec <code>apt-get</code>. Les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/pcap" title="Consultez l'article &quot;pcap&quot; de l'encyclopédie libre Wikipedia">pcap</a></b>
d'exemple sont livrés avec la machine virtuelle, dans
<code>/opt/haka/share/haka/sample/hellopacket</code>.</p></div> 
<div class="para"><p>Premier exercice, s'entraîner aux bases de Haka et apprendre à
afficher certains paquets. Allons-y en Lua :
</p><pre>
-- On charge le dissecteur IPv4 (pas encore de dissecteur IPv6,
-- malheureusement ; un volontaire pour l'écrire ?)
local ip = require('protocol/ipv4')

-- Haka fonctionne en écrivant des *règles* qui réagissent à des
-- *évènements*, ici, l'évènement est le passage d'un paquet IPv4
haka.rule{
    hook = ip.events.receive_packet,
    -- Suit une série d'actions, qui reçoivent un paramètre qui dépend
    -- du dissecteur. Le dissecteur IPv4 passe à l'évènement
    -- receive_packet un paquet.
    eval = function (pkt)
        haka.log("Hello", "packet from %s to %s", pkt.src, pkt.dst)
    end
}
</pre><p>
Et comment on a trouvé que les champs de <code>pkt</code> qui
contenaient les adresses IP source et destination se nommaient
<code>src</code> et <code>dst</code> ? On a lu <a href="http://doc.haka-security.org/haka/release/v0.1/modules/protocol/ipv4/doc/lua.html#dissector">la
doc</a> (également disponible dans la machine virtuelle en
<code>/lib/live/mount/medium/haka/manual/modules/protocol/ipv4/doc/ipv4.html#dissector</code>). Il
existe aussi un mode interactif de Haka, permettant d'explorer les
paquets, pas montré ici.</p></div>
<div class="para"><p>Si on lance ce script Haka sur un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/pcap" title="Consultez l'article &quot;pcap&quot; de l'encyclopédie libre Wikipedia">pcap</a></b>
existant, il affiche :
</p><pre>
% hakapcap hellopacket.lua hellopcaket.pcap

info  core: load module 'packet/pcap.ho', Pcap Module
info  core: load module 'alert/file.ho', File alert
info  core: setting packet mode to pass-through

info  core: loading rule file 'hellopacket.lua'
info  core: initializing thread 0
info  dissector: register new dissector 'raw'
info  pcap:      opening file 'hellopacket.pcap'
info  dissector: register new dissector 'ipv4'
info  core:      1 rule(s) on event 'ipv4:receive_packet'
info  core:      1 rule(s) registered

info  core:      starting single threaded processing

info  Hello:     packet from 192.168.10.1 to 192.168.10.99
info  Hello:     packet from 192.168.10.99 to 192.168.10.1
info  Hello:     packet from 192.168.10.1 to 192.168.10.99
info  Hello:     packet from 192.168.10.1 to 192.168.10.99
info  Hello:     packet from 192.168.10.99 to 192.168.10.1
info  Hello:     packet from 192.168.10.1 to 192.168.10.99
info  Hello:     packet from 192.168.10.99 to 192.168.10.1
info  Hello:     packet from 192.168.10.1 to 192.168.10.99
info  core:      unload module 'Pcap Module'
info  core:      unload module 'File alert'
</pre><p>
Ça a bien marché, chaque paquet du pcap a été affiché.
</p></div>
<div class="para"><p>Deuxième exercice, filtrage des paquets qui ne nous plaisent pas,
en l'occurrence, ceux qui viennent du méchant réseau
<code>192.168.10.0/27</code> :
</p><pre>
local ip = require('protocol/ipv4')

local bad_network = ip.network("192.168.10.0/27")

haka.rule{
    hook = ip.events.receive_packet,
    eval = function (pkt)
      -- On teste si le paquet appartient au méchant réseau
      if bad_network:contains(pkt.src) then
        -- Si oui, on le jette et on journalise
        haka.log("Dropped", "packet from %s to %s", pkt.src, pkt.dst)
	pkt:drop()
      -- Si non (pas de 'else') le paquet suit son cours
      end
   end
}
</pre><p>
Une fois lancé le script sur un pcap, on obtient :
</p><pre>
...
info  Dropped:   packet from 192.168.10.1 to 192.168.10.99
info  Dropped:   packet from 192.168.10.1 to 192.168.10.99
info  Dropped:   packet from 192.168.10.1 to 192.168.10.99
info  Dropped:   packet from 192.168.10.1 to 192.168.10.99
info  Dropped:   packet from 192.168.10.10 to 192.168.10.99
info  Dropped:   packet from 192.168.10.10 to 192.168.10.99
info  Dropped:   packet from 192.168.10.10 to 192.168.10.99
</pre><p>
Si vous regardez le pcap avec tcpdump, vous verrez qu'il y a d'autres
paquets, en provenance de 192.168.10.99 qui n'ont pas été jetés, car
pas envoyés depuis le méchant réseau :
</p><pre>
14:49:27.076486 IP 192.168.10.1 &gt; 192.168.10.99: ICMP echo request, id 26102, seq 1, length 64
14:49:27.076536 IP 192.168.10.99 &gt; 192.168.10.1: ICMP echo reply, id 26102, seq 1, length 64
14:49:28.075844 IP 192.168.10.1 &gt; 192.168.10.99: ICMP echo request, id 26102, seq 2, length 64
14:49:28.075900 IP 192.168.10.99 &gt; 192.168.10.1: ICMP echo reply, id 26102, seq 2, length 64
14:49:31.966286 IP 192.168.10.1.37542 &gt; 192.168.10.99.80: Flags [S], seq 3827050607, win 14600, options [mss 1460,sackOK,TS val 2224051087 ecr 0,nop,wscale 7], length 0
14:49:31.966356 IP 192.168.10.99.80 &gt; 192.168.10.1.37542: Flags [R.], seq 0, ack 3827050608, win 0, length 0
14:49:36.014035 IP 192.168.10.1.47617 &gt; 192.168.10.99.31337: Flags [S], seq 1811320530, win 14600, options [mss 1460,sackOK,TS val 2224052099 ecr 0,nop,wscale 7], length 0
14:49:36.014080 IP 192.168.10.99.31337 &gt; 192.168.10.1.47617: Flags [R.], seq 0, ack 1811320531, win 0, length 0
14:49:46.837316 ARP, Request who-has 192.168.10.99 tell 192.168.10.10, length 46
14:49:46.837370 ARP, Reply 192.168.10.99 is-at 52:54:00:1a:34:60, length 28
14:49:46.837888 IP 192.168.10.10.35321 &gt; 192.168.10.99.8000: Flags [S], seq 895344097, win 14600, options [mss 1460,sackOK,TS val 2224054805 ecr 0,nop,wscale 7], length 0
14:49:46.837939 IP 192.168.10.99.8000 &gt; 192.168.10.10.35321: Flags [R.], seq 0, ack 895344098, win 0, length 0
14:49:50.668580 IP 192.168.10.10 &gt; 192.168.10.99: ICMP echo request, id 26107, seq 1, length 64
14:49:50.668674 IP 192.168.10.99 &gt; 192.168.10.10: ICMP echo reply, id 26107, seq 1, length 64
14:49:51.670446 IP 192.168.10.10 &gt; 192.168.10.99: ICMP echo request, id 26107, seq 2, length 64
14:49:51.670492 IP 192.168.10.99 &gt; 192.168.10.10: ICMP echo reply, id 26107, seq 2, length 64
14:49:51.841297 ARP, Request who-has 192.168.10.10 tell 192.168.10.99, length 28
14:49:51.841915 ARP, Reply 192.168.10.10 is-at 52:54:00:30:b0:bd, length 46
</pre></div>
<div class="para"><p>Bon, jusqu'à présent, on n'a rien fait d'extraordinaire,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Netfilter" title="Consultez l'article &quot;Netfilter&quot; de l'encyclopédie libre Wikipedia">Netfilter</a></b> en 
aurait fait autant. Mais le prochain exercice est plus intéressant. On
va faire du filtrage <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b>. La documentation du dissecteur TCP nous apprend que le champ qui
indique le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Port%20(logiciel)" title="Consultez l'article &quot;Port (logiciel)&quot; de l'encyclopédie libre Wikipedia">port</a></b> de destination est
<code>dstport</code> :
</p><pre>
local ip = require('protocol/ipv4')

-- On charge un nouveau dissecteur
local tcp = require ('protocol/tcp_connection')

haka.rule{
    -- Et on utilise un nouvel évènement, qui signale un nouveau flot TCP
    hook = tcp.events.new_connection,
    eval = function (flow, pkt)
      -- Si le port n'est ni 22, ni 80...
      if flow.dstport ~= 22 and flow.dstport ~= 80 then
        haka.log("Dropped", "flow from %s to %s:%s", pkt.ip.src, pkt.ip.dst, flow.dstport)
	flow:drop()
      else	
        haka.log("Accepted", "flow from %s to %s:%s", pkt.ip.src, pkt.ip.dst, flow.dstport)
      end
   end
}
</pre><p>
Et on le teste sur un pcap :
</p><pre>
info  Accepted:  flow from 192.168.10.1 to 192.168.10.99:80
info  Dropped:   flow from 192.168.10.1 to 192.168.10.99:31337
info  Dropped:   flow from 192.168.10.10 to 192.168.10.99:8000
</pre><p>
Il y avait trois flots (trois connexions TCP) dans le pcap, une seule
a été acceptée.</p></div>
<div class="para"><p>Maintenant, fini de jouer avec des pcap. Cela peut être intéressant
(analyse de pcap compliqués en ayant toute la puissance d'un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Turing-complet" title="Consultez l'article &quot;Turing-complet&quot; de l'encyclopédie libre Wikipedia">langage de Turing</a></b>) mais je vous avais promis un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feu</a></b>. On va donc filtrer des paquets et des
flots vivants, en temps réel. On écrit d'abord le fichier de
configuration du <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Daemon%20(informatique)" title="Consultez l'article &quot;Daemon (informatique)&quot; de l'encyclopédie libre Wikipedia">démon</a></b> Haka :
</p><pre>
[general]
# Select the haka configuration file to use
configuration = "tcpfilter.lua"

# Optionally select the number of thread to use. 
#thread = 4

# Pass-through mode
# If yes, haka will only inspect packet
# If no, it means that haka can also modify and create packet
pass-through = no

[packet]
# Select the capture model, nfqueue or pcap
module = "packet/nfqueue"

# Select the interfaces to listen to
interfaces = "lo"
#interfaces = "eth0"

# Select packet dumping for nfqueue
#dump = yes
#dump_input = "/tmp/input.pcap"
#dump_output = "/tmp/output.pcap"

[log]
# Select the log module
module = "log/syslog"

[alert]
# Select the alert module
module = "alert/syslog"
</pre><p>
Le script est le même que dans l'essai précédent, il accepte
uniquement les connexions TCP vers les ports 22 ou 80. On lance le
démon (notez que celui-ci fera appel à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Netfilter" title="Consultez l'article &quot;Netfilter&quot; de l'encyclopédie libre Wikipedia">Netfilter</a></b> pour lui passer les paquets) :
</p><pre>
% sudo haka -c haka.conf --no-daemon
info  core: load module 'log/syslog.ho', Syslog logger
info  core: load module 'alert/syslog.ho', Syslog alert
info  core: load module 'alert/file.ho', File alert
info  core: load module 'packet/nfqueue.ho', nfqueue
info  nfqueue: installing iptables rules for device(s) lo
info  core:    loading rule file 'tcpfilter.lua'
info  core:    initializing thread 0
info  dissector: register new dissector 'raw'
info  dissector: register new dissector 'ipv4'
info  dissector: register new dissector 'tcp'
info  dissector: register new dissector 'tcp_connection'
info  core:      1 rule(s) on event 'tcp_connection:new_connection'
info  core:      1 rule(s) registered

info  core:      starting single threaded processing
</pre><p>
Et on tente quelques connexions (143 = <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Message%20Access%20Protocol" title="Consultez l'article &quot;Internet Message Access Protocol&quot; de l'encyclopédie libre Wikipedia">IMAP</a></b>) :
</p><pre>
info  Accepted:  flow from 127.0.0.1 to 127.0.0.1:80
info  Dropped:   flow from 127.0.0.1 to 127.0.0.1:143
info  Dropped:   flow from 127.0.0.1 to 127.0.0.1:143
info  Dropped:   flow from 127.0.0.1 to 127.0.0.1:143
</pre><p>
Et en effet, les clients IMAP vont désormais
<i class="foreign" xml:lang="en">timeouter</i>. 
Dès qu'on arrête le démon, avec un Control-C, IMAP remarche :
</p><pre>
% telnet 127.0.0.1 imap2
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
* OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE STARTTLS AUTH=PLAIN] Dovecot ready.
</pre><p>
J'ai beaucoup aimé la possibilité de journaliser ou de jeter un flot
TCP entier, pas en agissant paquet par paquet. Pour la partie
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b> au début de cet atelier, Haka a un
concurrent évident, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Scapy" title="Consultez l'article &quot;Scapy&quot; de l'encyclopédie libre Wikipedia">Scapy</a></b> (mêmes concepts mais
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Python%20(langage)" title="Consultez l'article &quot;Python (langage)&quot; de l'encyclopédie libre Wikipedia">Python</a></b> au lieu de Lua). Mais Scapy ne sait pas
gérer les flots TCP, il ne travaille que par paquet.
</p></div>
<div class="para"><p>Exercice suivant, le protocole du Web,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b>. On va modifier les pages
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Markup%20Language" title="Consultez l'article &quot;Hypertext Markup Language&quot; de l'encyclopédie libre Wikipedia">HTML</a></b> en vol (et vous comprendrez pourquoi il
faut toujours utiliser <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/HyperText%20Transfer%20Protocol%20Secure" title="Consultez l'article &quot;HyperText Transfer Protocol Secure&quot; de l'encyclopédie libre Wikipedia">HTTPS</a></b>).
Il faut changer haka.conf pour indiquer le nouveau script, <code>blurring-the-web.lua</code>.
D'abord, on se contente d'afficher les requêtes HTTP :
</p><pre>
local ip = require('protocol/ipv4')

-- On charge un nouveau dissecteur
local http = require ('protocol/http')

-- Pas d'indication du protocole supérieur dans TCP, seulement du
-- numéro de port, donc il faut être explicite
http.install_tcp_rule(80)

haka.rule{
    -- Et on utilise un nouvel évènement
    hook = http.events.request,
    eval = function (connection, request)
      haka.log("HTTP request", "%s %s", request.method, request.uri)
      -- Il faut être sûr que les données ne soient pas comprimées,
      -- pour que la modification ultérieure marche. On modifie donc
      -- la requête.
      request.headers['Accept-Encoding'] = nil
      request.headers['Accept'] = "*/*"
    end
}
</pre><p>
Haka fait beaucoup de choses mais il ne décomprime pas les flots
HTTP. Comme la compression est <a href="gzip-compression-apache.html" title="Consultez ce blog à propos de &quot;gzip-compression-apache&quot;">souvent utilisée sur le Web</a>, on
modifie les en-têtes de la requête pour prétendre qu'on n'accepte pas
la compression (cf. <a href="7231.html" class="rfc" title="Consultez l'analyse du RFC 7231">RFC 7231</a>, sections 5.3.4 et
5.3.2).</p></div>
<div class="para"><p>On lance maintenant le démon Haka avec ce nouveau script. Pour
tester que les requêtes du navigateur Web ont bien été modifiées, on
peut aller sur un site qui affiche les en-têtes de la requête comme
<code>http://www.bortzmeyer.org/apps/env</code>. Par défaut,
le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Mozilla%20Firefox" title="Consultez l'article &quot;Mozilla Firefox&quot; de l'encyclopédie libre Wikipedia">Firefox</a></b> de la machine virtuelle envoie :
</p><pre>
HTTP_ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
HTTP_ACCEPT_ENCODING: gzip, deflate
</pre><p>
alors qu'une fois le démon en route, on n'a plus que (mettre une
entrée de tableau à <code>nil</code> la détruit) :
</p><pre>
HTTP_ACCEPT: */*
</pre><p>
Attention au passage : Firefox peut maintenir des connexions TCP
persistantes avec le serveur HTTP. Si vous lancez Firefox
<b class="emphasis">avant</b> Haka, vous risquez de récupérer
fréquemment des :
</p><pre>
alert: id = 8
	time = Sat Jul 19 16:31:32 2014
	severity = low
	description = no connection found for tcp packet
	sources = {
		address: 127.0.0.1
		service: tcp/56042
	}
	targets = {
		address: 127.0.0.1
		service: tcp/80
	}
</pre><p>
C'est parce que Haka a vu passer des paquets d'une connexion TCP antérieure
à son activation et qu'il ne sait donc pas rattacher à un flot qu'il
suit. (C'est le problème de tous les filtres à état.)
</p></div>
<div class="para"><p>Attention aussi, Haka ne gère pas IPv6. Si on se connecte à un serveur Web
en indiquant son nom, on peut utiliser IPv6 (c'est le cas de
<code>http://localhost/</code> sur la Debian de la machine
virtuelle) et Haka ne verra alors rien. D'où l'option
<code>-4</code> de wget, pour tester :
</p><pre>
% wget -v -4 http://localhost/
...
# Haka affiche
info  HTTP request: GET /
</pre></div>
<div class="para"><p>Maintenant, on ne va pas se contenter d'observer, on modifie la
réponse HTTP en ajoutant du <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Feuilles%20de%20style%20en%20cascade" title="Consultez l'article &quot;Feuilles de style en cascade&quot; de l'encyclopédie libre Wikipedia">CSS</a></b> rigolo :
</p><pre>

local ip = require('protocol/ipv4')
local http = require ('protocol/http')

local re = require('regexp/pcre')

-- Ce CSS rend tout flou
local css = '&lt;style type="text/css" media="screen"&gt; * { color: transparent !important; text-shadow: 0 0 3px black !important; } &lt;/style&gt;'

http.install_tcp_rule(80)

-- Bien garder cette règle, pour couper la compression, qui est
-- activée par défaut sur beaucoup de serveurs
haka.rule{
    hook = http.events.request,
    eval = function (connection, request)
      haka.log("HTTP request", "%s %s", request.method, request.uri)
      request.headers['Accept-Encoding'] = nil
      request.headers['Accept'] = "*/*"
    end
}

-- Deuxième règle, pour changer la réponse
haka.rule{
    hook = http.events.response_data,
    options = {
        streamed = true,
    },
    eval = function (flow, iter)
      -- Chercher la fin de l'élément &lt;head&gt;
      local regexp = re.re:compile("&lt;/head&gt;", re.re.CASE_INSENSITIVE)
      local result = regexp:match(iter, true)
      -- Si on a bien trouvé un &lt;head&gt;
      if result then 
         result:pos('begin'):insert(haka.vbuffer_from(css))
      end
    end
}

</pre><p>
Et re-testons :
</p><pre>

% wget -O - -v -4 http://localhost/
--2014-07-19 16:41:48--  http://localhost/
Resolving localhost (localhost)... 127.0.0.1, 127.0.0.1
Connecting to localhost (localhost)|127.0.0.1|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 190 [text/html]
Saving to: `STDOUT'

 0% [                                               ] 0           --.-K/s              &lt;html&gt;&lt;head&gt;&lt;style type="text/css" media="screen"&gt; * { color: transparent !important; text-shadow: 0 0 3px black !important; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;
100%[==============================================&gt;] 190         --.-K/s   in 0s      

2014-07-19 16:41:48 (45.0 MB/s) - written to stdout [190/190]

</pre><p>
Le CSS a bien été inséré ! Et, avec un vrai site Web, on voit bien l'effet :
<!--
         This image uses HTTP content-negociation which, I know, fail
with MS Internet Explorer 5 and 6, which apparently sends a */*, thus
retrieving SVG files they do not how how to handle. Too bad for them.
       --><img src="images/blurred-web.png" alt=""/></p></div>
<div class="para"><p>Attention, le <code>haka.conf</code> indiqué ici n'écoute que
sur l'interface <code>lo</code>. Pour tester sur le Web en
grand, pensez à changer le <code>haka.conf</code> (et
rappelez-vous que Haka n'aura aucun effet sur les sites Web
accessibles en IPv6 comme <a href="http://www.ietf.org/"><code>http://www.ietf.org/</code></a>, si la
machine virtuelle a une connectivité IPv6).</p></div>
<div class="para"><p>Voilà, sur ce truc spectaculaire, ce fut la fin de l'atelier.  À noter que nous n'avons pas testé les performances de Haka, 
question évidemment cruciale pour des filtrages en temps réel. En première approximation, Haka semble bien plus rapide que Scapy pour les tâches d'analyse de pcap mais il faudra un jour mesurer sérieusement.</p></div>
</div>
<br />
<a href="haka.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7314.txt">RFC 7314</a>: Extension Mechanisms for DNS (EDNS) EXPIRE Option</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : M. Andrews (ISC)<br/>Expérimental<br/>Première rédaction de cet article le 18 juillet 2014<br/></p><hr/>
<div class="para"><p>L'enregistrement <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System" title="Consultez l'article &quot;Domain Name System&quot; de l'encyclopédie libre Wikipedia">DNS</a></b>
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System#SOA_record" title="Consultez l'article &quot;Domain Name System&quot; de l'encyclopédie libre Wikipedia">SOA</a></b> (<i class="foreign" xml:lang="en">Start Of Authority</i>) a
un champ <code>expire</code> qui indique au bout de combien de
temps un serveur esclave qui ne réussit pas à contacter le maître peut
arrêter de servir la zone. Si l'esclave a eu les données, non pas
directement du maître, mais d'un autre esclave, la durée d'expiration
peut ne pas être correcte. C'est ce (rare) problème que règle l'option
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/EDNS" title="Consultez l'article &quot;EDNS&quot; de l'encyclopédie libre Wikipedia">EDNS</a></b> <code>EXPIRE</code>.</p></div>
<div class="para"><p>En effet, il faut se rappeler que la distribution d'une zone DNS
depuis un serveur maître (le RFC utilise l'ancien terme de « serveur
primaire ») n'est pas forcément directe. On peut avoir un
maître qui envoie des données à un esclave, qui à son tour les envoie
à un autre esclave. Cela permet notamment davantage de robustesse (si le maître
n'est temporairement pas joignable depuis certains esclaves). Notez
que l'esclave ne sait même pas si la machine qui lui a envoyé les
données était un maître ou pas.</p></div>
<div class="para"><p>Si la période de validité donnée par le champ
<code>expire</code> du SOA (<a href="1035.html" class="rfc" title="Consultez l'analyse du RFC 1035">RFC 1035</a>,
section 3.3.13) vaut V et que le transfert de
l'esclave à un autre esclave prend place S secondes après le transfert
depuis le maître (les transferts ne sont pas forcément instantanés,
par exemple en cas de coupure réseau), la zone sera servie pendant V + S secondes et pas
seulement pendant V secondes. Pire, s'il existe une boucle dans le
graphe de distribution, la zone risque de ne jamais expirer, les
esclaves se rafraichissant mutuellement.</p></div>
<div class="para"><p>Personnellement, le problème me semble rare et de peu
d'importance. Il y a des tas d'autres choses plus urgentes à régler
dans le DNS. Mais, bon, c'est juste une expérience.</p></div>
<div class="para"><p>La nouvelle option de ce <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> dépend de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/EDNS" title="Consultez l'article &quot;EDNS&quot; de l'encyclopédie libre Wikipedia">EDNS</a></b> (<a href="6891.html" class="rfc" title="Consultez l'analyse du RFC 6891">RFC 6891</a>). Elle a
le numéro 9. Mise dans une requête (a priori une requête de type
SOA, AXFR ou IXFR), elle indique que le client DNS connait cette
option et voudrait sa valeur. Un serveur qui ne connait pas l'option
<code>EXPIRE</code> ne mettra pas l'option dans sa
réponse.</p></div>
<div class="para"><p>Par contre, un serveur qui connait cette option répondra avec une
option <code>EXPIRE</code> dans sa réponse. Elle comporte
quatre octets de données (comme pour le champ
<code>expire</code> du SOA), indiquant le nombre de secondes
de la période de validité. Si le serveur est un maître, il met
toujours dans cette option la valeur du champ
<code>expire</code> du SOA. S'il est un esclave, il met la
valeur actuelle de son compteur d'expiration. Ainsi, si le champ
<code>expire</code> du SOA vaut 7 200 secondes (2 heures) et
que le serveur secondaire reçoit une demande 30 minutes après le
transfert depuis le maître, il mettra 5 400 dans l'option EDNS
<code>EXPIRE</code> (120 minutes de validité moins les 30
minutes écoulées). C'est ainsi qu'on évite l'accumulation des périodes
de validité en cas de transfert indirect.</p></div>
<div class="para"><p>Un serveur esclave (le RFC utilise l'ancien terme de « serveur
secondaire ») qui utilise l'option, et qui reçoit une réponse lors
d'un transfert initial de la zone, devrait utiliser comme durée de
validité la valeur de l'option <code>EXPIRE</code> (et pas le
champ <code>expire</code> du SOA, sauf si ce champ a une
valeur inférieure à celle de l'option
<code>EXPIRE</code>). Cette durée de validité est ensuite mise
dans un compteur d'expiration qui décroît avec le temps. Pour les rafraichissements ultérieurs,
le serveur esclave doit également
utiliser comme durée de validité la valeur de l'option, sauf si le
compteur actuel a une valeur plus élevée. Par exemple, si le compteur
du secondaire dit que la zone est encore valable pour 4 500 secondes,
et qu'une réponse IXFR (<a href="1995.html" class="rfc" title="Consultez l'analyse du RFC 1995">RFC 1995</a>) contient une
option <code>EXPIRE</code> de valeur 9 300 secondes, alors le
compteur est mis à 9 300 secondes. Si l'option
<code>EXPIRE</code> avait valu 2 400 secondes, le compteur
n'aurait pas été modifié.</p></div>
<div class="para"><p>Une conséquence amusante de cette option est qu'elle permet de
savoir quand a eu lieu le dernier transfert de zone réussi, juste en
interrogeant un esclave. Cela peut être vu comme indiscret, mais cela
peut aussi être un outil de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Surveillance%20(informatique)" title="Consultez l'article &quot;Surveillance (informatique)&quot; de l'encyclopédie libre Wikipedia">supervision</a></b> très pratique.</p></div>
<div class="para"><p>Cette option est utilisable depuis <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Dig%20(programme%20informatique)" title="Consultez l'article &quot;Dig (programme informatique)&quot; de l'encyclopédie libre Wikipedia">dig</a></b>, à
partir de <a href="http://www.isc.org/blogs/bind-9-10-statistics-troubleshooting-and-zone-configuration/">la
version 9.10</a>. <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Wireshark" title="Consultez l'article &quot;Wireshark&quot; de l'encyclopédie libre Wikipedia">Wireshark</a></b> a récemment
<a href="https://code.wireshark.org/review/#/c/3101/">été modifié
pour</a> reconnaître cette option.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7314.txt">Téléchargez le RFC 7314</a></p>
<br />
<a href="7314.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7291.txt">RFC 7291</a>: DHCP Options for the Port Control Protocol (PCP)</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : M. Boucadair (France
Telecom), R. Penno, D. Wing
(Cisco)<br/>Chemin des normes<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/pcp">pcp</a></b><br/>Première rédaction de cet article le 15 juillet 2014<br/></p><hr/>
<div class="para"><p>Le protocole <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Port%20Control%20Protocol" title="Consultez l'article &quot;Port Control Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">PCP</a></b>, normalisé dans le <a href="6887.html" class="rfc" title="Consultez l'analyse du RFC 6887">RFC 6887</a> permet à la machine de M. Michu de
configurer un routeur/traducteur, par exemple pour lui demander de
laisser passer le trafic entrant vers un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Port%20(logiciel)" title="Consultez l'article &quot;Port (logiciel)&quot; de l'encyclopédie libre Wikipedia">port</a></b>
donné. La norme PCP ne précisait pas tellement comment le client était
censé trouver le serveur PCP. Dans certains cas, c'est trivial, c'est
le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/routeur" title="Consultez l'article &quot;routeur&quot; de l'encyclopédie libre Wikipedia">routeur</a></b> par défaut. Dans d'autres, il faut
d'autres mécanismes et c'est là que notre <a href="http://www.rfc-editor.org/rfc/rfc7291.txt" class="rfc" title="Consultez le texte intégral du RFC 7291">RFC 7291</a> est
utile : il normalise un moyen de découvrir le serveur PCP grâce à une
nouvelle option <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Dynamic%20Host%20Configuration%20Protocol" title="Consultez l'article &quot;Dynamic Host Configuration Protocol&quot; de l'encyclopédie libre Wikipedia">DHCP</a></b>.</p></div>
<div class="para"><p>Le mécanisme est le même pour DHCP <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b>
(<a href="3315.html" class="rfc" title="Consultez l'analyse du RFC 3315">RFC 3315</a>) ou DHCP <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv4" title="Consultez l'article &quot;IPv4&quot; de l'encyclopédie libre Wikipedia">IPv4</a></b>
(<a href="2131.html" class="rfc" title="Consultez l'analyse du RFC 2131">RFC 2131</a>). Pour DHCP IPv6, l'option est décrite
en section 3. Elle est nommée
<code>OPTION_V6_PCP_SERVER</code> et a le code 86 (mis dans
le <a href="http://www.iana.org/assignments/dhcpv6-parameters">registre IANA</a>). Suit une
liste d'adresses IPv6, qui sont celles d'un serveur PCP. S'il y a
plusieurs serveurs PCP, on met plusieurs occurrences de l'option
<code>OPTION_V6_PCP_SERVER</code>.</p></div>
<div class="para"><p>On note que c'est une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/adresse%20IP" title="Consultez l'article &quot;adresse IP&quot; de l'encyclopédie libre Wikipedia">adresse IP</a></b> et pas un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/nom%20de%20domaine" title="Consultez l'article &quot;nom de domaine&quot; de l'encyclopédie libre Wikipedia">nom de domaine</a></b> qui est utilisée pour identifier
le ou les serveur(s) PCP. Un nom de domaine aurait permis un niveau
d'indirection supplémentaire. Le sujet a donc fait l'objet d'une
certaine controverse au sein du groupe de travail PCP à
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> avant que le consensus se fasse sur
l'adresse IP.</p></div>
<div class="para"><p>Pour obtenir cette liste d'adresses, le client DHCP doit mettre
l'option <code>OPTION_V6_PCP_SERVER</code> dans sa requête et,
si le serveur DHCP connait des serveurs PCP, il mettra leur(s)
adresse(s) dans sa réponse.</p></div>
<div class="para"><p>Le mécanisme est quasiment le même en IPv4 (section 4), avec
l'option <code>OPTION_V4_PCP_SERVER</code> de code 158 (<a href="http://www.iana.org/assignments/bootp-dhcp-parameters/">registre IANA</a>). La
principale différence est le mécanisme utilisé pour mettre plusieurs
serveurs PCP (pas juste plusieurs adresses IP pour un serveur,
mais plusieurs serveurs) : en IPv6, on répétait l'option. En IPv4, on
envoie plusieurs listes dans la même réponse.</p></div>
<div class="para"><p>Donc, attention, aussi bien côté client que côté serveur, ce RFC
permet d'avoir plusieurs serveurs PCP, ayant chacun plusieurs adresses
IP. Par exemple, côté serveur, le mécanisme de configuration du
serveur (mettons son fichier de configuration) doit permettre de
distinguer les deux cas, afin de choisir le bon encodage. Si le
fichier de configuration permet de mettre un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Nom%20de%20domaine" title="Consultez l'article &quot;Nom de domaine&quot; de l'encyclopédie libre Wikipedia">nom de
domaine</a></b> pour le serveur PCP, et que le serveur DHCP, en
résolvant ce nom, trouve plusieurs adresses IP, il doit bien  les
mettre dans une seule option (en IPv6) ou une seule liste (IPv4).</p></div>
<div class="para"><p>Notez une différence entre IPv6 et IPv4 : un serveur DHCP
IPv6 peut retourner des adresses IPv4 (encodées selon la section
2.5.5.2 du <a href="4291.html" class="rfc" title="Consultez l'analyse du RFC 4291">RFC 4291</a>) dans sa réponse (cas d'un réseau purement
IPv6 mais qui reçoit une connectivité IPv4 via un mécanisme
spécifique), l'inverse n'étant pas vrai.</p></div>
<div class="para"><p>À noter que, dans le cas de 
<i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/multi-homing" title="Consultez l'article &quot;multi-homing&quot; de l'encyclopédie libre Wikipedia">multi-homing</a></b></i>, on peut
recevoir plusieurs serveurs PCP via des réponses DHCP différentes, sur
des liens réseau différents (par exemple un lien
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Wi-Fi%20(protocole%20de%20communication)" title="Consultez l'article &quot;Wi-Fi (protocole de communication)&quot; de l'encyclopédie libre Wikipedia">WiFi</a></b> et un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/3G" title="Consultez l'article &quot;3G&quot; de l'encyclopédie libre Wikipedia">3G</a></b>). Dans ce cas, la machine doit bien faire
attention à associer chaque serveur PCP à son réseau, pour ne
configurer que le bon serveur PCP correspondant à l'adresse qu'on veut utiliser.</p></div>
<div class="para"><p>Les praticiens noteront avec plaisir qu'il existe au moins <a href="http://tools.ietf.org/html/draft-boucadair-pcp-nat64-experiments-00#section-2.9">une
mise en œuvre documentée</a> (sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Fedora%20(Linux)" title="Consultez l'article &quot;Fedora (Linux)&quot; de l'encyclopédie libre Wikipedia">Fedora</a></b>).</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7291.txt">Téléchargez le RFC 7291</a></p>
<br />
<a href="7291.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7320.txt">RFC 7320</a>: URI Design and Ownership</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : M. Nottingham<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/appsawg">appsawg</a></b><br/>Première rédaction de cet article le 12 juillet 2014<br/></p><hr/>
<div class="para"><p>Ah, les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b>... Comme ces identificateurs
sont très souvent vus et manipulés par un grand nombre d'utilisateurs,
ils suscitent forcément des passions et des discussions sans fin. Ce
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> de bonne pratique s'attaque à un problème
fréquent : les applications ou extensions qui imposent des contraintes sur l'URI,
sans que cela soit justifié par le format de ces URI. Par exemple, on
voit des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Syst%C3%A8me%20de%20gestion%20de%20contenu" title="Consultez l'article &quot;Système de gestion de contenu&quot; de l'encyclopédie libre Wikipedia">CMS</a></b> imposer, au moment de
l'installation, que le CMS soit accessible par un URI commençant par
le nom du logiciel. S'il s'appelle Foobar, on voit parfois des
logiciels qui ne marchent que si l'URI commence par
<code>http://www.example.org/Foobar/</code>. Pourquoi est-ce
une mauvaise idée et que faudrait-il faire à la place ?</p></div>
<div class="para"><p>D'abord, l'argument d'autorité qui tue : la norme des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b>, le <a href="3986.html" class="rfc" title="Consultez l'analyse du RFC 3986">RFC 3986</a>, dit
clairement que la structure d'un URI est déterminé par son
<b class="emphasis">plan</b> (<i class="foreign" xml:lang="en">scheme</i> en anglais) et
que donc l'application n'a pas le droit d'imposer des règles
supplémentaires. Les deux seuls « propriétaires » sont la norme
décrivant le plan (qui impose une syntaxe, et certains éléments, par
exemple le nom du serveur avec le plan <code>http://</code>)
et l'organisation qui contrôle cet URI particulier (par exemple,
toujours pour <code>http://</code>, l'organisation qui
contrôle le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Nom%20de%20domaine" title="Consultez l'article &quot;Nom de domaine&quot; de l'encyclopédie libre Wikipedia">domaine</a></b> dans
l'URI). Imposer des règles, pour une application ou une extension, c'est violer ce
principe de propriété. (Il est formalisé dans <a href="http://www.w3.org/TR/2004/REC-webarch-20041215">une
recommandation du W3C</a>, section 2.2.2.1.)</p></div>
<div class="para"><p>Un exemple de structure dans les URI est l'interprétation du
chemin (<i class="foreign" xml:lang="en">path</i> en anglais) comme étant un endroit du
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/syst%C3%A8me%20de%20fichiers" title="Consultez l'article &quot;système de fichiers&quot; de l'encyclopédie libre Wikipedia">système de fichiers</a></b>. Ainsi, bien des serveurs
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b>, en voyant l'URI
<code>http://www.example.org/foo/bar/toto.html</code>,
chercheront le fichier en
<code>$DOCUMENT_ROOT/foo/bar/toto.html</code>. C'est une
particularité de la mise en œuvre de ce serveur, pas une obligation du
plan d'URI <code>http://</code>. Un autre exemple est
l'utilisation de l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Extension%20de%20nom%20de%20fichier" title="Consultez l'article &quot;Extension de nom de fichier&quot; de l'encyclopédie libre Wikipedia">extension du nom de fichier</a></b> comme moyen de
trouver le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Type%20MIME" title="Consultez l'article &quot;Type MIME&quot; de l'encyclopédie libre Wikipedia">type de média</a></b> de la ressource. (« Ça
se termine en <code>.png</code> ? On envoie le type
<code>image/png</code>. ») Ces deux cas ne violent pas
forcément le principe de propriété des URI car l'utilisateur, après
tout, choisit son serveur.</p></div>
<div class="para"><p>Mais, dans certains cas, l'imposition d'une structure (autre que
celle déjà imposée par la norme du plan d'URI) a des conséquences
néfastes :
</p><ul>
<li>Risque de collisions entre deux conventions différentes.</li>
<li>Risque d'instabilité si on met trop d'informations dans l'URI
(voir la section 3.5.1 du document « <i class="foreign" xml:lang="en">Architecture of the World Wide
Web, Volume One</i> », cité plus haut). Pour reprendre l'exemple
de l'extension du fichier, si on change le format de l'image de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Portable%20Network%20Graphics" title="Consultez l'article &quot;Portable Network Graphics&quot; de l'encyclopédie libre Wikipedia">PNG</a></b> en <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/JPEG" title="Consultez l'article &quot;JPEG&quot; de l'encyclopédie libre Wikipedia">JPEG</a></b>, l'URI
changera, ce qui <a href="http://www.w3.org/Provider/Style/URI.html">est néfaste</a>.</li>
<li>Rigidité accrue. Si un logiciel impose d'être installé en
<code>/Foobar</code> comme dans l'exemple au début, il
contraint les choix pour l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Administrateur%20syst%C3%A8mes" title="Consultez l'article &quot;Administrateur systèmes&quot; de l'encyclopédie libre Wikipedia">administrateur
système</a></b> (et si je veux des URI avec un chemin vide, genre
<code>http://foobar.example.org/</code>, je fais
quoi ?)</li>
<li>Risque que le client fasse des suppositions injustifiées. Si une
spécification décrit le paramètre <code>sig</code> comme étant
forcément une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Signature%20num%C3%A9rique" title="Consultez l'article &quot;Signature numérique&quot; de l'encyclopédie libre Wikipedia">signature cryptographique</a></b>, il y
a une possibilité qu'un logiciel client croit, dès qu'il voit un
paramètre de ce nom, que c'est une signature.</li>
</ul><p>
Donc, pour toutes ces raisons, notre RFC <b class="emphasis">déconseille
fortement</b> de rajouter des règles de structure dans les
URI. Ces règles diminuent la liberté du propriétaire de l'URI.</p></div>
<div class="para"><p>Qui risque de violer ce principe ? Les auteurs d'applications,
comme dans l'exemple Foobar plus haut, mais aussi des gens qui font
des extensions aux URI, par le biais de nouvelles spécifications (par
exemple pour mettre des signatures ou autres métadonnées dans
l'URI). En revanche, ce principe ne s'applique pas au propriétaire
lui-même, qui a évidemment le droit de définir ses règles pour la
gestion de ses URI (exemple : le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/webmestre" title="Consultez l'article &quot;webmestre&quot; de l'encyclopédie libre Wikipedia">webmestre</a></b> qui
crée un schéma de nommage des URI de son <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/site%20Web" title="Consultez l'article &quot;site Web&quot; de l'encyclopédie libre Wikipedia">site Web</a></b>). Et cela
ne s'applique pas non plus au cas où le propriétaire de l'URI reçoit
lui-même une délégation pour gérer ce site (par exemple, un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> qui crée un registre
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Assigned%20Numbers%20Authority" title="Consultez l'article &quot;Internet Assigned Numbers Authority&quot; de l'encyclopédie libre Wikipedia">IANA</a></b> et spécifie la structure des URI sous
<code>http://www.iana.org/</code> est dans son droit, l'IANA
agissant sur délégation de l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b>). Le principe
« bas les pattes » de ce RFC n'est pas technique : on n'interdit pas
de mettre de la structure dans les URI, on dit juste
<b class="emphasis">qui</b> a le droit de le faire.</p></div>
<div class="para"><p>Notre RFC reconnait que certaines normes IETF (non citées...)
violent ce principe, et appelle à profiter de la prochaine révision
pour les corriger.</p></div>
<div class="para"><p>La partie normative de notre RFC est la section 2. Elle explicite
le principe « bas les pattes » (« <i class="foreign" xml:lang="en">get off my lawn</i> »
dans le nom original du document en anglais...) D'abord, éviter de
contraindre l'usage d'un plan particulier. Par exemple, imposer
<code>http://</code> peut être trop contraignant, certaines
applications ou extensions pourraient marcher avec d'autres plans
d'URI comme par exemple <code>file://</code>.</p></div>
<div class="para"><p>D'autre part, si on veut une structure dans les URI d'un plan
particulier, cela doit être spécifié dans le document qui définit le
plan (<a href="7230.html" class="rfc" title="Consultez l'analyse du RFC 7230">RFC 7230</a> pour
<code>http://</code>, <a href="6920.html" class="rfc" title="Consultez l'analyse du RFC 6920">RFC 6920</a> pour
<code>ni:</code>, etc) pas dans une extension faite par
d'autres (« touche pas à mon plan »).</p></div>
<div class="para"><p>Les URI comprennent un champ « autorité » juste après le plan. Les
extensions ou applications ne doivent <b class="emphasis">pas</b> imposer
de contraintes particulières sur ce champ. Ainsi, pour
<code>http://</code>, l'autorité est un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Nom%20de%20domaine" title="Consultez l'article &quot;Nom de domaine&quot; de l'encyclopédie libre Wikipedia">nom de
domaine</a></b> et notre RFC ne permet pas qu'on lui mette des
contraintes (du genre « le premier composant du nom de domaine doit
commencer par <code>foobar-</code>, comme dans
<code>foobar-www.example.org</code> »).</p></div>
<div class="para"><p>Même chose pour le champ « chemin », qui vient après
l'autorité. Pas question de lui ajouter des contraintes (comme dans
l'exemple du CMS qui imposerait <code>/Foobar</code> comme
préfixe d'installation). La seule
exception est la définition des URI bien connus du <a href="5785.html" class="rfc" title="Consultez l'analyse du RFC 5785">RFC 5785</a>. Le <a href="6415.html" class="rfc" title="Consultez l'analyse du RFC 6415">RFC 6415</a> donne un exemple
d'URI bien connus, avec une structure imposée.</p></div>
<div class="para"><p>Autre conséquence du principe « bas les pattes » et qui est, il me
semble, plus souvent violée en pratique, le champ « requête »
(<i class="foreign" xml:lang="en">query</i>). Optionnel, il se trouve après le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/point%20d'interrogation" title="Consultez l'article &quot;point d'interrogation&quot; de l'encyclopédie libre Wikipedia">point d'interrogation</a></b> dans l'URI. Notre RFC
interdit aux applications d'imposer l'usage des requêtes, car cela
empêcherait le déploiement de l'application dans d'autres contextes
où, par exemple, on veut utiliser des URI sans requête (je dois dire
que mes propres applications Web violent souvent ce principe). Quant
aux extensions, elles ne doivent pas contraindre le format des
requêtes. L'exemple cité plus haut, d'une extension
hypothétique, qui fonctionnerait par l'ajout d'un paramètre
<code>sig</code> aux requêtes pour indiquer une signature est
donc une mauvaise idée. Une telle extension causerait des collisions
(applications ou autres extensions qui voudraient un paramètre de
requête nommé <code>sig</code>) et des risques de suppositions
injustifié (un logiciel qui se dirait « tiens, un paramètre
<code>sig</code>, je vais vérifier la signature, ah, elle est
invalide, cet URI est erroné »). Au passage, les préfixes n'aident
pas. Supposons qu'une extension, voulant limiter le risque de
collisions, décide que tous les paramètres qu'elle définit commencent
par <code>myapp_</code> (donc, la signature serait
<code>myapp_sig</code>). Cela ne supprime pas le risque de
collisions puisque le préfixe lui-même ne serait pas enregistré.</p></div>
<div class="para"><p>Sauf erreur, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Dotclear" title="Consultez l'article &quot;Dotclear&quot; de l'encyclopédie libre Wikipedia">Dotclear</a></b> gère bien cela, en
permettant, via les « méthodes de lecture »
<code>PATH_INFO</code> ou <code>QUERY_STRING</code>
d'avoir les deux types d'URI (sans requête ou bien avec).</p></div>
<div class="para"><p>Pourtant, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Markup%20Language" title="Consultez l'article &quot;Hypertext Markup Language&quot; de l'encyclopédie libre Wikipedia">HTML</a></b> lui-même fait cela, dans
<a href="http://www.w3.org/TR/1999/REC-html401-19991224">la norme
4.01</a>, en restreignant la syntaxe lors de la soumission d'un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/formulaire#En_informatique" title="Consultez l'article &quot;formulaire&quot; de l'encyclopédie libre Wikipedia">formulaire</a></b>. Mais c'était une mauvaise idée et
les futures normes ne devraient pas l'imiter.</p></div>
<div class="para"><p>Comme précédemment, les URI bien connus ont, eux, droit à changer
la syntaxe ou contraindre les paramètres puisque, d'une certaine
façon, l'espace sous <code>.well-known</code> est délégué à
l'IETF et n'est plus « propriété » de l'autorité.</p></div>
<div class="para"><p>Dernier champ de l'URI à étudier, l'identificateur de fragment (ce
qui est après le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Croisillon%20(signe)" title="Consultez l'article &quot;Croisillon (signe)&quot; de l'encyclopédie libre Wikipedia">croisillon</a></b>). Les définitions
d'un type de média (<a href="6838.html" class="rfc" title="Consultez l'analyse du RFC 6838">RFC 6838</a>) ont le droit de
spécifier la syntaxe d'un identificateur de fragment spécifique à ce
type de média (comme ceux du texte brut, dans le <a href="5147.html" class="rfc" title="Consultez l'analyse du RFC 5147">RFC 5147</a>). Les autres extensions doivent s'en abstenir.</p></div>
<div class="para"><p>Bon, assez de négativité et d'interdiction. Après les « faites pas
ci » et les « faites pas ça », la section 3 de notre RFC expose les
alternatives, les bonnes pratiques pour remplacer celles qui sont
interdites ici. D'abord, si le but est de faire des liens, il faut se
rappeler qu'il existe un cadre complet pour cela, décrit dans le <a href="5988.html" class="rfc" title="Consultez l'analyse du RFC 5988">RFC 5988</a>. Une application peut utiliser ce cadre pour
donner la sémantique qu'elle veut à des liens. Autre technique
rigolote et peu connue, les gabarits du <a href="6570.html" class="rfc" title="Consultez l'analyse du RFC 6570">RFC 6570</a>, qui permettent de gérer facilement le cas de données
spécifiques à l'application dans un URI.</p></div>
<div class="para"><p>Et, comme cité plusieurs fois, les URI bien connus du <a href="5785.html" class="rfc" title="Consultez l'analyse du RFC 5785">RFC 5785</a> sont un moyen de déclarer sa propre
structure sur des URI. Par contre, ils sont censés avoir un usage
limité (accéder à des métadonnées avant de récupérer une ressource) et ne sont pas un moyen générique d'échapper aux règles qui
nous dérangent !</p></div>

<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7320.txt">Téléchargez le RFC 7320</a></p>
<br />
<a href="7320.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7300.txt">RFC 7300</a>: Reservation of Last Autonomous System (AS) Numbers</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : J. Haas (Juniper
Networks), J. Mitchell (Microsoft
Corporation)<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/idr">idr</a></b><br/>Première rédaction de cet article le 11 juillet 2014<br/></p><hr/>
<div class="para"><p>Ce très court <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> réserve formellement deux
numéros d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Autonomous%20System" title="Consultez l'article &quot;Autonomous System&quot; de l'encyclopédie libre Wikipedia">AS</a></b>, 65535 et 4294967295, qui ne
doivent donc pas être alloués à un opérateur réseau.</p></div>
<div class="para"><p>Ces deux AS étaient déjà réservés en pratique mais cela n'avait pas
été documenté (au sens du <a href="6996.html" class="rfc" title="Consultez l'analyse du RFC 6996">RFC 6996</a>). Ils sont les derniers de leur plage (65535 est le
dernier des AS traditionnels sur 16 bits et 4294967295 le dernier des
AS sur 32 bits du <a href="6793.html" class="rfc" title="Consultez l'analyse du RFC 6793">RFC 6793</a>), d'où le titre de ce
RFC.</p></div>
<div class="para"><p>Pourquoi les réserver ? Pour 65535, c'est parce qu'il est déjà
utilisé dans des communautés <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Border%20Gateway%20Protocol" title="Consultez l'article &quot;Border Gateway Protocol&quot; de l'encyclopédie libre Wikipedia">BGP</a></b> bien connues
(<a href="http://www.rfc-editor.org/rfc/rfc1997.txt" class="rfc" title="Consultez le texte intégral du RFC 1997">RFC 1997</a> et <a href="http://www.iana.org/assignments/bgp-well-known-communities/">registre
IANA</a>, c'est le cas, par exemple, de <code>NO_EXPORT</code>, alias 65535:65281). Par contre, 4294967295 n'a pas de telles communautés
mais il est réservé au cas où on ait besoin d'un AS qui ne soit jamais
annoncé en BGP.</p></div>
<div class="para"><p>Donc, ces deux AS ne doivent <b class="emphasis">pas</b> être utilisés
sur l'Internet et ne seront donc jamais (si tout le monde respecte les
règles) dans un attribut BGP comme <code>AS_PATH</code>. Mais
ils peuvent servir à des usages pas encore définis et les programmes qui mettent en œuvre
BGP ne doivent donc pas interdire leur usage. Ils sont
désormais dans <a href="http://www.iana.org/assignments/as-numbers/">le registre IANA des
AS</a> et dans <a href="http://www.iana.org/assignments/iana-as-numbers-special-registry/">celui
des AS spéciaux</a>.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7300.txt">Téléchargez le RFC 7300</a></p>
<br />
<a href="7300.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7303.txt">RFC 7303</a>: XML Media Types</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : H. Thompson (University of Edinburgh), C. Lilley (W3C)<br/>Chemin des normes<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/appsawg">appsawg</a></b><br/>Première rédaction de cet article le 11 juillet 2014<br/></p><hr/>
<div class="para"><p>Voici la nouvelle norme décrivant les types
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multipurpose%20Internet%20Mail%20Extensions" title="Consultez l'article &quot;Multipurpose Internet Mail Extensions&quot; de l'encyclopédie libre Wikipedia">MIME</a></b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Extensible%20Markup%20Language" title="Consultez l'article &quot;Extensible Markup Language&quot; de l'encyclopédie libre Wikipedia">XML</a></b>, comme
<code>application/xml</code>. Elle remplace le <a href="http://www.rfc-editor.org/rfc/rfc3023.txt" class="rfc" title="Consultez le texte intégral du RFC 3023">RFC 3023</a>. Cette norme décrit aussi l'utilisation de
<code>+xml</code> comme suffixe pour des formats de données
fondés sur XML comme <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Text%20Encoding%20Initiative" title="Consultez l'article &quot;Text Encoding Initiative&quot; de l'encyclopédie libre Wikipedia">TEI</a></b>, avec son
<code>application/tei+xml</code>.</p></div>
<div class="para"><p><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Extensible%20Markup%20Language" title="Consultez l'article &quot;Extensible Markup Language&quot; de l'encyclopédie libre Wikipedia">XML</a></b> est une norme du
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/World%20Wide%20Web%20Consortium" title="Consultez l'article &quot;World Wide Web Consortium&quot; de l'encyclopédie libre Wikipedia">W3C</a></b> et n'est donc pas dans un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> mais dans un <a href="http://www.w3.org/XML/">document du W3C</a>. Lorsque des documents sont envoyés sur
l'Internet, ils sont souvent étiquetés avec un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Type%20MIME" title="Consultez l'article &quot;Type MIME&quot; de l'encyclopédie libre Wikipedia">type de média</a></b>, dit
aussi, pour des raisons historiques, type
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multipurpose%20Internet%20Mail%20Extensions" title="Consultez l'article &quot;Multipurpose Internet Mail Extensions&quot; de l'encyclopédie libre Wikipedia">MIME</a></b>. Pour XML, il existe cinq types,
<code>application/xml</code>, <code>text/xml</code>,
<code>application/xml-external-parsed-entity</code>,
<code>text/xml-external-parsed-entity</code> et
<code>application/xml-dtd</code>. Il existe aussi une
convention, formalisée dans le <a href="6838.html" class="rfc" title="Consultez l'analyse du RFC 6838">RFC 6838</a>, pour
les formats bâtis au-dessus de XML, comme <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Atom" title="Consultez l'article &quot;Atom&quot; de l'encyclopédie libre Wikipedia">Atom</a></b>
(<a href="4287.html" class="rfc" title="Consultez l'analyse du RFC 4287">RFC 4287</a>). On écrit les types de média pour ces
formats avec un <code>+xml</code> à la fin, indiquant ainsi
qu'un processeur XML généraliste pourra toujours en faire quelque
chose, même s'il ne connait pas ce format spécifique. Ainsi, Atom est
<code>application/atom+xml</code>. (Ces suffixes sont
désormais banals mais, à l'époque du <a href="http://www.rfc-editor.org/rfc/rfc3023.txt" class="rfc" title="Consultez le texte intégral du RFC 3023">RFC 3023</a>, ils étaient
contestés et l'annexe A du <a href="http://www.rfc-editor.org/rfc/rfc3023.txt" class="rfc" title="Consultez le texte intégral du RFC 3023">RFC 3023</a> contient une
justification détaillée, qui n'a pas été reprise dans ce nouveau <a href="http://www.rfc-editor.org/rfc/rfc7303.txt" class="rfc" title="Consultez le texte intégral du RFC 7303">RFC 7303</a>.)</p></div>
<div class="para"><p>Pour normaliser quelque chose à propos de XML, il faut d'abord se
pencher sur les problèmes d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Codage%20des%20caract%C3%A8res" title="Consultez l'article &quot;Codage des caractères&quot; de l'encyclopédie libre Wikipedia">encodage de
caractères</a></b>. Le modèle de caractères de XML est forcément
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unicode" title="Consultez l'article &quot;Unicode&quot; de l'encyclopédie libre Wikipedia">Unicode</a></b>.Les encodages de documents peuvent être
très divers, mais la norme Unicode n'en définit que trois,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/UTF-8" title="Consultez l'article &quot;UTF-8&quot; de l'encyclopédie libre Wikipedia">UTF-8</a></b>, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/UTF-16" title="Consultez l'article &quot;UTF-16&quot; de l'encyclopédie libre Wikipedia">UTF-16</a></b> et
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/UTF-32" title="Consultez l'article &quot;UTF-32&quot; de l'encyclopédie libre Wikipedia">UTF-32</a></b>. UTF-8 (<a href="3629.html" class="rfc" title="Consultez l'analyse du RFC 3629">RFC 3629</a>)
représente les caractères par une suite d'octets de longueur
variable. Il 
n'a qu'une seule sérialisation en octets possible. UTF-16 en a deux,
car il représente les caractères (enfin, ceux du
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unicode#Plan_multilingue_de_base_.28PMB.2C_0000_.C3.A0_FFFF.29" title="Consultez l'article &quot;Unicode&quot; de l'encyclopédie libre Wikipedia">PMB</a></b>) par des seizets. 
Selon qu'on mette l'octet de poids fort du seizet en premier ou en
dernier, on parle d'UTF-16 <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Endianness" title="Consultez l'article &quot;Endianness&quot; de l'encyclopédie libre Wikipedia">gros-boutien</a></b>
(<code>utf-16be</code> dans une déclaration XML) ou d'UTF-16
petit-boutien (<code>utf-16le</code>). Quant à UTF-32, qui est
le plus simple des encodages, car le plus uniforme (tout caractère
Unicode est représenté par quatre octets, codant son point de code), il a
quatre sérialisations possibles en théorie mais deux seulement sont
définies, <code>UTF-32BE</code>, gros-boutien, et
<code>UTF32-LE</code>, petit-boutien. UTF-32
est malheureusement peu déployé (qu'on ne me dise pas que c'est parce
qu'il prend plus de place : quatre octets par caractère, à l'époque où
on s'échange des vidéos <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Haute%20d%C3%A9finition" title="Consultez l'article &quot;Haute définition&quot; de l'encyclopédie libre Wikipedia">HD</a></b>, ce n'est rien). Ce
RFC déconseille désormais son usage. (Une bonne discussion des problèmes avec UTF-32 est dans
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=604317">ce rapport de bogue chez Mozilla</a>.)</p></div>
<div class="para"><p>La section 3 du RFC décrit toutes les recommandations actuelles
pour l'encodage des documents XML envoyés sur l'Internet. UTF-8 est
recommandé (et sans <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Indicateur%20d'ordre%20des%20octets" title="Consultez l'article &quot;Indicateur d'ordre des octets&quot; de l'encyclopédie libre Wikipedia">BOM</a></b> : il faut le retirer
si, par exemple, on convertit de l'UTF-16 en UTF-8). Les
producteurs/envoyeurs de XML devraient mettre un paramètre
<code>charset</code> (pour les protocoles qui ont ce
paramètre) et utiliser la déclaration XML (le truc qui commence
par <code>&lt;?xml version="1.0" encoding=...</code>)
lorsqu'ils utilisent autre chose qu'UTF-8.</p></div>
<div class="para"><p>Cela suppose qu'ils sachent exactement quel est l'encodage. Si on
envoie de l'XML et qu'on ne peut pas déterminer son encodage, il vaut
mieux ne rien dire que de raconter n'importe quoi. Le RFC note que
c'est particulièrement important pour les serveurs Web : avoir un
paramètre global pour tout le site qui indique un encodage est
dangereux, à moins qu'on puisse être absolument sûr que tous les
documents du site auront cet encodage. Le RFC recommande que cet
étiquetage soit configurable par l'utilisateur, pour qu'il puisse
l'adapter à ses fichiers (<code>AddDefaultCharset</code> et
<code>AddCharset</code> dans
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Apache%20HTTP%20Server" title="Consultez l'article &quot;Apache HTTP Server&quot; de l'encyclopédie libre Wikipedia">Apache</a></b>.)</p></div>
<div class="para"><p>Quant aux consommateurs de documents XML, ils doivent considérer le
BOM comme faisant autorité, et utiliser le paramètre
<code>charset</code> si le BOM est absent. Les consommateurs
qui comprennent le XML peuvent, s'il n'y a ni BOM, ni
<code>charset</code>, utiliser les techniques purement XML,
exposées dans la norme de ce format (en gros, utiliser la déclaration
par exemple <code>&lt;?xml version="1.0"
encoding="ISO 8859-1"?&gt;</code>. Il y a plein d'exemples en
section 8 du RFC. Par exemple, ce cas-ci :
</p><pre>

Content-Type: application/xml; charset=utf-8
...
&lt;?xml version="1.0" encoding="utf-8"?&gt;

</pre><p>
est trivial : tout le monde est d'accord, le document est en UTF-8 et
c'est explicite. En revanche, ce cas :
</p><pre>

Content-Type: application/xml; charset=iso-8859-1
...
&lt;?xml version="1.0" encoding="utf-8"?&gt;

</pre><p>
est pathologique : le type MIME dans l'en-tête HTTP et la déclaration
XML se contredisent. Ici, un logiciel respectueux des normes doit
traiter le document comme de l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ISO%208859-1" title="Consultez l'article &quot;ISO 8859-1&quot; de l'encyclopédie libre Wikipedia">ISO 8859-1</a></b>, le
type MIME ayant priorité (il n'y a pas de BOM, qui aurait une priorité
supérieure). Mais, évidemment, l'envoyeur n'aurait pas dû
générer ces informations incohérentes. Il vaut mieux ne pas envoyer de
<code>charset</code> que d'envoyer un incorrect (voir aussi
annexe C.2). Ainsi, dans ce troisième exemple :
</p><pre>

Content-Type: application/xml
...
&lt;?xml version="1.0"?&gt;

</pre><p>
il n'y a rien d'explicite : pas de BOM, pas de
<code>charset</code> dans le type MIME et pas d'encodage
indiqué dans la déclaration XML. Dans ce cas, puisque MIME ne dit
rien, on applique la règle XML : l'encodage par défaut en XML est UTF-8.</p></div>
<div class="para"><p>À noter que le transport le
plus utilisé pour XML, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b>, avait un encodage de
caractères par défaut, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ISO%208859-1" title="Consultez l'article &quot;ISO 8859-1&quot; de l'encyclopédie libre Wikipedia">ISO 8859-1</a></b> mais ce n'est
plus le cas depuis le <a href="7230.html" class="rfc" title="Consultez l'analyse du RFC 7230">RFC 7230</a>. Voir aussi le
<a href="6657.html" class="rfc" title="Consultez l'analyse du RFC 6657">RFC 6657</a> pour l'encodage par défaut des types <code>text/*</code>.</p></div>
<div class="para"><p>Assez fait d'encodage, place aux types MIME, sujet principal de ce
RFC. La section 4 donne leur liste :
</p><ul>
<li>Les documents XML eux-mêmes auront le type
<code>application/xml</code> ou
<code>text/xml</code>. Le RFC ne tranche pas entre les deux
possibilités, alors que ce choix a fait se déplacer beaucoup
d'électrons, lors des innombrables discussions sur le « meilleur »
type. (Le prédécesseur, le <a href="http://www.rfc-editor.org/rfc/rfc3023.txt" class="rfc" title="Consultez le texte intégral du RFC 3023">RFC 3023</a> recommandait <code>text/xml</code>.)</li>
<li>Les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Document%20Type%20Definition" title="Consultez l'article &quot;Document Type Definition&quot; de l'encyclopédie libre Wikipedia">DTD</a></b> auront le type
<code>application/xml-dtd</code>.</li>
<li>Les « entités externes analysées » (<i class="foreign" xml:lang="en">external parsed
entities</i>), sont de type
<code>application/xml-external-parsed-entity</code> ou
<code>text/xml-external-parsed-entity</code>. Si elles sont
par ailleurs des documents XML bien formés (ce qui n'est pas toujours
le cas), elles peuvent avoir les types <code>application/xml</code> ou
<code>text/xml</code>.</li>
<li>Les paramètres externes (<i class="foreign" xml:lang="en">external parameter
entities</i>) ont le même type que les DTD,
<code>application/xml-dtd</code>.</li>
</ul><p>
Ils sont tous mis dans le <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">registre IANA</a>
(cf. section 9 du RFC).
</p></div>
<div class="para"><p>Il y a aussi le suffixe <code>+xml</code> (section 4.2),
utilisant la notion de suffixe du <a href="6839.html" class="rfc" title="Consultez l'analyse du RFC 6839">RFC 6839</a>. Il a
vocation à être utilisé pour tous les formats XML. Si les concepteurs
de ce format ne veulent pas d'un traitement générique XML (un cas
probablement rare), ils doivent choisir un type MIME sans ce suffixe.</p></div>
<div class="para"><p>À noter que, si on envoie du XML en HTTP, le système de
négociation de contenu de HTTP ne prévoit pas de mécanisme pour dire
« j'accepte le XML, quel que soit le format ». Pas question de dire
<code>Accept: text/*+xml</code>, donc.</p></div>
<div class="para"><p>La section 5 décrit ensuite le cas des identificateurs de fragment
(le texte après le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Croisillon%20(signe)" title="Consultez l'article &quot;Croisillon (signe)&quot; de l'encyclopédie libre Wikipedia">#</a></b> dans un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b>, pour désigner une partie d'un
document). Ils sont décrits dans la section 3.5 du <a href="3986.html" class="rfc" title="Consultez l'analyse du RFC 3986">RFC 3986</a>. Pour le cas particulier de XML, on se sert de la
syntaxe <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/XPointer" title="Consultez l'article &quot;XPointer&quot; de l'encyclopédie libre Wikipedia">XPointer</a></b> pour écrire ces
identificateurs (pas exemple, <code>http://www.example.org/data.html#xpointer(/foo/bar)</code>).</p></div>
<div class="para"><p>Le document XML envoyé peut utiliser l'attribut
<code>xml:base</code> (section 6) pour spécifier un URI de
référence, utilisé pour construire des URI absolus à partir des
relatifs qu'on peut trouver dans le document XML (par exemple, lors de
l'inclusion d'un autre document XML).</p></div>
<div class="para"><p>Et les versions de XML (il existe actuellement deux versions
normalisées, 1.0 et 1.1) ? Voyez la section 7, qui précise que les
types MIME sont exactement les mêmes pour toutes les versions : un
analyseur XML doit utiliser les techniques XML (le champ
<code>version</code> dans la déclaration) pour identifier les
versions, pas les types MIME.</p></div>
<div class="para"><p>Enfin, si vous vous intéressez à la sécurité, voyez la section 10
qui résume rapidement les grandes questions de sécurité de
XML. D'abord, les documents XML étant souvent modulaires (un document
déclenche le chargement de paramètres ou d'entités XML externes, ou
encore de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Feuille%20de%20style" title="Consultez l'article &quot;Feuille de style&quot; de l'encyclopédie libre Wikipedia">feuilles de style</a></b>), la sécurité doit
prendre en compte <b class="emphasis">tous</b> les documents extérieurs et leur technique de
chargement. Si un document XML est chargé en
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/HyperText%20Transfer%20Protocol%20Secure" title="Consultez l'article &quot;HyperText Transfer Protocol Secure&quot; de l'encyclopédie libre Wikipedia">HTTPS</a></b> mais qu'il contient une référence HTTP à
une feuille de style <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Feuilles%20de%20style%20en%20cascade" title="Consultez l'article &quot;Feuilles de style en cascade&quot; de l'encyclopédie libre Wikipedia">CSS</a></b>, la sécurité de HTTPS
ne protégera pas cette dernière, alors qu'elle pourrait, par exemple, faire
disparaître certains des éléments XML (<code>display:
none;</code>...) Ainsi, beaucoup de documents XML se réfèrent à des
entités XML qui sont sur les serveurs du <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/World%20Wide%20Web%20Consortium" title="Consultez l'article &quot;World Wide Web Consortium&quot; de l'encyclopédie libre Wikipedia">W3C</a></b>,
sans se préoccuper d'analyser la sécurité desdits serveurs. Si la
définition de l'entité <code><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Tiret#Tiret_long" title="Consultez l'article &quot;Tiret&quot; de l'encyclopédie libre Wikipedia">mdash</a></b></code>
est remplacée par le texte de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Winnie%20l'ourson" title="Consultez l'article &quot;Winnie l'ourson&quot; de l'encyclopédie libre Wikipedia">Winnie l'ourson</a></b>, de drôles de résultats peuvent
survenir.</p></div>
<div class="para"><p>Il y a aussi des attaques par <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Attaque%20par%20d%C3%A9ni%20de%20service" title="Consultez l'article &quot;Attaque par déni de service&quot; de l'encyclopédie libre Wikipedia">déni de
service</a></b> : un document XML qui contient une référence à une
entité qui contient à son tour de nombreuses autres références, qui
contiennent chacune de nombreuses autres références, et ainsi de suite,
jusqu'au <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/d%C3%A9passement%20de%20pile" title="Consultez l'article &quot;dépassement de pile&quot; de l'encyclopédie libre Wikipedia">dépassement de pile</a></b>. (La forme la plus
triviale de l'attaque, où l'entité se référence elle-même, est
normalement empêchée par la prohibition de ces auto-références.)</p></div>
<div class="para"><p>Également d'un grand intérêt pratique, l'annexe C, sur les
questions opérationnelles. La situation actuelle, notamment pour
trouver l'encodage des caractères d'un document, n'est pas idéale. La
nouvelle règle sur les BOM (priorité sur le paramètre
<code>charset</code>) casse, en théorie, la compatibilité
mais, en pratique, n'aggrave pas la situation et devrait l'améliorer à
terme. Si on veut se simplifier la vie lors de l'envoi de XML, on le
met en UTF-8 : c'est l'encodage recommandé par défaut, et il se passe
de BOM. Si on n'utilise pas UTF-8, alors, il faut mettre un BOM.</p></div>
<div class="para"><p>Et le consommateur de XML ? Il lui suffit de regarder le BOM sinon
le <code>charset</code> sinon la déclaration XML. En suivant
ces règles simples, tout le monde devrait être heureux.</p></div>
<div class="para"><p>Depuis le <a href="http://www.rfc-editor.org/rfc/rfc3023.txt" class="rfc" title="Consultez le texte intégral du RFC 3023">RFC 3023</a>, la précédente norme, que s'est-il
passé ? L'annexe D résume les nombreux et sérieux changements. Les sous-types de <code>text</code> comme
<code>text/xml</code> ont vu leur définition alignée avec
celle du sous-type
d'<code>application</code>. <code>text/xml</code> est
donc désormais un simple synonyme de
<code>application/xml</code>, ce qui reflète la réalité des
mises en œuvre logicielles de XML. Le BOM est désormais prioritaire
sur le <code>charset</code>. D'autre part,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/XPointer" title="Consultez l'article &quot;XPointer&quot; de l'encyclopédie libre Wikipedia">XPointer</a></b> est désormais intégré. Et
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/UTF-32" title="Consultez l'article &quot;UTF-32&quot; de l'encyclopédie libre Wikipedia">UTF-32</a></b> est maintenant officiellement
déconseillé, au nom de l'interopérabilité.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7303.txt">Téléchargez le RFC 7303</a></p>
<br />
<a href="7303.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7304.txt">RFC 7304</a>: A method for mitigating namespace collisions</h2><p>Date de publication du RFC : Juillet 2014<br/>Auteur(s) du RFC : W. Kumari (Google)<br/>Pour information<br/>Première rédaction de cet article le 7 juillet 2014<br/></p><hr/>
<div class="para"><p>Il arrive parfois, lors de l'utilisation d'un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Nom%20de%20domaine" title="Consultez l'article &quot;Nom de domaine&quot; de l'encyclopédie libre Wikipedia">nom de
domaine</a></b>, qu'il y ait plusieurs noms qui correspondent à
l'intention exprimée par l'utilisateur humain (dans les milieux
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Corporation%20for%20Assigned%20Names%20and%20Numbers" title="Consultez l'article &quot;Internet Corporation for Assigned Names and Numbers&quot; de l'encyclopédie libre Wikipedia">ICANN</a></b>, c'est souvent appelé une
<b class="emphasis">collision</b>, terme brutal conçu pour faire peur). Par exemple, si
l'utilisateur dans une entreprise <code>example.com</code>
tape « <code>www.foobar</code> » dans son
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/navigateur%20Web" title="Consultez l'article &quot;navigateur Web&quot; de l'encyclopédie libre Wikipedia">navigateur Web</a></b>, peut-être comptait-il aller en
<code>http://www.foobar.example.com/</code> en comptant sur
le fait que le logiciel complètera (ce qu'on nomme une <i class="foreign" xml:lang="en">search
list</i>) mais peut-être aussi voulait-il aller en
<code>http://www.foobar/</code> (le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domaine%20de%20premier%20niveau" title="Consultez l'article &quot;Domaine de premier niveau&quot; de l'encyclopédie libre Wikipedia">TLD</a></b>
<code>.foobar</code> n'existe pas aujourd'hui mais, au rythme
où des TLD sont créés, cela pourrait arriver un jour). Dans ces
conditions, comment faire pour désambiguer ? Ce très court
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> décrit une méthode... et explique pourquoi
elle est fortement déconseillée.</p></div>
<div class="para"><p>Ce problème n'est pas spécifique aux <i class="foreign" xml:lang="en">search
lists</i>. On peut aussi l'avoir lorsque plusieurs espaces de
nommage sont utilisés, par exemple en cas de « <a href="racines-alternatives.html" title="Consultez ce blog à propos de &quot;racines-alternatives&quot;">racines alternatives</a> ». Les
partisans desdites racines écartent souvent le problème de
« collision » entre deux racines en disant « il suffira de demander à
l'utilisateur son choix ». Pourquoi est-ce une mauvaise idée (mon
intention était d'écrire « une idée idiote » mais le RFC dont je rends
compte est plus prudent) ?</p></div>
<div class="para"><p>La section 2 de notre RFC décrit la méthode et ses défauts : si le nom n'a qu'une
signification possible, on y va, sinon on présente à
l'utilisateur une liste des possibilités « vouliez-vous aller en
<code>http://www.foobar.example.com/</code> ou en
<code>http://www.foobar/</code> ? » et on lui demande de
choisir. On peut mémoriser ce choix, pour éviter de demander trop
souvent à l'utilisateur. Mes lecteurs techniques voient sans doute
immédiatement pourquoi cela ne peut pas marcher, mais ce RFC est conçu
à des fins pédagogiques, pour tordre le cou une bonne fois pour toutes
à cette fausse bonne idée, qui resurgit de temps en temps.</p></div>
<div class="para"><p>Quels sont les problèmes avec cette approche (si vous êtes
enseignant en informatique, vous pouvez faire de cette question un
sujet d'interrogation, pour voir si les étudiants ont bien compris les
réseaux) ?
</p><ul>
<li>Il n'y a pas toujours un humain disponible devant l'écran. Il y
a des serveurs fonctionnant automatiquement, et des applications qui
s'exécutent en arrière-plan (comme les mises à jour
périodiques).</li>
<li>L'humain peut ne pas savoir, notamment si le choix découle d'une
tentative de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/hame%C3%A7onnage" title="Consultez l'article &quot;hameçonnage&quot; de l'encyclopédie libre Wikipedia">hameçonnage</a></b> ou autre tentative
délibérée de l'induire en erreur.</li>
<li>Le délai supplémentaire pendant lequel l'utilisateur réfléchit
peut conduire l'application à renoncer.</li>
<li>Ces demandes perpétuelles peuvent être pénibles pour l'utilisateur (songez qu'une
seule page Web peut comporter des dizaines de noms de domaine).</li>
<li>Mémoriser les choix résoudrait partiellement le problème
précédent, mais créerait d'autres ennuis, par exemple en cas de
déplacement (si l'utilisateur se servait d'un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Ordinateur%20portable" title="Consultez l'article &quot;Ordinateur portable&quot; de l'encyclopédie libre Wikipedia">portable</a></b> et qu'il quitte les locaux de <code>example.com</code>).</li>
</ul></div>
<div class="para"><p>Bref, c'est une <b class="emphasis">mauvaise</b> solution et notre RFC la
déconseille.
Par contre, il ne propose pas d'alternative (il n'y en a pas de sérieuse).</p></div>
<div class="para"><p>Pous les informaticiens, notez que, question mise en œuvre technique d'une telle solution, on aurait
plusieurs possibilités : intercepter les requêtes de résolution de
noms dans un <i class="foreign" xml:lang="en">shim</i>, une mince couche logicielle
entre l'application et la bibliothèque de résolution de noms (c'est
ainsi que sont souvent mis en œuvre des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domaine%20de%20premier%20niveau" title="Consultez l'article &quot;Domaine de premier niveau&quot; de l'encyclopédie libre Wikipedia">TLD</a></b>
« alternatifs » comme <code><b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/.bit" title="Consultez l'article &quot;.bit&quot; de l'encyclopédie libre Wikipedia (en anglais)">.bit</a></b></code>
ou <code><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/.onion" title="Consultez l'article &quot;.onion&quot; de l'encyclopédie libre Wikipedia">.onion</a></b></code>) ou bien en
remplaçant complètement la bibliothèque de résolution de noms. On
pourrait encore mettre ce service dans le navigateur Web (ignorant les
problèmes des applications non-Web), ou dans un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Proxy" title="Consultez l'article &quot;Proxy&quot; de l'encyclopédie libre Wikipedia">relais</a></b> sur le trajet.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7304.txt">Téléchargez le RFC 7304</a></p>
<br />
<a href="7304.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7252.txt">RFC 7252</a>: Constrained Application Protocol (CoAP)</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : Z. Shelby (Sensinode), K. Hartke, C. Bormann (Universitaet Bremen TZI)<br/>Chemin des normes<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/core">core</a></b><br/>Première rédaction de cet article le 2 juillet 2014<br/></p><hr/>
<div class="para"><p>Le protocole <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Constrained%20Application%20Protocol" title="Consultez l'article &quot;Constrained Application Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">CoAP</a></b> n'est pas destiné aux
ordinateurs, ni même aux <i class="foreign" xml:lang="en">smartphones</i> mais principalement aux
petits engins, aux machines qui n'ont parfois qu'un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/microcontr%C3%B4leur" title="Consultez l'article &quot;microcontrôleur&quot; de l'encyclopédie libre Wikipedia">microcontrôleur</a></b> 8 bits pour tout processeur,
très peu de mémoire (cf. <a href="6574.html" class="rfc" title="Consultez l'analyse du RFC 6574">RFC 6574</a>) et qui, en prime, sont
connectées par des liens radio lents et peu fiables (les « LowPAN » des
<a href="4919.html" class="rfc" title="Consultez l'analyse du RFC 4919">RFC 4919</a> et <a href="http://www.rfc-editor.org/rfc/rfc4944.txt" class="rfc" title="Consultez le texte intégral du RFC 4944">RFC 4944</a>),
allant parfois à seulement quelques dizaines de kb/s. Pour de tels engins, les protocoles comme
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b> et <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b> sont trop
contraignants. CoAP est un « HTTP-like » (il reprend pas mal de termes
et de concepts
de HTTP, comme le modèle REST) mais spécialement conçu pour des applications M2M
(<i class="foreign" xml:lang="en">machine-to-machine</i>) dans des environnements à
fortes limitations matérielles.</p></div>
<div class="para"><p>Le succès de HTTP et notamment de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Representational%20State%20Transfer" title="Consultez l'article &quot;Representational State Transfer&quot; de l'encyclopédie libre Wikipedia">REST</a></b> a
sérieusement influencé les concepteurs de CoAP. Le modèle de CoAP est celui de HTTP : protocole
requête/réponse, verbes <code>GET</code>,
<code>POST</code>, <code>DELETE</code>, etc, des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b> et des types de media comme sur le Web
(<code>application/json</code>...) Cette proximité facilitera
notamment le développement de passerelles entre le monde des objets CoAP et le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/World%20Wide%20Web" title="Consultez l'article &quot;World Wide Web&quot; de l'encyclopédie libre Wikipedia">Web</a></b>
actuel (section 10). Une des pistes explorées
pour l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20des%20objets" title="Consultez l'article &quot;Internet des objets&quot; de l'encyclopédie libre Wikipedia">Internet des Objets</a></b> (terme
essentiellement marketing mais répandu) avait été de prendre de l'HTTP
normal et de comprimer pour gagner des ressources réseau mais CoAP
suit une autre voie : définir un protocole qui est essentiellement un
sous-ensemble de HTTP. Si vous connaissez HTTP, vous ne serez pas trop
perdu avec CoAP.</p></div>
<div class="para"><p>CoAP tournera sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b> (<a href="768.html" class="rfc" title="Consultez l'analyse du RFC 768">RFC 768</a>), TCP étant trop consommateur de ressources, et, si on
veut de la sécurité, on ajoutera <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Datagram%20Transport%20Layer%20Security" title="Consultez l'article &quot;Datagram Transport Layer Security&quot; de l'encyclopédie libre Wikipedia">DTLS</a></b> (<a href="6347.html" class="rfc" title="Consultez l'analyse du RFC 6347">RFC 6347</a>). CoAP fonctionne donc de manière asynchrone
(on lance la requête et on espère une réponse un jour). On pourrait
décrire CoAP comme composé de deux parties, un transport utilisant UDP
avec des extensions optionnelles si on veut de la fiabilité (accusés
de réception), et un langage des messages (requêtes et réponses en
<i class="foreign" xml:lang="en">HTTP-like</i>).</p></div>
<div class="para"><p>Et les messages ? L'en-tête CoAP (section 3 du RFC) a été conçu pour être facile à
analyser par des programmes tournant sur de petites machines. Au lieu du texte lisible de HTTP, l'en-tête de CoAP
commence par une partie fixe de quatre octets, qui comprend un
<i class="foreign" xml:lang="en">Message ID</i> de deux octets. Ce <i class="foreign" xml:lang="en">Message
ID</i> permet de détecter les duplicatas et d'associer un accusé
de réception à un message précis. À noter qu'avec ces deux octets, on
est limité à environ 250 messages par seconde (en raison du paramètre
<code>EXCHANGE_LIFETIME</code> qui est à 247 secondes par
défaut). Ce n'est pas une limite bien grave : les ressources
(en énergie, en capacité réseau, etc) des machines CoAP ne leur permettront pas
d'être trop bavardes, de toute façon.</p></div>
<div class="para"><p>Le message contient également un champ <i class="foreign" xml:lang="en">Token</i>
(utilisé pour mettre en correspondance les requêtes et les réponses, à
un niveau supérieur à celui des messages, qui sont, eux, identifiés
par le <i class="foreign" xml:lang="en">Message ID</i>) et un code sur huit bits. Ce
code s'écrit sous forme d'un groupe de trois chiffres, le premier
indiquant la classe (2 : succès, 4 : erreur du client, 5 : erreur du
serveur, etc) et suivi d'un point, et les deux autres chiffres fournissant des détails. Comme vous
connaissez HTTP, vous ne serez pas étonné d'apprendre que le code 4.03 indique un
problème de permission... Un <a href="http://www.iana.org/assignments/core-parameters/core-parameters.xhtml#response-codes">registre de ces
codes</a> existe.</p></div>
<div class="para"><p>Notez bien que l'encodage, lui, est radicalement différent de celui
de HTTP. Il est en binaire et le code 4.03 sera transmis sous forme
d'un octet (10000011, avec 100 pour la classe et 11 pour le détail),
pas sous forme de la chaîne de caractères qu'utilise HTTP.</p></div>
<div class="para"><p>Le message contient ensuite des options, qui jouent le rôle des
en-têtes de requête de HTTP (leur liste est également
<a href="http://www.iana.org/assignments/core-parameters/core-parameters.xhtml#option-numbers">dans un registre</a>, on y trouve des trucs
connus comme <code>If-Match</code> - section 5.10.8.1,
<code>Accept</code> - section 5.10.4 - ou
<code>ETag</code> - section 5.10.6). Pour économiser
quelques bits, leur encodage est assez spécial. Le numéro de l'option,
normalement sur 16 bits, n'est pas transmis tel quel mais sous forme
d'une différence avec l'option précédente. Ainsi, si on utilise les
options 4 (<code>ETag</code>) et 5
(<code>If-None-Match</code>), la première option indiquera
bien 4 mais la seconde indiquera 1... De même, les valeurs de l'option
sont violemment comprimées. Si on veut envoyer un entier, on ne doit
transmettre que le nombre d'octets nécessaire (rien si l'entier vaut
zéro, un seul octet s'il est inférieur à 255, etc).</p></div>
<div class="para"><p>Le transport utilisé par CoAP, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b>, ne
fournit aucune garantie de remise : un paquet UDP peut être perdu, et
UDP ne s'en occupera pas, ce sera à l'application de gérer ce
cas. CoAP fournit un service pour faciliter la vie aux applications :
on peut marquer un message CoAP comme nécessitant un accusé de
réception (type <code>CON</code> pour
<i class="foreign" xml:lang="en">Confirmable</i>). Si ce type est présent dans
l'en-tête CoAP, l'expéditeur recevra un accusé de réception
(type <code>ACK</code>) portant le <i class="foreign" xml:lang="en">Message ID</i> du
message reçu. Le RFC fournit l'exemple d'un capteur de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/temp%C3%A9rature" title="Consultez l'article &quot;température&quot; de l'encyclopédie libre Wikipedia">température</a></b> interrogé en CoAP :
</p><pre>
Client -&gt; Serveur: CON [0xbc90] "GET /temperature" 
Serveur -&gt; Client: ACK [0xbc90] "2.05 Content" "22.5 °C"
</pre><p>
Ici, le second message, la réponse du serveur, contient un accusé de
réception pour 0xbc90 (le <i class="foreign" xml:lang="en">Message ID</i>). La requête
est un <code>GET</code> et la réponse a le code 2.05 (un
succès). Notez que, contrairement à HTTP, les codes sont écrits avec
un point entre le premier chiffre (la classe) et les deux autres (le
détail, cf. section 5.9). Ainsi, 4.04
a la classe 4 (erreur du client) et le détail 04 (ressource non
trouvée). Comme indiqué plus haut, les classes sont les mêmes qu'en HTTP : 2 pour un succès, 4 pour une erreur du client (qui devrait
changer sa requête avant de réessayer) et 5 pour une erreur du serveur
(réessayer à l'identique plus tard peut marcher).</p></div>
<div class="para"><p>Le <i class="foreign" xml:lang="en">Message ID</i> et ces types
<code>CON</code> et <code>NON</code> (son contraire,
<i class="foreign" xml:lang="en">Non-confirmable</i>) permettent de mettre en œuvre des
mécanismes simples de retransmission. L'émetteur envoie un message de
type <code>CON</code>, s'il ne reçoit pas de message de type
<code>ACK</code> à temps, il réessaie, avec
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/croissance%20exponentielle" title="Consultez l'article &quot;croissance exponentielle&quot; de l'encyclopédie libre Wikipedia">croissance exponentielle</a></b> du délai. Le
<i class="foreign" xml:lang="en">Message-ID</i> permet aussi de détecter les éventuels duplicatas.</p></div>
<div class="para"><p>On n'est pas obligé d'utiliser le type <code>CON</code>. Si
un message n'a pas besoin de fiabilité (par exemple les lectures
périodiques qu'envoie un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/capteur" title="Consultez l'article &quot;capteur&quot; de l'encyclopédie libre Wikipedia">capteur</a></b>, que quelqu'un
écoute ou pas), il sera du type <code>NON</code>.</p></div>
<div class="para"><p>Le <i class="foreign" xml:lang="en">Message ID</i> doit évidemment être unique,
pendant la durée de vie possible des échanges (variable
<code>EXCHANGE_LIFETIME</code>, quatre minutes par défaut). Il
peut être généré de manière incrémentale (l'émetteur garde un compteur
indiquant le dernier <i class="foreign" xml:lang="en">Message ID</i> généré) mais, dans
ce cas, le RFC recommande (section 4.4) que la valeur initiale soit aléatoire, pour
limiter les possibilités d'attaque par un méchant non situé sur le
chemin des données (c'est un problème de sécurité analogue à celui des
identificateurs de fragments <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b> - voir l'option
<code>--frag-id-policy</code> de <a href="hacking-ipv6.html" title="Consultez ce blog à propos de &quot;hacking-ipv6&quot;">l'outil frag6</a> - ou celui des
numéros de séquences initiaux de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b> - voir le <a href="6528.html" class="rfc" title="Consultez l'analyse du RFC 6528">RFC 6528</a>).</p></div>
<div class="para"><p>Autre problème pour l'émetteur CoAP : quelle taille de messages ?
Les machines pour qui CoAP est conçu peuvent avoir du mal à gérer
parfaitement la <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/IP%20fragmentation" title="Consultez l'article &quot;IP fragmentation&quot; de l'encyclopédie libre Wikipedia (en anglais)">fragmentation</a></b>. Et puis des gros paquets ont davantage de chances d'être corrompus que des petits, sur les liens radios typiques des machines CoAP. Le RFC
recommande donc de ne pas dépasser la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Maximum%20Transmission%20Unit" title="Consultez l'article &quot;Maximum Transmission Unit&quot; de l'encyclopédie libre Wikipedia">MTU</a></b> et,
si elle est inconnue, de <a href="fragmentation-ip-1280.html" title="Consultez ce blog à propos de &quot;fragmentation-ip-1280&quot;">ne pas
dépasser 1 280 octets</a> en <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b>. (C'est
plus compliqué pour <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv4" title="Consultez l'article &quot;IPv4&quot; de l'encyclopédie libre Wikipedia">IPv4</a></b> où le RFC recommande
576 octets et le bit DF - <i class="foreign" xml:lang="en">Don't Fragment</i> - en
notant que, pour les usages typiques de CoAP, le chemin sera simple,
avec peu de routeurs et pas de liens à grande distance, donc peu de
chances que la fragmentation soit nécessaire.)</p></div>
<div class="para"><p>Comme CoAP repose sur UDP, il n'y a pas de mécanisme de contrôle de
la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Congestion%20(r%C3%A9seau)" title="Consultez l'article &quot;Congestion (réseau)&quot; de l'encyclopédie libre Wikipedia">congestion</a></b> par défaut. CoAP doit donc
s'auto-limiter : réémissions avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Croissance%20exponentielle" title="Consultez l'article &quot;Croissance exponentielle&quot; de l'encyclopédie libre Wikipedia">croissance
exponentielle</a></b> des délais, et au maximum une requête en attente pour
chaque machine avec qui on communique (paramètre
<code>NSTART</code>). Ces règles sont pour le client. Si tous
les clients les respectent, tout ira bien. Mais un
serveur CoAP prudent doit considérer que certains clients seront
bogués ou malveillants. Les serveurs ont donc tout intérêt à avoir une forme ou
une autre de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Rate%20limiting" title="Consultez l'article &quot;Rate limiting&quot; de l'encyclopédie libre Wikipedia">limitation de trafic</a></b>.</p></div>
<div class="para"><p>La sémantique des requêtes et réponses CoAP figure en section 5. On
l'a dit, elle ressemble à celle de HTTP, un client qui envoie une
requête et un serveur qui transmet une réponse. L'une des plus grosses
différences avec HTTP est le caractère asynchrone de l'échange.</p></div>
<div class="para"><p>Les requêtes sont les classiques (section 5.8) <code>GET</code>,
<code>POST</code>, <code>PUT</code> et
<code>DELETE</code>, agissant sur une ressource donnée
(identifiée par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b>), comportant des données
optionnelles (surtout utilisées pour <code>POST</code> et
<code>PUT</code>) et utilisant les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Type%20MIME" title="Consultez l'article &quot;Type MIME&quot; de l'encyclopédie libre Wikipedia">types de
média</a></b>. CoAP exige que <code>GET</code>,
<code>PUT</code> et <code>DELETE</code> soient
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Idempotence" title="Consultez l'article &quot;Idempotence&quot; de l'encyclopédie libre Wikipedia">idempotents</a></b> (une bonne pratique mais pas
toujours respectée sur le Web). Une requête non reconnue et la
réponse sera un 4.05. La liste des requêtes possibles est dans <a href="http://www.iana.org/assignments/core-parameters/core-parameters.xhtml#method-codes">un registre IANA</a>.</p></div>
<div class="para"><p>Du fait du caractère asynchrone de l'échange, mettre en
correspondance une requête et une réponse est un peu plus compliqué
qu'en HTTP, où toutes les deux empruntaient la même connexion
TCP. Ici, la section 5.3.2 résume les règles de correspondance : une
réponse correspond à une requête si l'adresse IP source de la réponse
était l'adresse IP de destination de la requête
<b class="emphasis">et</b> que le <i class="foreign" xml:lang="en">Message ID</i> et le
<i class="foreign" xml:lang="en">Token</i> correspondent.</p></div>
<div class="para"><p>Comme HTTP, CoAP permet d'utiliser des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Proxy#Proxy_web" title="Consultez l'article &quot;Proxy&quot; de l'encyclopédie libre Wikipedia">relais</a></b>. C'est d'autant plus important que les
machines CoAP sont souvent indisponibles (hibernation pour économiser
la batterie, par exemple) et un relais pourra donc répondre à la place
d'une machine injoignable. Les relais sont traités plus en détail en
section 5.7. Comme en HTTP, on pourra avoir des <i class="foreign" xml:lang="en">forward
proxies</i> sélectionnés par les clients ou des <i class="foreign" xml:lang="en">reverse
proxies</i> placés devant un serveur.</p></div>
<div class="para"><p>On l'a vu, CoAP, comme HTTP, utilise des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b>, détaillés en section 6. Ils commencent par
les plans <code>coap:</code> ou
<code>coaps:</code>. On verra ainsi, par exemple,
<code>coap://example.com/~sensors/temp.xml</code> ou
<code>coaps://[2001:db8::2:1]/measure/temperature/</code>. Attention,
tout le monde croit bien connaître les URI car ils sont massivement
utilisés pour le Web mais le RFC met en garde les programmeurs : il y
a plein de pièges dans le traitement des URI, notamment dans le
décodage des valeurs encodées en pour-cent.</p></div>
<div class="para"><p>Si le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Port%20(logiciel)" title="Consultez l'article &quot;Port (logiciel)&quot; de l'encyclopédie libre Wikipedia">port</a></b> n'est pas indiqué dans l'URI (ce
qui est le cas des deux exemples ci-dessus), le port par défaut est
5683 pour <code>coap:</code> et 5684 pour <code>coaps:</code>.</p></div>
<div class="para"><p>CoAP utilise, comme HTTP, la convention du
<code>/.well-known/</code> (<a href="5785.html" class="rfc" title="Consultez l'analyse du RFC 5785">RFC 5785</a>)
pour placer des ressources « bien connues », facilitant ainsi leur
découverte.</p></div>
<div class="para"><p>Justement, à propos de découverte, la section 7 détaille comment un
client CoAP va pouvoir trouver les URI des ressources
intéressantes. CoAP est conçu pour des communications de machine à
machine, où aucun humain n'est présent dans la boucle pour deviner,
faire une recherche <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Google%20(moteur%20de%20recherche)" title="Consultez l'article &quot;Google (moteur de recherche)&quot; de l'encyclopédie libre Wikipedia">Google</a></b>, utiliser son
intuition, etc. La méthode privilégiée dans CoAP est celle du <a href="6690.html" class="rfc" title="Consultez l'analyse du RFC 6690">RFC 6690</a> : un fichier au format normalisé situé en
<code>/.well-known/core</code>.</p></div>
<div class="para"><p>Les section 9 et 11 sont consacrées à la sécurité de CoAP. Évidemment, vu
les ressources très limitées des machines CoAP typiques, il ne faut
pas s'attendre à une grande sécurité. Par exemple, une protection par
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Datagram%20Transport%20Layer%20Security" title="Consultez l'article &quot;Datagram Transport Layer Security&quot; de l'encyclopédie libre Wikipedia">DTLS</a></b> (<a href="6347.html" class="rfc" title="Consultez l'analyse du RFC 6347">RFC 6347</a>) est
possible mais pas obligatoire, juste conseillée. En outre, les
ressources matérielles limitées des machines CoAP compliquent la tâche
du programmeur : des processeurs
très lents qui facilitent les <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Timing%20attack" title="Consultez l'article &quot;Timing attack&quot; de l'encyclopédie libre Wikipedia (en anglais)">attaques par mesure du temps écoulé</a></b>,
et pas de bon générateur aléatoire. En l'absence d'un tel générateur,
on ne peut donc pas
générer des clés <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cryptographie" title="Consultez l'article &quot;Cryptographie&quot; de l'encyclopédie libre Wikipedia">cryptographiques</a></b> localement, il faut
le faire en usine et les enregistrer sur la machine. Et pas question
de mettre les mêmes clés à tout le monde : comme les machines CoAP seront souvent dispersées dans des
endroits ayant peu de sécurité physique (capteurs placés un peu
partout), et n'auront en général pas de protection contre les
manipulations physiques, pour des raisons de coût, un attaquant pourra
facilement ouvrir une machine et en extraire ses clés.</p></div>
<div class="para"><p>La complexité est l'une des ennemies principales de la sécurité. Le
RFC rappelle que le traitement des URI (bien plus compliqué qu'il n'en
a l'air) impose des analyseurs relativements complexes et donc
augmente la probabilité de bogues, pouvant mener à des failles de
sécurité. Même chose pour le format des liens du <a href="6690.html" class="rfc" title="Consultez l'analyse du RFC 6690">RFC 6690</a>.</p></div>
<div class="para"><p>Question réseau, CoAP souffrira sans doute d'attaques rendues
possibles par l'usurpation d'adresses IP. Comme UDP ne nécessite pas
d'échange préalable, il est trivial d'envoyer un paquet depuis une
adresse usurpée et de le voir accepté. Cela permet des tas
d'attaques comme :
</p><ul>
<li>Envoyer un <code>RST</code> (<i class="foreign" xml:lang="en">Reset</i>)
aux demandes de connexion vers un serveur, rendant ainsi ce serveur
inutilisable (<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Attaque%20par%20d%C3%A9ni%20de%20service" title="Consultez l'article &quot;Attaque par déni de service&quot; de l'encyclopédie libre Wikipedia">déni de service</a></b>),</li>
<li>Envoyer une fausse réponse à une requête
<code>GET</code>.</li>
</ul><p>
Pour cette deuxième attaque, il faut pouvoir deviner le
<i class="foreign" xml:lang="en">Token</i> utilisé. Si l'attaquant est aveugle (parce
que situé en dehors du chemin des paquets), sa tâche sera difficile si
le <i class="foreign" xml:lang="en">Token</i> est bien aléatoire (mais ces machines
contraintes en ressources n'ont souvent pas de vrai
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/G%C3%A9n%C3%A9rateur%20de%20nombres%20al%C3%A9atoires" title="Consultez l'article &quot;Générateur de nombres aléatoires&quot; de l'encyclopédie libre Wikipedia">générateur aléatoire</a></b>, au sens du <a href="4086.html" class="rfc" title="Consultez l'analyse du RFC 4086">RFC 4086</a>).</p></div>
<div class="para"><p>En pratique, il est probable que les déploiements réels de CoAP
aient lieu dans des réseaux fermés, ne contenant que des machines de
confiance, et où l'accès à l'extérieur passera par une passerelle qui
s'occupera de sécurité. Autrement, un simple
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ping%20(logiciel)" title="Consultez l'article &quot;ping (logiciel)&quot; de l'encyclopédie libre Wikipedia">ping</a></b> à destination d'une machine CoAP pourrait
suffir à vider sa batterie.</p></div>
<div class="para"><p>CoAP introduit aussi une autre menace, celle d'attaques par
<b class="emphasis">amplification</b> (section 11.3). Comme <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Simple%20network%20management%20protocol" title="Consultez l'article &quot;Simple network management protocol&quot; de l'encyclopédie libre Wikipedia">SNMP</a></b>
et le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System" title="Consultez l'article &quot;Domain Name System&quot; de l'encyclopédie libre Wikipedia">DNS</a></b> (tous les deux <a href="attaques-reflexion.html" title="Consultez ce blog à propos de &quot;attaques-reflexion&quot;">déjà utilisés pour ces
attaques</a>), CoAP a des réponses plus grandes que les questions
(permettant l'amplification) et repose sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b>
et non pas <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b> (permettant l'usurpation
d'adresse IP).</p></div>
<div class="para"><p>La seule limite à ces attaques semble devoir être les faibles
ressources des machines CoAP, qui devraient les rendre relativement
peu intéressantes comme amplificateurs contre des serveurs
Internet. En revanche, à l'intérieur d'un réseau de machines CoAP, le
risque demeure élevé et le RFC ne propose aucune vraie solution.</p></div>
<div class="para"><p>CoAP est, d'une certaine façon, un vieux protocole (voir l'article
« <i class="foreign" xml:lang="en">CoAP: An Application Protocol for Billions of Tiny Internet
Nodes</i> » de Carsten Bormann, Angelo Paolo Castellani et Zach
Shelby publié en 2012 dans dans <i class="foreign" xml:lang="en">Internet Computing, IEEE
(Volume:16 ,  Issue: 2)</i> et malheureusement pas disponible
en ligne, il faut demander une copie à l'auteur). Il existe déjà
plusieurs mise en œuvre, qui ont été souvent testées dans des essais
d'interopérabilité formels. Un exemple de mise en œuvre est celle du
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Contiki" title="Consultez l'article &quot;Contiki&quot; de l'encyclopédie libre Wikipedia">système Contiki</a></b>.
</p></div>
<div class="para"><p>Des exemples de requêtes CoAP décrites en détail figurent dans
l'annexe A du RFC. Grâce à Renzo Navas, voici quelques traces CoAP au format <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/pcap" title="Consultez l'article &quot;pcap&quot; de l'encyclopédie libre Wikipedia">pcap</a></b> :
</p><ul>
<li><a class="local-file" href="files/01-coap-getwellknown.pcap" title="Récupérez le fichier &quot;01-coap-getwellknown.pcap&quot;">Un simple GET</a> du
fichier des services, <code>/.well-known/core</code>,</li>
<li><a class="local-file" href="files/02-getHelloWorldANDtoUppercaseRES.pcap" title="Récupérez le fichier &quot;02-getHelloWorldANDtoUppercaseRES.pcap&quot;">Un autre GET</a>,</li>
<li><a class="local-file" href="files/03-separateResponse.pcap" title="Récupérez le fichier &quot;03-separateResponse.pcap&quot;">Un GET avec réponse</a>,</li>
<li><a class="local-file" href="files/04-post-put-get-delete.pcap" title="Récupérez le fichier &quot;04-post-put-get-delete.pcap&quot;">POST, PUT et DELETE</a>.</li>
</ul><p>
Si <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/tcpdump" title="Consultez l'article &quot;tcpdump&quot; de l'encyclopédie libre Wikipedia">tcpdump</a></b> ne connait pas encore CoAP,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Wireshark" title="Consultez l'article &quot;Wireshark&quot; de l'encyclopédie libre Wikipedia">Wireshark</a></b>, par contre, sait bien
l'analyser. Ici, une
la première requête <code>GET</code> du premier fichier pcap et sa réponse :
</p><pre>

Constrained Application Protocol, TID: 27328, Length: 21
    01.. .... = Version: 1
    ..00 .... = Type: Confirmable (0)
    .... 0000 = Option Count: 0
    Code: GET (1)
    Transaction ID: 27328
    Payload Content-Type: text/plain (default), Length: 17, offset: 4
        Line-based text data: text/plain
            \273.well-known\004core

Constrained Application Protocol, TID: 27328, Length: 521
    01.. .... = Version: 1
    ..10 .... = Type: Acknowledgement (2)
    .... 0000 = Option Count: 0
    Code: 2.05 Content (69)
    Transaction ID: 27328
    Payload Content-Type: text/plain (default), Length: 517, offset: 4
        Line-based text data: text/plain
            \301(\261\r
            [truncated] \377&lt;/careless&gt;;rt="SepararateResponseTester";title="This resource will ACK anything, but never send a separate response",&lt;/helloWorld&gt;;rt="HelloWorldDisplayer";title="GET a friendly greeting!",&lt;/image&gt;;ct="21 22 23 24";rt="Ima

</pre></div>
<div class="para"><p>Merci à Laurent Toutain pour sa relecture attentive.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7252.txt">Téléchargez le RFC 7252</a></p>
<br />
<a href="7252.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7288.txt">RFC 7288</a>: Reflections On Host Firewalls</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : D. Thaler (Microsoft)<br/>Pour information<br/>Première rédaction de cet article le 2 juillet 2014<br/></p><hr/>
<div class="para"><p>Aujourd'hui, on met des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feux</a></b> partout et
leur présence est en général considérée, sans aucune réflexion
supplémentaire, comme indispensable. Il existe des pare-feux qui se
branchent sur le réseau et protègent ainsi toutes les machines du
réseau (<i class="foreign" xml:lang="en">network firewall</i>). Et il existe des pare-feux sur les <a href="terminal-host.html" title="Consultez ce blog à propos de &quot;terminal-host&quot;">machines terminales</a>, des <i class="foreign" xml:lang="en">host
firewalls</i>, qui font l'objet de ce
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b>. En présence d'un tel pare-feu, on peut
avoir une application qui tourne, et donc consomme des ressources,
mais ne peut pas communiquer avec l'extérieur puisqu'elle est bloquée
par le pare-feu. Le même résultat de sécurité pourrait être atteint en
ne faisant pas tourner l'application, ou en la configurant pour
limiter ses possibilités. Cette approche ne serait-elle pas meilleure ?</p></div>
<div class="para"><p>Le <a href="http://www.rfc-editor.org/rfc/rfc2979.txt" class="rfc" title="Consultez le texte intégral du RFC 2979">RFC 2979</a> discutait des <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feux</a></b>
sur l'Internet et des propriétés qu'on attendait d'eux (et les <a href="http://www.rfc-editor.org/rfc/rfc4949.txt" class="rfc" title="Consultez le texte intégral du RFC 4949">RFC 4949</a> et <a href="4948.html" class="rfc" title="Consultez l'analyse du RFC 4948">RFC 4948</a> discutaient de la terminologie). Le <a href="http://www.rfc-editor.org/rfc/rfc2979.txt" class="rfc" title="Consultez le texte intégral du RFC 2979">RFC 2979</a> pointait
notamment le risque de « faux positif », lorsqu'un pare-feu bloque
accidentellement une communication légitime. Les vendeurs de pare-feux
oublient toujours de mentionner ce risque. Pourtant, nombreux sont les
pare-feux qui bloquent stupidement des connexions parfaitement
légitimes, par exemple parce que les paquets <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b>
contiennent <a href="options-interdites.html" title="Consultez ce blog à propos de &quot;options-interdites&quot;">des options</a>, ou
des en-têtes <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b> (cf. <a href="7045.html" class="rfc" title="Consultez l'analyse du RFC 7045">RFC 7045</a>). Le <a href="4924.html" class="rfc" title="Consultez l'analyse du RFC 4924">RFC 4924</a> revient sur cette
question des pare-feux en notant qu'ils sont largement responsables de
l'ossification de l'Internet, et que de plus en plus d'applications
consacrent beaucoup d'effort à contourner ces obstacles. En outre, les
pare-feux contribuent souvent à un faux sentiment de sécurité, qui
peut mener à baisser sa garde sur les machines supposées « protégées
par le pare-feu » (section 6 de notre RFC). Enfin, la section 1.1 du
RFC rappelle que le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Network%20Address%20Translation" title="Consultez l'article &quot;Network Address Translation&quot; de l'encyclopédie libre Wikipedia">NAT</a></b> n'est  <a href="nat-et-securite.html" title="Consultez ce blog à propos de &quot;nat-et-securite&quot;">pas un vrai
pare-feu</a>.</p></div>
<div class="para"><p>Le problème des pare-feux est d'autant plus aigu que la réponse classique à la
question de l'utilité d'un pare-feu est « bloquer le trafic non
souhaité », mais que cette réponse ne dit pas « non souhaité par
qui ». Par l'utilisateur final ? Par son employeur ? Par
l'administrateur réseau ? Par le développeur ? Leurs intérêts sont
souvent en conflit et on ne peut pas espérer un consensus simple entre
tous ces acteurs (le RFC reprend l'excellent terme de « <i class="foreign" xml:lang="en"><a href="tussle-cyberspace.html" hreflang="en" title="Consultez ce blog à propos de &quot;tussle-cyberspace&quot;">tussle</a></i> »). Pas étonnant qu'on voit souvent des « courses aux
armements » entre ceux qui bloquent et ceux qui contournent le blocage.</p></div>
<div class="para"><p>Le pare-feu typique est souvent configuré par des règles
<i class="foreign" xml:lang="en">allow</i>/<i class="foreign" xml:lang="en">deny</i>
où on indique que tel type de trafic est autorisé ou interdit (section
2 du RFC). Voici par exemple des règles <a href="filtrage-avec-shorewall.html" title="Consultez ce blog à propos de &quot;filtrage-avec-shorewall&quot;">Shorewall</a> où tout est interdit
par défaut mais où on accepte quelques services :
</p><pre>
# SMTP 
ACCEPT               net       fw       tcp      25
ACCEPT               net       fw       tcp      587
# IMAP, IMAPS et POPS
ACCEPT               net        fw      tcp      143
ACCEPT               net        fw      tcp      993
ACCEPT               net        fw      tcp      995
# Nagios Remote Execution (NRPE)
ACCEPT               net:192.0.2.187  fw  TCP     5767
# SNMP
ACCEPT               net:192.0.2.187,203.0.113.170   fw  udp   161
</pre><p>
Pour un pare-feu sur une machine terminale,
l'utilisateur n'a pas le droit de modifier ces règles sauf dans le cas
(fréquent avec les machines personnelles) où l'utilisateur est en même
temps administrateur système. Par contre, des applications peuvent
configurer le pare-feu, pour les systèmes où celui-ci fournit une
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Interface%20de%20programmation" title="Consultez l'article &quot;Interface de programmation&quot; de l'encyclopédie libre Wikipedia">API</a></b> aux applications, ou bien s'il existe un
protocole standard de changement de la configuration du pare-feu comme
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Universal%20Plug%20and%20Play" title="Consultez l'article &quot;Universal Plug and Play&quot; de l'encyclopédie libre Wikipedia">UPnP</a></b> ou son successeur potentiel PCP (<a href="6887.html" class="rfc" title="Consultez l'analyse du RFC 6887">RFC 6887</a>). Ces règles sont classées par notre RFC en deux
catégories : réduction de la surface d'attaque (empêcher l'application
de faire des choses que le développeur ne voulait pas qu'elle fasse)
et politique de sécurité (empêcher l'application de faire des choses
que l'administrateur système ne voulait pas qu'elle fasse).</p></div> 
<div class="para"><p>La section 3 décrit la première catégorie, la réduction de la
surface d'attaque. On peut se demander si cette catégorie est utile :
après tout, si on ne veut pas qu'une application, par exemple,
détruise des fichiers en réponse à une requête venue par le réseau, le
mieux est de ne pas mettre en œuvre cette fonction. On sera alors bien
plus en sécurité. Sauf qu'on n'a pas toujours le luxe d'avoir
uniquement des applications bien conçues et bien écrites. Souvent, le
développeur a fait des impasses (ou, en termes plus savants, a pris de
la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/dette%20technique" title="Consultez l'article &quot;dette technique&quot; de l'encyclopédie libre Wikipedia">dette technique</a></b>) et réécrire l'application serait trop
coûteux. C'est par exemple le cas de beaucoup d'applications Web
programmées à la va-vite sans souci de sécurité, en
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/PHP%3A%20Hypertext%20Preprocessor" title="Consultez l'article &quot;PHP: Hypertext Preprocessor&quot; de l'encyclopédie libre Wikipedia">PHP</a></b> ou <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Visual%20Basic%20.NET" title="Consultez l'article &quot;Visual Basic .NET&quot; de l'encyclopédie libre Wikipedia">VB.NET</a></b>. Coller un
pare-feu devant l'application est en général moins coûteux et plus
efficace que de se plonger dans le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Syndrome%20du%20plat%20de%20spaghettis" title="Consultez l'article &quot;Syndrome du plat de spaghettis&quot; de l'encyclopédie libre Wikipedia">plat de spaghettis</a></b>.</p></div>
<div class="para"><p>Il y a aussi des cas où la dette prise par le développeur (reporter
le problème à plus tard...) était justifiée par un manque de support
de la part du système. Par exemple, une règle aussi simple et courante
que
« communication uniquement avec le lien local » est difficile à mettre
en œuvre de façon portable, sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unix" title="Consultez l'article &quot;Unix&quot; de l'encyclopédie libre Wikipedia">Unix</a></b>, dans tous
les langages de programmation. (Notez au passage que n'autoriser que
les adresses IP source du même réseau que celui du serveur n'est pas
suffisant, en raison de la possibilité d'usurpation d'adresse. Pour
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b>, il faudrait aussi tester le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Time%20to%20Live#Le_Time_to_Live_sur_les_paquets_IP" title="Consultez l'article &quot;Time to Live&quot; de l'encyclopédie libre Wikipedia">TTL</a></b>, cf. <a href="5082.html" class="rfc" title="Consultez l'analyse du RFC 5082">RFC 5082</a>.) Il y a
aussi le cas où la machine se déplace d'un réseau sûr à un réseau non-sûr. Le
développeur est donc tenté de déléguer la mise en œuvre de cette
politique à un pare-feu.</p></div>
<div class="para"><p>Même chose avec des politiques complexes, comme de ne communiquer
que sur les liens les moins coûteux, sachant que l'application n'a pas
forcément connaissance des coûts (sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Android" title="Consultez l'article &quot;Android&quot; de l'encyclopédie libre Wikipedia">Android</a></b>,
cette politique est en général purement binaire : on considère que la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/3G" title="Consultez l'article &quot;3G&quot; de l'encyclopédie libre Wikipedia">3G</a></b> est coûteuse et le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Wi-Fi%20(protocole%20de%20communication)" title="Consultez l'article &quot;Wi-Fi (protocole de communication)&quot; de l'encyclopédie libre Wikipedia">Wifi</a></b> gratuit, ce qui n'est pas toujours vrai.)
Avoir une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Interface%20de%20programmation" title="Consultez l'article &quot;Interface de programmation&quot; de l'encyclopédie libre Wikipedia">API</a></b> permettant à l'application
d'exprimer ses souhaits, que le système d'exploitation traduirait en
règles de pare-feu concrètes, simplifierait beaucoup les choses.</p></div>
<div class="para"><p>Quelles sont donc les solutions pour l'utilisateur, qui se retrouve
avec une application « imparfaite », pleine de failles de sécurité ?
D'abord, réparer le logiciel en corrigeant ces failles. Les partisans
des pare-feux feront évidemment remarquer qu'il est plus rapide et
plus efficace d'utiliser un pare-feu : déboguer un logiciel mal écrit
est long et coûteux et on n'est jamais sûr d'avoir bouché tous les
trous de sécurité. Il y a d'ailleurs des cas où réparer le logiciel
est quasi-impossible : pas les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Code%20source" title="Consultez l'article &quot;Code source&quot; de l'encyclopédie libre Wikipedia">sources</a></b> pour le faire ou bien pas de mécanisme de
mise à jour pour les engins qui font tourner ce logiciel. En général,
un changement des règles du pare-feu peut être déployé plus facilement
qu'un <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Patch%20(informatique)" title="Consultez l'article &quot;Patch (informatique)&quot; de l'encyclopédie libre Wikipedia">patch</a></b></i>.</p></div>
<div class="para"><p>Autre idée, 
ne pas utiliser le
logiciel. Solution brutale mais qui résoud tout. Notez que l'idée
n'est pas si violente qu'elle en a l'air : certains systèmes font
tourner par défaut des logiciels qui ne devraient pas tourner. Arrêter 
ce logiciel inutile est une solution réaliste.</p></div>
<div class="para"><p>Enfin, il y a le pare-feu, qui va protéger contre le logiciel mal
fait. Le logiciel tournera toujours, consommant des ressources
(personnellement, je ne trouve pas l'argument très convaincant : si le
logiciel est juste en attente d'événements, il ne consomme pas
grand'chose). Et, surtout, si un utilisateur tente de se servir du
logiciel, il aura des surprises, car beaucoup de programmes ne sont
pas conçus de manière robuste : ils réagissent mal quand, par exemple,
certains services réseau ne leur sont pas accessibles. Parfois, cela
aggrave la consommation de ressources (par exemple, le logiciel,
n'ayant pas compris qu'il était bloqué par le pare-feu, réessaie en
boucle). Autre problème avec les pare-feux : ils sont souvent
surbloquants. Par exemple, ils bloquent tout ce qu'il ne connaissent
pas et gênent donc considérablement l'innovation. Certains analysent
les paquets de manière très sommaire (oubliant par exemple certaines
fonctions avancées du protocole) et prennent donc de mauvaises
décisions. C'est ainsi qu'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Control%20Message%20Protocol" title="Consultez l'article &quot;Internet Control Message Protocol&quot; de l'encyclopédie libre Wikipedia">ICMP</a></b> est souvent
bloqué, menant à des problèmes de découverte de la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Path%20MTU%20discovery" title="Consultez l'article &quot;Path MTU discovery&quot; de l'encyclopédie libre Wikipedia">MTU du
chemin</a></b> (<a href="http://www.rfc-editor.org/rfc/rfc4890.txt" class="rfc" title="Consultez le texte intégral du RFC 4890">RFC 4890</a> et <a href="http://www.rfc-editor.org/rfc/rfc2979.txt" class="rfc" title="Consultez le texte intégral du RFC 2979">RFC 2979</a>).</p></div>
<div class="para"><p>Deuxième catégorie de règles dans un pare-feu, celles qui visent à
faire respecter une politique de sécurité. L'administrateur a décidé
qu'on ne regarderait pas <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/YouTube" title="Consultez l'article &quot;YouTube&quot; de l'encyclopédie libre Wikipedia">YouTube</a></b>, les règles
bloquent YouTube. Cette catégorie peut en théorie être mise en œuvre à
trois endroits. D'abord, dans les applications elles-mêmes. Ça ne
passe évidemment pas à l'échelle : il faudrait ajouter du code à
toutes les applications (faites un peu une liste du nombre de clients
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b> sur votre machine, par exemple ;
rappelez vous qu'il n'y a pas que les navigateurs Web)
<b class="emphasis">et</b> les configurer. En pratique, il y aura
toujours une application oubliée. Cette solution n'est donc pas
réaliste.</p></div>
<div class="para"><p>Deuxième endroit possible, le pare-feu. Outre les
problèmes discutés plus haut (application qui réagit mal au blocage de
certains services), cela mène facilement à une course aux armements :
comme les désirs de l'utilisateur final et de l'administrateur du
pare-feu ne coïncident pas forcément, les applications, à la demande
des utilisateurs, vont évoluer pour contourner le filtrage, qui va
devenir de plus en plus intrusif et ainsi de suite jusqu'à ce que tout
le monde, pris dans cette course, oublie le but originel de la
politique de sécurité. Comme le disait la section 2.1 du <a href="4924.html" class="rfc" title="Consultez l'analyse du RFC 4924">RFC 4924</a>, le filtrage sans le consentement (au moins
passif) de l'utilisateur est difficile, et va mener à des solutions
compliquées, coûteuses et fragiles, violant largement les bons
principes d'architecture réseau (par exemple en faisant tout passer
au-dessus de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b>, seul protocole
autorisé).</p></div>
<div class="para"><p>Reste le troisième endroit, qui a plutôt les faveurs du RFC : faire
des politiques de sécurité un service auquel s'inscrivent les
applications. L'application utilise une
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Biblioth%C3%A8que%20logicielle" title="Consultez l'article &quot;Bibliothèque logicielle&quot; de l'encyclopédie libre Wikipedia">bibliothèque</a></b> (comme les <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/TCP%20Wrapper" title="Consultez l'article &quot;TCP Wrapper&quot; de l'encyclopédie libre Wikipedia (en anglais)">TCP
wrappers</a></b></i>) ou bien parle un protocole réseau
(comme <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Port%20Control%20Protocol" title="Consultez l'article &quot;Port Control Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">PCP</a></b>, <a href="6887.html" class="rfc" title="Consultez l'analyse du RFC 6887">RFC 6887</a>),
décrit ce qu'elle veut, et apprend si c'est autorisé ou pas, de
manière propre. Cela nécessite évidemment des standards (comme PCP,
qui est pour l'instant très peu déployé, et qui est de toute façon
sans doute insuffisant pour gérer toutes les politiques possibles)
car on n'imagine pas chaque application ajouter du code pour
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Interface%20de%20programmation" title="Consultez l'article &quot;Interface de programmation&quot; de l'encyclopédie libre Wikipedia">API</a></b> de chaque marque de pare-feu.</p></div>
<div class="para"><p>Cette technique est très originale par rapport à l'approche
habituelle sur les pare-feux mais c'est celle recommandée par notre
RFC. Pour le résumer en une phrase, on fait trop travailler les pare-feux
et pas assez les applications.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7288.txt">Téléchargez le RFC 7288</a></p>
<br />
<a href="7288.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7250.txt">RFC 7250</a>: Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : P. Wouters (Red Hat), H. Tschofenig, J. Gilmore, S. Weiler (SPARTA), T. Kivinen (AuthenTec)<br/>Chemin des normes<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/tls">tls</a></b><br/>Première rédaction de cet article le 1 juillet 2014<br/></p><hr/>
<div class="para"><p>Le système de sécurité <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transport%20Layer%20Security" title="Consultez l'article &quot;Transport Layer Security&quot; de l'encyclopédie libre Wikipedia">TLS</a></b>, normalisé dans
le <a href="5246.html" class="rfc" title="Consultez l'analyse du RFC 5246">RFC 5246</a> est souvent confondu avec la norme
de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Certificat%20%C3%A9lectronique" title="Consultez l'article &quot;Certificat électronique&quot; de l'encyclopédie libre Wikipedia">certificats</a></b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/X.509" title="Consultez l'article &quot;X.509&quot; de l'encyclopédie libre Wikipedia">X.509</a></b>. On
lit souvent des choses comme « le serveur TLS envoie alors un
certificat X.509 au client », voire, pire, on appelle ces certificats
« certificats TLS » (ou, encore plus inexact, « certificats
SSL »). Dans la réalité, les deux systèmes, TLS et X.509, sont
indépendants. X.509 peut servir à autre chose qu'à TLS (et c'est
pourquoi parler de « certificats SSL » est une grosse erreur), et TLS
peut utiliser d'autres techniques
d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/authentification" title="Consultez l'article &quot;authentification&quot; de l'encyclopédie libre Wikipedia">authentification</a></b> que X.509. Une de ces
techniques était déjà spécifiée dans le <a href="6091.html" class="rfc" title="Consultez l'analyse du RFC 6091">RFC 6091</a>, l'utilisation de clés <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pretty%20Good%20Privacy" title="Consultez l'article &quot;Pretty Good Privacy&quot; de l'encyclopédie libre Wikipedia">PGP</a></b>. Une
autre vient d'être normalisée dans ce <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b>,
l'utilisation de « clés brutes » (<i class="foreign" xml:lang="en">raw keys</i>), sans
certificat autour. Comme une clé seule ne peut pas être authentifiée,
ces clés brutes n'ont de sens que combinées avec un mécanisme
d'authentification externe, comme <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/DNS-based%20Authentication%20of%20Named%20Entities" title="Consultez l'article &quot;DNS-based Authentication of Named Entities&quot; de l'encyclopédie libre Wikipedia (en anglais)">DANE</a></b>.</p></div>
<div class="para"><p>Rappelons en effet qu'un certificat, c'est une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cryptographie%20asym%C3%A9trique" title="Consultez l'article &quot;Cryptographie asymétrique&quot; de l'encyclopédie libre Wikipedia">clé
publique</a></b> (champ <code>SubjectPublicKeyInfo</code>
dans X.509) plus un certain nombre de métadonnées (comme la
date d'expiration) et une signature par une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Autorit%C3%A9%20de%20certification" title="Consultez l'article &quot;Autorité de certification&quot; de l'encyclopédie libre Wikipedia">autorité</a></b> qui certifie la clé. Pour la session
TLS, la seule partie indispensable est la clé (dans un certificat
« auto-signé », seule la clé a un sens, le reste du certificat ne
pouvant pas être vérifié). Mais, en pratique, le
chiffrement sans l'authentification est limité : il ne protège que
contre un attaquant purement passif. Dès que l'attaquant est actif
(pensons par exemple à un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Borne%20Wi-Fi" title="Consultez l'article &quot;Borne Wi-Fi&quot; de l'encyclopédie libre Wikipedia">hotspot Wifi</a></b> tentant... mais tenu par
l'attaquant), il peut rediriger le client TLS vers un serveur intermédiaire qui va faire croire au client qu'il est le vrai serveur, avant
de retransmettre vers le serveur authentique. Pour contrer cette
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/attaque%20de%20l'homme%20du%20milieu" title="Consultez l'article &quot;attaque de l'homme du milieu&quot; de l'encyclopédie libre Wikipedia">attaque de l'homme du milieu</a></b>, on
<b class="emphasis">authentifie</b> le serveur. Sur l'Internet, la
méthode la plus courante est l'utilisation de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/X.509" title="Consultez l'article &quot;X.509&quot; de l'encyclopédie libre Wikipedia">certificats
X.509</a></b>, ou plus précisement de leur profil
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/PKIX" title="Consultez l'article &quot;PKIX&quot; de l'encyclopédie libre Wikipedia">PKIX</a></b> (<a href="5280.html" class="rfc" title="Consultez l'analyse du RFC 5280">RFC 5280</a>). Cette
méthode est d'une fiabilité très douteuse : des centaines
d'organisations dans le monde peuvent <a href="http://www.01net.com/editorial/610140/comment-le-ministere-des-finances-espionne-le-trafic-web-de-ses-collaborateurs/">émettre
un faux certificat pour gmail.com</a> et il ne peut donc pas y
avoir de confiance rationnelle dans ce système (cf. « <i class="foreign" xml:lang="en"><a href="http://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf" hreflang="en">New
Tricks for Defeating SSL in Practice</a></i> »).</p></div>
<div class="para"><p>Il existe d'autres méthodes
d'authentification que X.509, permettant de faire un lien entre le
serveur qu'on veut contacter, et l'entité qui nous envoie une clé
publique en TLS :
</p><ul>
<li>Les certificats ou clés publiés dans le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System" title="Consultez l'article &quot;Domain Name System&quot; de l'encyclopédie libre Wikipedia">DNS</a></b> et sécurisés par
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System%20Security%20Extensions" title="Consultez l'article &quot;Domain Name System Security Extensions&quot; de l'encyclopédie libre Wikipedia">DNSSEC</a></b>, à savoir la technique <a href="jres-dane-2011.html" title="Consultez ce blog à propos de &quot;jres-dane-2011&quot;">DANE</a> du <a href="6698.html" class="rfc" title="Consultez l'analyse du RFC 6698">RFC 6698</a>,</li>
<li>Les certificats ou clés publiés dans un annuaire
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Lightweight%20Directory%20Access%20Protocol" title="Consultez l'article &quot;Lightweight Directory Access Protocol&quot; de l'encyclopédie libre Wikipedia">LDAP</a></b>,</li>
<li>Les certificats ou clés stockés en dur chez le client. Cela
manque de souplesse (il est difficile de les changer) et ce n'est donc
pas très recommandé pour l'Internet public mais c'est envisagé pour
des déploiements plus fermés comme ceux du protocole
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Constrained%20Application%20Protocol" title="Consultez l'article &quot;Constrained Application Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">CoAP</a></b> (<a href="7252.html" class="rfc" title="Consultez l'analyse du RFC 7252">RFC 7252</a>), où les objets peuvent
sécuriser la communication avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Datagram%20Transport%20Layer%20Security" title="Consultez l'article &quot;Datagram Transport Layer Security&quot; de l'encyclopédie libre Wikipedia">DTLS</a></b>. (Cette
troisième méthode est sans doute la seule possible pour
l'authentification du client TLS par le serveur, cf. section 4.3.)</li>
</ul><p>
La section 6 de notre RFC revient en détail sur l'authentification de
ces clés brutes. Sans cette authentification, une session TLS
utilisant ces clés est très vulnérable à l'homme du milieu.
</p></div>
<div class="para"><p>La section 3 décrit les détails de format des clés brutes. Il faut
deux extensions au protocole TLS, <code>client_certificate_type</code>
et <code>server_certificate_type</code> (enregistrées 
dans <a href="http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#tls-extensiontype-values-1">le
registre des extensions</a>), qui permettent d'indiquer
(lors de la négociation TLS)
séparément le type de certificat utilisé par le serveur et par le
client. Par exemple, pour le serveur, cela s'écrit ainsi :
</p><pre>
 
struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType server_certificate_types&lt;1..2^8-1&gt;;
               case server:
                 CertificateType server_certificate_type;
           }
   } ServerCertTypeExtension;

</pre><p>
Lorsque ces extensions TLS sont utilisées, la structure
<code>Certificate</code> est modifiée ainsi :
</p><pre>   

struct {
       select(certificate_type){

           // certificate type defined in this document.
           case RawPublicKey:
             opaque ASN.1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;

           // X.509 certificate defined in RFC 5246
           case X.509:
             ASN.1Cert certificate_list&lt;0..2^24-1&gt;;

           // Additional certificate type based on TLS
           //   Certificate Type Registry 
           //   http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#tls-extensiontype-values-3
           // for instance PGP keys
       };
   } Certificate;

</pre><p>
(On notera que le <a href="6091.html" class="rfc" title="Consultez l'analyse du RFC 6091">RFC 6091</a> utilisait un autre
mécanisme, l'extension <code>cert_type</code>, numéro 9, mais qui n'a pas été réutilisée ici, le <a href="6091.html" class="rfc" title="Consultez l'analyse du RFC 6091">RFC 6091</a> n'ayant <a href="http://www.ietf.org/mail-archive/web/tls/current/msg08726.html">pas le statut « Chemin des Normes »</a> et le mécanisme <code>cert_type</code> ne permettant pas <a href="http://www.ietf.org/mail-archive/web/tls/current/msg08733.html">des types différents pour le client et le serveur</a>.) Le champ
<code>subjectPublicKeyInfo</code> contient un encodage
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Distinguished%20Encoding%20Rules" title="Consultez l'article &quot;Distinguished Encoding Rules&quot; de l'encyclopédie libre Wikipedia">DER</a></b> de la clé et d'un identificateur
d'algorithme (un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/OID" title="Consultez l'article &quot;OID&quot; de l'encyclopédie libre Wikipedia">OID</a></b> comme 1.2.840.10045.2.1
pour <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Elliptic%20curve%20digital%20signature%20algorithm" title="Consultez l'article &quot;Elliptic curve digital signature algorithm&quot; de l'encyclopédie libre Wikipedia">ECDSA</a></b>) :
</p><pre>
     SubjectPublicKeyInfo  ::=  SEQUENCE  {
           algorithm               AlgorithmIdentifier,
           subjectPublicKey        BIT STRING  }
</pre><p>
L'omission d'une grande partie du certificat permet
de se contenter d'un analyseur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ASN.1" title="Consultez l'article &quot;ASN.1&quot; de l'encyclopédie libre Wikipedia">ASN.1</a></b> plus
réduit. Mais les clés brutes ne sont malheureusement pas réellement
brutes, c'est quand même une structure décrite en ASN.1 et il faut
donc un analyseur minimal.
</p></div>
<div class="para"><p>La section 4 décrit les modifications à la négociation initiale de
TLS (les autres parties de la communication ne sont pas modifiées par
ce RFC). Le client ajoute une ou deux des extensions TLS (la plupart
du temps, en TLS, le client ne s'authentifie pas, et on n'aura donc
que l'extension <code>server_certificate_type</code>). La ou
les extensions indiquent les types de certificat reconnus par le pair
TLS (si l'extension est absente, seul X.509 est reconu). Ainsi, un
serveur nouveau, intégrant les clés brutes, sait tout de suite si un
client pourrait les traiter (si le client n'a pas mis
<code>server_certificate_type</code>, ou bien si son
<code>server_certificate_type</code> n'inclut pas les clés
brutes, ce n'est pas la peine d'en envoyer). Si c'est le client qui
est nouveau et le serveur ancien, la réponse du serveur ne contiendra
pas les extensions et le client saura donc qu'il ne faut pas
s'attendre aux clés brutes. Si le serveur reconnait l'extension, mais
aucun des types de certificats indiqués, il termine la session. À noter que
ces clés brutes marchent avec tous les algorithmes de
cryptographie déjà reconnus.</p></div>
<div class="para"><p>La section 5 du RFC fournit des exemples de sessions TLS avec cette
nouvelle possibilité. Par exemple, ce dialogue montre un client qui
gère les clés brutes du serveur (et uniquement celles-ci, ce n'est
donc pas un navigateur Web typique) et un serveur qui
accepte d'envoyer sa clé ainsi. Le client n'est pas authentifié (il
n'envoie pas sa clé ou son certificat et ne se sert donc pas de <code>client_certificate_type</code>) :
</p><pre>

client_hello,
server_certificate_type=(RawPublicKey) // [1]
                       -&gt;
                       &lt;- server_hello,
                          server_certificate_type=(RawPublicKey), // [2]
                          certificate, // [3]
                          server_key_exchange,
                          server_hello_done

client_key_exchange,
change_cipher_spec,
finished               -&gt;

                       &lt;- change_cipher_spec,
                          finished

Application Data       &lt;-------&gt; Application Data

</pre><p>
Ce cas d'un client ne comprenant que les clés brutes est un cas qui
peut se produire pour l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20des%20objets" title="Consultez l'article &quot;Internet des objets&quot; de l'encyclopédie libre Wikipedia">Internet des
objets</a></b>, par exemple avec <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Constrained%20Application%20Protocol" title="Consultez l'article &quot;Constrained Application Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">CoAP</a></b>. Mais un client différent, par exemple un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/navigateur%20Web" title="Consultez l'article &quot;navigateur Web&quot; de l'encyclopédie libre Wikipedia">navigateur Web</a></b>, va accepter d'autres types de
certificats. Le dialogue pourrait ressembler à :
</p><pre>

client_hello,
server_certificate_type=(X.509, RawPublicKey)
client_certificate_type=(RawPublicKey) // [1]
                         -&gt;
                         &lt;-  server_hello,
                             server_certificate_type=(X.509)//[2]
                             certificate, // [3]
                             client_certificate_type=(RawPublicKey)//[4]
                             certificate_request, // [5]
                             server_key_exchange,
                             server_hello_done
certificate, // [6]
client_key_exchange,
change_cipher_spec,
finished                  -&gt;

                          &lt;- change_cipher_spec,
                             finished

Application Data        &lt;-------&gt;     Application Data

</pre><p>
Ici, le serveur reconnait la nouvelle extension mais ne sait envoyer
que des certificats X.509 (ce qui est donc fait par la suite). Le
client, lui, s'authentifie en envoyant une clé brute (même si ce
message est marqué <code>certificate</code> dans le dialogue).</p></div>
<div class="para"><p>Il existe apparemment déjà plusieurs mises en œuvre de TLS qui utilisent ces extensions.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7250.txt">Téléchargez le RFC 7250</a></p>
<br />
<a href="7250.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7284.txt">RFC 7284</a>: The Profile URI Registry</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : M. Lanthaler<br/>Pour information<br/>Première rédaction de cet article le 1 juillet 2014<br/></p><hr/>
<div class="para"><p>Le <a href="6906.html" class="rfc" title="Consultez l'analyse du RFC 6906">RFC 6906</a> définit la notion de
<b class="emphasis">profil</b>, une variante (en général restrictive)
d'un format. Les profils du <a href="6906.html" class="rfc" title="Consultez l'analyse du RFC 6906">RFC 6906</a> sont
identifiés par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Identifier" title="Consultez l'article &quot;Uniform Resource Identifier&quot; de l'encyclopédie libre Wikipedia">URI</a></b> et ce nouveau
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> crée un registre de ces URI, afin de
faciliter la tâche des développeurs.</p></div>
<div class="para"><p>Les conditions d'inscription dans le registre sont spécifiées dans
la section 2 : il faut indiquer l'URI qui sert d'identificateur, un nom
court pour le profil, la description et un lien vers une documentation stable du profil, accessible
publiquement. Ensuite (section 4), c'est du premier arrivé, premier servi
(politique décrite dans la section 4.1 du <a href="5226.html" class="rfc" title="Consultez l'analyse du RFC 5226">RFC 5226</a>).
La section 3 donne un exemple en utilisant un profil
bidon, <code>http://example.com/profiles/example</code>.</p></div>
<div class="para"><p>Le registre est <a href="http://www.iana.org/assignments/profile-uris/profile-uris.xhtml">désormais en ligne</a> et
comprend au début cinq profils :
</p><ul>
<li><code>urn:example:profile-uri</code>, prévu pour être
utilisé dans les exemples, documentations, etc,</li>
<li><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Dublin%20Core" title="Consultez l'article &quot;Dublin Core&quot; de l'encyclopédie libre Wikipedia">Dublin Core</a></b>
<code>http://dublincore.org/documents/2008/08/04/dc-html/</code>,
un moyen pour mettre les méta-données en
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Markup%20Language" title="Consultez l'article &quot;Hypertext Markup Language&quot; de l'encyclopédie libre Wikipedia">HTML</a></b>,</li>
<li><code>http://www.w3.org/ns/json-ld#expanded</code>,
<code>http://www.w3.org/ns/json-ld#compacted</code> et
<code>http://www.w3.org/ns/json-ld#flattened</code>, des
profils du monde <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/JavaScript%20Object%20Notation" title="Consultez l'article &quot;JavaScript Object Notation&quot; de l'encyclopédie libre Wikipedia">JSON</a></b> décrits dans <a href="http://www.w3.org/TR/json-ld/">une norme du W3C</a>.</li>  
</ul></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7284.txt">Téléchargez le RFC 7284</a></p>
<br />
<a href="7284.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7282.txt">RFC 7282</a>: On Consensus and Humming in the IETF</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : P. Resnick (Qualcomm)<br/>Pour information<br/>Première rédaction de cet article le 1 juillet 2014<br/></p><hr/>
<div class="para"><p>L'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b>, organisme de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Norme%20et%20standard%20techniques" title="Consultez l'article &quot;Norme et standard techniques&quot; de l'encyclopédie libre Wikipedia">normalisation</a></b> des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Protocole%20de%20communication" title="Consultez l'article &quot;Protocole de communication&quot; de l'encyclopédie libre Wikipedia">protocoles</a></b> de
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet" title="Consultez l'article &quot;Internet&quot; de l'encyclopédie libre Wikipedia">Internet</a></b>, fonctionne normalement par
« consensus ». Il n'y a pas de vote formel, pas de majorité qui
décide, on discute jusqu'à ce que
presque tout le monde soit d'accord. À cause du « presque », on parle
de « consensus approximatif » (<i class="foreign" xml:lang="en">rough consensus</i>). Ça,
c'est la théorie. En pratique, les évolutions récentes font que de
plus en plus de décisions sont prises suite à des opérations qui
ressemblent pas mal à des votes majoritaires, justement ce que les
règles de l'IETF voulaient éviter. D'où ce <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b>
d'opinion, écrit pour défendre le principe du consensus approximatif,
et pour appeler à se méfier de ces dérives.</p></div>
<div class="para"><p>Ce RFC a le statut « pour information » et représente le point de
vue de son auteur : ce n'est pas un document officiel. En outre, il ne
définit pas de nouvelles règles, il explique juste le fonctionnement
idéal. Pour
résumer ce RFC, revenons à la théorie. Le fonctionnement normal de
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> a été traduit par une percutante phrase
de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/David%20D.%20Clark" title="Consultez l'article &quot;David D. Clark&quot; de l'encyclopédie libre Wikipedia">Dave Clark</a></b> (dans « <i class="foreign" xml:lang="en"><a href="http://www.ietf.org/proceedings/24.pdf" hreflang="en">A Cloudy Crystal Ball - Visions of the
Future</a></i> »), que tous les participants à l'IETF connaissent par
cœur : « <i class="foreign" xml:lang="en">We reject kings, presidents and voting.
We believe in rough consensus and running code.</i> ». Les
décisions à l'IETF ne peuvent pas être prises par un seul individu
(roi ou président), mais elles ne doivent pas non plus être prises par
un vote, pour les raisons expliquées plus loin. Au contraire, elles
doivent s'appuyer sur le consensus approximatif, lui-même nourri
d'expérience concrète (le « <i class="foreign" xml:lang="en">running code</i> », par
opposition à des organisations comme l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Organisation%20internationale%20de%20normalisation" title="Consultez l'article &quot;Organisation internationale de normalisation&quot; de l'encyclopédie libre Wikipedia">ISO</a></b> qui
ont développé des usines à gaz impossibles à programmer). La pratique
doit toujours l'emporter : le code qui marche a raison.</p></div>
<div class="para"><p>Notez que le consensus est approximatif : avoir un consensus tout
court (tout le monde est d'accord ou, au moins, se tait) serait
l'idéal mais ce n'est pas réaliste. Demander un consensus complet
serait donner un droit de veto à n'importe quel individu négatif qui
s'oppose à tout (l'IETF, comme toute organisation humaine, a quelques
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Troll%20(Internet)" title="Consultez l'article &quot;Troll (Internet)&quot; de l'encyclopédie libre Wikipedia">trolls</a></b> de ce calibre...).</p></div>
<div class="para"><p>Comme il n'y a pas de vote, l'IETF a développé une autre pratique
inhabituelle, le mmmmmmmm (<i class="foreign" xml:lang="en">humming</i>). Lorsqu'on veut
avoir une idée de l'opinion des gens, lors d'une réunion physique, on
demande à chacun de se manifester par ce bruit produit en gardant la
bouche fermée (ce qui assure un certain secret, contrairement aux
mains levées). En faisant des mmmmmmmmm plus ou moins forts, on peut
même avoir un vote non-binaire. Ce rituel est souvent pratiqué pendant
les réunions IETF.</p></div>
<div class="para"><p>Mais tous les participants à l'IETF ne comprennent pas forcément
ces subtilités, surtout lorsqu'ils viennent d'arriver. « Pourquoi un
mmmmmm et pas un vote normal ? » ou « Il y avait une majorité de
mmmmmm en faveur de la proposition B, pourquoi continue-t-on de
discuter ? » Même quand le groupe de travail est arrivé à un résultat,
bien des participants ne comprennent pas comment il a été obtenu et
pensent que le processus a produit un mauvais résultat. Paradoxe : il
n'y a pas de consensus à l'IETF sur l'importance du consensus. Ou
plutôt, il y en a un en parole (la phrase de Clark est très souvent citée) mais
pas dans la réalité du travail.</p></div>
<div class="para"><p>Donc, premier point expliqué par ce RFC, en section 2, l'important
n'est pas que tout le monde soit d'accord, mais qu'il n'y ait pas trop
de désaccord. Imaginons un groupe qui doit trancher entre deux formats
pour un protocole (mettons <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/JavaScript%20Object%20Notation" title="Consultez l'article &quot;JavaScript Object Notation&quot; de l'encyclopédie libre Wikipedia">JSON</a></b> et
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Extensible%20Markup%20Language" title="Consultez l'article &quot;Extensible Markup Language&quot; de l'encyclopédie libre Wikipedia">XML</a></b>, pour prendre un exemple réel...). Il y a
des gens pour et des gens contre chacune des deux
propositions. Cela veut-il dire qu'il n'y aura jamais de consensus ?
Sauf que tout travail d'ingéniérie (et la création d'une norme
technique en est un) nécessite des compromis. Si on demande un accord
de tous, on ne l'aura jamais (surtout avec le goût des ingénieurs pour
les <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Parkinson's%20law%20of%20triviality" title="Consultez l'article &quot;Parkinson's law of triviality&quot; de l'encyclopédie libre Wikipedia (en anglais)">discussions sur la couleur du garage à vélos</a></b>). En revanche, si on demande qu'il n'y ait
pas d'objections bloquantes, on peut arriver à un résultat. Les
partisans de XML ne vont pas tout à coup préférer JSON. Par contre,
ils peuvent considérer que JSON, sans être leur solution préférée, est
acceptable, qu'il n'a pas de défaut qui mettrait vraiment en péril le
nouveau protocole. Il ne faut donc pas demander aux participants
« êtes-vous heureux avec ce choix ? » (il y aura forcément des
râleurs) mais plutôt « ce choix a t-il un
défaut rédhibitoire (et, si vous répondez oui, argumentez) ? » Bien
sûr, il faut quand même qu'il y ait un certain nombre de gens qui
soutiennent activement la proposition. Une solution technique qui ne
rencontrerait aucune objection, mais pas non plus de soutien actif ne
serait sans doute pas intéressante !</p></div>
<div class="para"><p>Autre point où il faut entrer dans les nuances, la différence entre
compromis et compromission. Le mot « compromis » (en français, comme
en anglais avec « <i class="foreign" xml:lang="en">compromise</i> ») est utilisé dans
deux sens différents. Le compromis est une bonne chose : en
ingéniérie, on a rarement des solutions idéales. Il faut en général
arbitrer et, par exemple, décider de sacrifier du temps
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Processeur" title="Consultez l'article &quot;Processeur&quot; de l'encyclopédie libre Wikipedia">CPU</a></b> pour consommer moins de ressources réseau
ou le contraire, ou bien mettre de la redondance pour assurer
l'intégrité alors qu'elle va diminuer les performances, ou encore préférer un format texte qui facilite le
déboguage à un format binaire plus efficace mais plus dur à traiter
par les humains. Ce genre de compromis est un travail normal et
essentiel de
l'ingénieur, et l'IETF le fait.</p></div>
<div class="para"><p>En revanche, les compromissions sont
néfastes : une compromission est quand on tient compte des opinions et
pas des principes d'ingéniérie. Par exemple qu'on accepte telle
option, qui semble inutile, voire dangereuse, parce qu'une partie du
groupe de travail trépigne et y tient absolument. On ajoute alors
l'option pour obtenir leur accord (ou leur non-désaccord), faisant
ainsi une compromission (ou un « <i class="foreign" xml:lang="en">design by
committee</i> », où le résultat n'enthousiasme personne, à force
d'avoir intégré plein de demandes contradictoires). Ce genre de
compromission (qu'il faudrait plutôt appeler capitulation) n'a pas
réglé les problèmes techniques. Pire, on peut voir ce que le RFC
désigne sous le nom de « <i class="foreign" xml:lang="en">horse trading</i> »
(comportement de maquignon ?) « Je ne suis pas d'accord
avec ta proposition sur l'algorithme de traitement de la congestion,
tu n'es pas d'accord avec ma proposition sur le format des données,
mettons-nous d'accord pour chacun soutenir la proposition de
l'autre. » Cela permet d'arriver à un accord mais au prix de la
qualité : les objections contre les deux propositions ont été
ignorées, alors qu'elles étaient peut-être sérieuses techniquement et
devaient être traitées comme telles. Ce comportement donne l'apparence
du consensus alors qu'il est de la pure magouille.</p></div>
<div class="para"><p>Deuxième point important, en section 3, le fait qu'il faut traiter
toutes les questions mais pas forcément les résoudre. Parfois, une
objection technique va être résolue à la satisfaction de tous : celui
qui l'a soulevée est convaincu que son objection était erronée, ou
bien le groupe de travail a été convaincu qu'elle était sérieuse et a
modifié le protocole en cours de discussion. Mais, parfois,
le groupe de travail ne change pas de direction et celui qui a soulevé
l'objection est frustré. Est-ce un échec du consensus ? Non, car il y
a toujours « consensus approximatif ». Celui-ci est une solution de
repli : l'idéal est le consensus complet mais, comme le dit le conte
« <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Le%20Meunier%2C%20son%20fils%20et%20l'%C3%82ne" title="Consultez l'article &quot;Le Meunier, son fils et l'Âne&quot; de l'encyclopédie libre Wikipedia">Le meunier, son fils et l'âne</a></b> », on ne peut pas
toujours plaire à tout le monde et, de
toute façon, il y a des gens qui ne sont jamais contents. La notion
de consensus approximatif est faite pour ces cas-là : l'objection n'a
pas été ignorée, elle a été sérieusement étudiée et le groupe de
travail a délibérement décidé de continuer dans la voie
originale. Compte-tenu de la forte personnalité de pas mal de
participants à l'IETF, le consensus seulement approximatif, qui
devrait être une exception à la règle du consensus, est souvent la norme.</p></div>
<div class="para"><p>Notez que ce consensus approximatif vu comme un repli lorsque le
consensus idéal n'est pas atteint est une description nouvelle. Le
<a href="http://www.rfc-editor.org/rfc/rfc1603.txt" class="rfc" title="Consultez le texte intégral du RFC 1603">RFC 1603</a> voyait plutôt le consensus approximatif comme
exprimant le « point de vue dominant » du groupe de travail
IETF. Cette vision quantitative (exprimée de manière encore plus
directe dans son successeur, le <a href="http://www.rfc-editor.org/rfc/rfc2418.txt" class="rfc" title="Consultez le texte intégral du RFC 2418">RFC 2418</a>) n'est pas partagée par ce nouveau <a href="http://www.rfc-editor.org/rfc/rfc7282.txt" class="rfc" title="Consultez le texte intégral du RFC 7282">RFC 7282</a>, qui met l'accent sur le fait que les 0,1 % qui sont
en désaccord ont peut-être raison (comme le disait un de mes
enseignants à la fac, « la science n'est pas une démocratie »).</p></div>
<div class="para"><p>Et le mmmmmmm ? La section 4 revient sur son rôle. D'abord,
pourquoi ne vote-t-on pas, à l'IETF (certainement la première
question que posent tous les nouveaux venus) ? D'abord, l'IETF n'a pas
de membres : il n'existe aucun processus formel d'adhésion. On
s'inscrit à la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/liste%20de%20diffusion" title="Consultez l'article &quot;liste de diffusion&quot; de l'encyclopédie libre Wikipedia">liste de diffusion</a></b> d'un groupe
de travail et, hop, on est un participant à l'IETF. Impossible donc,
de compter le corps électoral. Ensuite, le vote peut être une mauvaise
chose : comme indiqué plus haut (même si l'expression n'est pas dans
le RFC), la technique n'est pas démocratique. 51 % ou même 99 % d'un
groupe de travail peut toujours voter X, c'est peut-être quand même Y
qui est justifié techniquement. Le vote pourrait être un moyen de
glisser sous le tapis les problèmes gênants, qui doivent au contraire
être traités en pleine lumière. Une des raisons de l'utilisation du
mmmmmmm est donc, précisément par le caractère folkorique de la
procédure, de rappeler qu'on ne vote pas, à l'IETF (par comparaison
avec, disons, un vote à main levée).</p></div>
<div class="para"><p>Le mmmmmmm sert donc à jauger la situation et à ordonner la
discussion. Par exemple, s'il y a beaucoup plus de mmmmmmm objectant
contre X que contre Y, partir des objections contre Y peut permettre
d'optimiser le temps de discussion (sans pour autant considérer que Y
a « gagné »).</p></div>
<div class="para"><p>Malgré cela, un effet pervers s'est développé, avec des gens
considérant le mmmmmmm comme une sorte de vote anonyme. Ce n'est pas
son but, le mmmmmmm devrait être utilisé au début (pour avoir une idée
des points de vue en présence) pas à la fin pour clore le bec aux
minoritaires. Le mmmmmmm n'est pas une méthode magique, et,
s'il est mal utilisé, il a souvent les mêmes inconvénients que le vote
classique (par exemple une extrême sensibilité à la rédaction des
questions, ou même simplement à leur ordre).</p></div>
<div class="para"><p>Donc, le but, c'est le consensus ? Pas du tout. La section 5
insiste sur le fait que le consensus est un moyen et pas une fin. Le
consensus approximatif est un moyen d'obtenir la meilleure décision
technique possible, en s'assurant qu'aucune objection, aucun problème,
n'a été négligé. Au contraire, l'expérience des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Organisme%20de%20normalisation" title="Consultez l'article &quot;Organisme de normalisation&quot; de l'encyclopédie libre Wikipedia">SDO</a></b> qui votent a largement montré que cela mène
à des mauvaises décisions, notamment suite à des compromissions pour
obtenir une majorité, et suite au mépris des remarques parfaitement
valides des minoritaires.</p></div>
<div class="para"><p>Alors, évidemment, la méthode IETF prend du temps et est souvent
exaspérante, même pour les plus patients des participants. Et il ne
faut donc pas se faire d'illusions : les magouilles politiciennes
existent aussi à l'IETF.  Simplement, passer à un système plus rapide
comme le vote permettrait d'avoir plus vite des normes de moins bonne
qualité.</p></div>
<div class="para"><p>La section 6 revient sur la notion de majorité et sur l'approche
quantitative, qu'appuyait le <a href="http://www.rfc-editor.org/rfc/rfc2418.txt" class="rfc" title="Consultez le texte intégral du RFC 2418">RFC 2418</a> (« <i class="foreign" xml:lang="en">Note that 51%
of the working group does not qualify as "rough consensus" and 99% is
better than rough.</i> ») S'il y a 100 participants dans un
groupe qui trouvent la proposition en cours excellente, et la
soutiennent activement, et 5 participants qui sont
en désaccord, prédisant, par exemple, « ce protocole va créer de la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Congestion%20(r%C3%A9seau)" title="Consultez l'article &quot;Congestion (réseau)&quot; de l'encyclopédie libre Wikipedia">congestion</a></b> et n'a aucun mécanisme de réaction
en cas de congestion » et que personne ne répond de manière argumentée
à ce point, alors, il n'y a pas de consensus, même pas de consensus
approximatif. Une objection a été ignorée, pas traitée, et pas
rejetée. Le faible nombre d'opposants n'y change rien, on ne peut pas
parler d'un consensus, même pas approximatif. (Le RFC note que c'est
pareil si la ou les personnes qui ont soulevé l'objection ne sont pas
des participants réguliers, et qu'ils n'insistent pas après avoir fait
leurs remarques ; les remarques en question doivent quand même être
traitées.)</p></div>
<div class="para"><p>En sens inverse, et même si cela peut sembler anti-intuitif, on
peut avoir 5 personnes qui soutiennent un projet et 100 qui sont
contre, et qu'il y ait quand même un consensus en faveur du
projet (section 7). Comment est-ce possible ? Le RFC décrit une telle situation
(et des cas analogues se sont effectivement produits) : un groupe de
travail a peu de participants actifs. Ils sont arrivés à un consensus
malgré les objections de l'un d'entre eux, objection qui a été étudiée
et rejetée. Le « dissident » fait appel à une centaine de personnes,
parfois des participants à d'autres groupes de travail mais souvent
des employés de la même société que lui, qui ne connaissent rien au
sujet mais font ce qu'on leur dit. Ils envoient tous un message sur la
liste de diffusion, disant qu'ils soutiennent l'objection. Une bonne
façon de traiter ces soutiens vides (sans contenu nouveau) est de leur
demander « Nous avons déjà discuté de ce point et abouti à un
consensus. Avez-vous des éléments techniques nouveaux qui
justifieraient de rouvrir la discussion ? » En général, les
commerciaux et marketeux qui avaient été recrutés pour faire masse dans
la discussion ne répondent pas... Ils croyaient que l'IETF
fonctionnait sur un système de vote et sont surpris de découvrir qu'on
leur demande d'argumenter. Bien sûr, ce cas est un peu extrême mais la
même méthode peut servir dans des cas moins dramatiques. Le principe
du consensus sert à traiter une des plus grosses failles des systèmes
de vote : le bourrage des urnes par des ignorants.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7282.txt">Téléchargez le RFC 7282</a></p>
<br />
<a href="7282.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="fr">Exposé « Tous à poil » à Pas Sage en Seine</h2><p>Première rédaction de cet article le 27 juin 2014<br/>Dernière mise à jour le 30 juin 2014<br/></p><hr/><div xml:lang="fr">
<div class="para"><p>Le 26 juin, j'ai eu le plaisir de livrer quelques réflexions sur
l'utilisation de la transparence pour la sécurité des protocoles
réseaux, à l'évènement « <a href="http://www.passageenseine.org/Passage">Pas Sage en Seine</a> » à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Paris" title="Consultez l'article &quot;Paris&quot; de l'encyclopédie libre Wikipedia">Paris</a></b>, l'évènement qui rassemble tous les
regards critiques et novateurs sur le numérique, l'Internet et bien
d'autres choses. Sous le titre de « Tous à poil » (titre choisi pour
des raisons de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Optimisation%20pour%20les%20moteurs%20de%20recherche" title="Consultez l'article &quot;Optimisation pour les moteurs de recherche&quot; de l'encyclopédie libre Wikipedia">SEO</a></b>), je parlais de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/bitcoin" title="Consultez l'article &quot;bitcoin&quot; de l'encyclopédie libre Wikipedia">bitcoin</a></b>, de <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Namecoin" title="Consultez l'article &quot;Namecoin&quot; de l'encyclopédie libre Wikipedia (en anglais)">Namecoin</a></b>,
d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Usenet" title="Consultez l'article &quot;Usenet&quot; de l'encyclopédie libre Wikipedia">Usenet</a></b> et même de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Border%20Gateway%20Protocol" title="Consultez l'article &quot;Border Gateway Protocol&quot; de l'encyclopédie libre Wikipedia">BGP</a></b>.</p></div>
<div class="para"><p>Voici les supports de cet exposé :
</p><ul>
<li>Version adaptée <a class="local-file" href="files/tous-a-poil-ecran.pdf" title="Récupérez le fichier &quot;tous-a-poil-ecran.pdf&quot;">à la lecture
sur écran</a>,</li>
<li>Version adaptée <a class="local-file" href="files/tous-a-poil-impression.pdf" title="Récupérez le fichier &quot;tous-a-poil-impression.pdf&quot;">à
l'impression</a>,</li>
<li><a class="local-file" href="files/tous-a-poil.tex" title="Récupérez le fichier &quot;tous-a-poil.tex&quot;">Source</a>,</li>
<li>Et <a href="http://numaparis.ubicast.tv/videos/bortzmeyer/">la
vidéo</a> (également <a href="http://www.youtube.com/watch?v=28v0M5NkdL0">sur YouTube</a>,
si on veut augmenter ses chances d'être suivi par la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/National%20Security%20Agency" title="Consultez l'article &quot;National Security Agency&quot; de l'encyclopédie libre Wikipedia">NSA</a></b>).</li>
</ul></div>
<div class="para"><p>Parmi les exemples de systèmes de sécurité fonctionnant sur la
transparence, j'ai oublié de mentionner le <a href="http://www.itconsult.co.uk/stamper.htm">Stamper</a>. J'aurais
dû. Pour les autres sujets que je mentionnais :
</p><ul>
<li>La <i class="foreign" xml:lang="en">Certificate Transparency</i> est décrite dans
le <a href="6962.html" class="rfc" title="Consultez l'analyse du RFC 6962">RFC 6962</a>.</li>
<li>La transparence de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Border%20Gateway%20Protocol" title="Consultez l'article &quot;Border Gateway Protocol&quot; de l'encyclopédie libre Wikipedia">BGP</a></b> a été utilisée
pour <a href="panne-saint-pierre-miquelon.html" title="Consultez ce blog à propos de &quot;panne-saint-pierre-miquelon&quot;">une analyse de
panne</a>, des <a href="alarmes-as.html" title="Consultez ce blog à propos de &quot;alarmes-as&quot;">systèmes d'alerte</a>,
un <a href="http://www.afnic.fr/fr/l-afnic-en-bref/actualites/actualites-generales/7114/show/l-observatoire-sur-la-resilience-de-l-internet-francais-publie-son-rapport-2012.html">rapport
sur la résilience de l'Internet</a>, etc.</li>
</ul></div>
</div>
<br />
<a href="tousapoil.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7276.txt">RFC 7276</a>: An Overview of Operations, Administration, and Maintenance (OAM) Tools</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : T. Mizrahi (Marvell), N. Sprecher (Nokia Solutions and Networks), E. Bellagamba (Ericsson), Y. Weingarten<br/>Pour information<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/opsawg">opsawg</a></b><br/>Première rédaction de cet article le 25 juin 2014<br/></p><hr/>
<div class="para"><p>Ce <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> est entièrement consacré à la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Gestion%20de%20r%C3%A9seaux%20(informatique)" title="Consultez l'article &quot;Gestion de réseaux (informatique)&quot; de l'encyclopédie libre Wikipedia">gestion de réseaux</a></b>. Quels sont les outils
existants dans les réseaux <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/TCP/IP" title="Consultez l'article &quot;TCP/IP&quot; de l'encyclopédie libre Wikipedia">TCP/IP</a></b>, notamment
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet" title="Consultez l'article &quot;Internet&quot; de l'encyclopédie libre Wikipedia">Internet</a></b> ? Ce RFC est destiné aux opérateurs
réseau, aux fournisseurs d'équipements et de logiciels réseau, et aux gens de la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Norme%20et%20standard%20techniques" title="Consultez l'article &quot;Norme et standard techniques&quot; de l'encyclopédie libre Wikipedia">normalisation</a></b>, pour
s'assurer qu'ils ont une base d'information commune sur les outils existants.</p></div>
<div class="para"><p>La gestion de réseaux est ici désignée par le sigle
<b class="emphasis">OAM</b> qui signifie <i class="foreign" xml:lang="en">Operations,
Administration, and Maintenance</i>. OAM est défini dans le <a href="http://www.rfc-editor.org/rfc/rfc6291.txt" class="rfc" title="Consultez le texte intégral du RFC 6291">RFC 6291</a>. Les outils de l'OAM sont
tous les dispositifs qui permettent de détecter un problème et de
l'isoler, ou bien de mesurer les performances. (Les outils permettant
de configurer les équipements réseaux ne sont pas traités ici.) Ce nouveau
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> couvre les outils utilisés dans des
contextes très divers, d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b> à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multiprotocol%20Label%20Switching" title="Consultez l'article &quot;Multiprotocol Label Switching&quot; de l'encyclopédie libre Wikipedia">MPLS</a></b> en passant par
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/TRILL%20(computing)" title="Consultez l'article &quot;TRILL (computing)&quot; de l'encyclopédie libre Wikipedia (en anglais)">TRILL</a></b> mais je ne vais parler que des outils IP,
ceux que je connais.</p></div>
<div class="para"><p>Ce RFC décrit les outils, logiciels mettant en œuvre un protocole particulier. Une liste des
protocoles normalisés par l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> pour l'OAM est
dans le <a href="6632.html" class="rfc" title="Consultez l'analyse du RFC 6632">RFC 6632</a>. Par exemple,
OWAMP (<a href="4656.html" class="rfc" title="Consultez l'analyse du RFC 4656">RFC 4656</a>) est un
protocole, le <a href="http://e2epi.internet2.edu/owamp/">programme distribué par
Internet 2</a> est un outil mettant en œuvre ce protocole.</p></div> 
<div class="para"><p>Tous les réseaux sont bien sûr gérés, et tous ont évidemment des
dispositifs d'OAM, plus ou moins perfectionnés. On a donc :
</p><ul>
<li>O (pour <i class="foreign" xml:lang="en">Operations</i>) : tout ce qui contribue à
ce que le réseau reste « <i class="foreign" xml:lang="en">up &amp; running</i> » en
détectant les problèmes (et en les résolvant) avant même que
l'utilisateur ne s'en aperçoive.</li>
<li>A (pour <i class="foreign" xml:lang="en">Administration</i>) : garder à jour la
liste des ressources et surveiller leur utilisation.</li>
<li>M (pour <i class="foreign" xml:lang="en">Maintenance</i>) : 
permettre les réparations et les évolutions (mise à jour du logiciel du
routeur, par exemple).
</li>
</ul></div>
<div class="para"><p>Parfois, ces
dispositifs d'OAM ont été ajoutés après, en utilisant
(souvent de manière créative) les fonctions disponibles. De nos jours,
on tend à prévoir l'OAM dès le début, comme ce fut le cas pour
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Asynchronous%20Transfer%20Mode" title="Consultez l'article &quot;Asynchronous Transfer Mode&quot; de l'encyclopédie libre Wikipedia">ATM</a></b>.</p></div>
<div class="para"><p>Notre RFC commence (section 2) par des rappels de concept et de
terminologie (outre le <a href="http://www.rfc-editor.org/rfc/rfc6291.txt" class="rfc" title="Consultez le texte intégral du RFC 6291">RFC 6291</a>, déjà cité, le
<a href="http://www.rfc-editor.org/rfc/rfc7087.txt" class="rfc" title="Consultez le texte intégral du RFC 7087">RFC 7087</a> définit les termes spécifiques à <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multiprotocol%20Label%20Switching" title="Consultez l'article &quot;Multiprotocol Label Switching&quot; de l'encyclopédie libre Wikipedia">MPLS</a></b>). D'abord, données vs. contrôle : on distingue souvent dans un équipement réseau le sous-système des
données (<i class="foreign" xml:lang="en">data plane</i> ou <i class="foreign" xml:lang="en">user plane</i>) et le sous-système de
contrôle (<i class="foreign" xml:lang="en">control plane</i>). Le premier désigne toutes
les fonctions qui contribuent à transmettre les
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Paquet%20(r%C3%A9seau)" title="Consultez l'article &quot;Paquet (réseau)&quot; de l'encyclopédie libre Wikipedia">paquets</a></b> (et donc les données) à l'équipement
suivant. Le second, le sous-système de contrôle, comprend les
fonctions qui permettent d'établir dynamiquement les informations dont
le sous-système des données va avoir besoin. Par exemple, dans un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/routeur" title="Consultez l'article &quot;routeur&quot; de l'encyclopédie libre Wikipedia">routeur</a></b>, le sous-système des données est
composé des fonctions qui font passer le paquet d'une interface
d'entrée à une interface de sortie (rôle de <i class="foreign" xml:lang="en">forwarding</i>), alors que le sous-système de
contrôle (rôle de <i class="foreign" xml:lang="en">routing</i>) comprend notamment les fonctions de calcul de la table de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/routage" title="Consultez l'article &quot;routage&quot; de l'encyclopédie libre Wikipedia">routage</a></b> (les mises en œuvre
d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Open%20shortest%20path%20first" title="Consultez l'article &quot;Open shortest path first&quot; de l'encyclopédie libre Wikipedia">OSPF</a></b>, de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Border%20Gateway%20Protocol" title="Consultez l'article &quot;Border Gateway Protocol&quot; de l'encyclopédie libre Wikipedia">BGP</a></b>, etc),
table de routage qu'utilisera le sous-système des données lors de la
transmission. Si le routeur est une machine
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unix" title="Consultez l'article &quot;Unix&quot; de l'encyclopédie libre Wikipedia">Unix</a></b>, le sous-système de données est mis en
œuvre dans le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Noyau%20de%20syst%C3%A8me%20d'exploitation" title="Consultez l'article &quot;Noyau de système d'exploitation&quot; de l'encyclopédie libre Wikipedia">noyau</a></b>, alors que celui de
contrôle l'est par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Daemon%20(informatique)" title="Consultez l'article &quot;Daemon (informatique)&quot; de l'encyclopédie libre Wikipedia">démon</a></b> séparé, genre
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Quagga%20(logiciel)" title="Consultez l'article &quot;Quagga (logiciel)&quot; de l'encyclopédie libre Wikipedia">Quagga</a></b> ou <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Bird%20Internet%20routing%20daemon" title="Consultez l'article &quot;Bird Internet routing daemon&quot; de l'encyclopédie libre Wikipedia (en anglais)">BIRD</a></b>. La
distinction entre sous-systèmes de contrôle et de données n'est pas
seulement conceptuelle, ni limitée au logiciel. Dans un routeur
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Juniper%20Networks" title="Consultez l'article &quot;Juniper Networks&quot; de l'encyclopédie libre Wikipedia">Juniper</a></b> ou <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cisco%20Systems" title="Consultez l'article &quot;Cisco Systems&quot; de l'encyclopédie libre Wikipedia">Cisco</a></b> moyen
ou haut de gamme, c'est même du matériel différent
(<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Application%20Specific%20Integrated%20Circuit" title="Consultez l'article &quot;Application Specific Integrated Circuit&quot; de l'encyclopédie libre Wikipedia">ASIC</a></b> pour les données,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Processeur" title="Consultez l'article &quot;Processeur&quot; de l'encyclopédie libre Wikipedia">CPU</a></b> généraliste pour le contrôle). L'OAM, tel
qu'utilisé ici, mesure et teste le sous-système de données, mais il
peut utiliser des informations fournies par le sous-système de
contrôle, et être piloté par lui. (On voit parfois, par exemple dans
le <a href="http://www.rfc-editor.org/rfc/rfc6123.txt" class="rfc" title="Consultez le texte intégral du RFC 6123">RFC 6123</a>, un troisième sous-système, le sous-système de gestion, le
<i class="foreign" xml:lang="en">management plane</i>. De toute façon, la différence
entre ces sous-systèmes n'est pas forcément claire et nette dans tous
les cas.)</p></div>
<div class="para"><p>Encore un peu de terminologie : les outils peuvent être « à la
demande » ou bien « proactifs ». Les premiers sont déclenchés
lorsqu'il y a un problème (c'est l'administrateur réseaux à qui on dit
« le serveur ne marche pas » et qui lance <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ping%20(logiciel)" title="Consultez l'article &quot;ping (logiciel)&quot; de l'encyclopédie libre Wikipedia">ping</a></b>
tout de suite), les seconds tournent en permanence, par exemple pour
détecter et signaler les pannes.</p></div>
<div class="para"><p>Quelle sont les fonctions précises d'un logiciel d'OAM ? Notre RFC
cite le test de la connectivité, la découverte du chemin, la localisation
d'un problème, et des mesures liées aux performances comme la mesure
du taux de perte de paquets, ou comme la mesure des délais d'acheminement.</p></div>
<div class="para"><p>On entend parfois parler de « tests de continuité » et de « tests
de connectivité ». Ces termes viennent de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multiprotocol%20Label%20Switching" title="Consultez l'article &quot;Multiprotocol Label Switching&quot; de l'encyclopédie libre Wikipedia">MPLS</a></b>
(<a href="http://www.rfc-editor.org/rfc/rfc5860.txt" class="rfc" title="Consultez le texte intégral du RFC 5860">RFC 5860</a>) et désignent, dans le premier cas, un test que les
paquets peuvent passer et, dans le second, que deux systèmes sont
effectivement connectés, et par le chemin attendu (IP, étant sans
connexion, n'a guère besoin de ces tests de connectivité).</p></div>
<div class="para"><p>En parlant de connexion, le monde <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/TCP/IP" title="Consultez l'article &quot;TCP/IP&quot; de l'encyclopédie libre Wikipedia">TCP/IP</a></b>
comprend des protocoles avec connexion et des protocoles sans. L'OAM
concerne ces deux groupes et les outils présentés dans ce RFC couvrent
les deux. Un test utilisant un protocole sans connexion
(<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ping%20(logiciel)" title="Consultez l'article &quot;ping (logiciel)&quot; de l'encyclopédie libre Wikipedia">ping</a></b> est l'exemple archétypal) peut 
emprunter un autre chemin, d'autres ressources (et donc donner un
autre résultat), qu'une utilisation réelle du réseau. Au contraire, en
testant un protocole avec connexion (<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b>, par
exemple), on utilise les mêmes ressources que les vraies
données. Notez aussi que des protocoles sans connexion peuvent être
testés par des protocoles avec connexion, le RFC donnant l'exemple
d'un test d'IP fait avec <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Bidirectional%20Forwarding%20Detection" title="Consultez l'article &quot;Bidirectional Forwarding Detection&quot; de l'encyclopédie libre Wikipedia (en anglais)">BFD</a></b> (<a href="5880.html" class="rfc" title="Consultez l'analyse du RFC 5880">RFC 5880</a>).</p></div>
<div class="para"><p>Enfin, dernier point de terminologie, les mots utilisés pour les
problèmes. Il n'existe pas une norme unique et acceptée pour ces
mots. Suivant la norme <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/G.806" title="Consultez l'article &quot;G.806&quot; de l'encyclopédie libre Wikipedia (en anglais)">ITU-T G.806</a></b>, notre RFC
fait une différence entre défaillance (<i class="foreign" xml:lang="en">fault</i>), qui est
l'incapacité à effectuer une tâche, comme de livrer un paquet,
interruption (<i class="foreign" xml:lang="en">defect</i>), qui est un arrêt temporaire
d'un service et panne (<i class="foreign" xml:lang="en">failure</i>). Cette
dernière, au contraire de l'interruption, n'est pas un accident ponctuel et elle peut durer longtemps.</p></div>
<div class="para"><p>Bien, après tous ces préliminaires, les outils eux-mêmes, présentés
en section 4 du RFC. À tout seigneur, tout honneur, on va évidemment
commence par l'outil emblématique de l'OAM,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ping%20(logiciel)" title="Consultez l'article &quot;ping (logiciel)&quot; de l'encyclopédie libre Wikipedia">ping</a></b>. Il envoie un paquet
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Control%20Message%20Protocol" title="Consultez l'article &quot;Internet Control Message Protocol&quot; de l'encyclopédie libre Wikipedia">ICMP</a></b> de type « demande d'écho » et la réception
d'un paquet ICMP de réponse indiquera que la connectivité est
complète. Il donnera également quelques indicateurs de performance comme le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Round-Trip%20delay%20Time" title="Consultez l'article &quot;Round-Trip delay Time&quot; de l'encyclopédie libre Wikipedia">RTT</a></b>, affiché après <i class="foreign" xml:lang="en">time=</i> : 
</p><pre>
% ping -c 3 www.ietf.org
PING www.ietf.org (4.31.198.44) 56(84) bytes of data.
64 bytes from mail.ietf.org (4.31.198.44): icmp_req=1 ttl=44 time=227 ms
64 bytes from mail.ietf.org (4.31.198.44): icmp_req=2 ttl=44 time=222 ms
64 bytes from mail.ietf.org (4.31.198.44): icmp_req=3 ttl=44 time=223 ms

--- www.ietf.org ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2004ms
rtt min/avg/max/mdev = 222.689/224.685/227.533/2.067 ms
</pre><p>
Certaines versions de ping peuvent faire
des tests avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b> plutôt qu'ICMP. ping donne un
point de vue unilatéral, celui du côté qui initie la connexion. Si on
veut le point de vue du pair, il faut que celui-ci fasse un test de son
côté (par exemple, s'il y a un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feu</a></b> à état
entre les deux machines, un des tests peut échouer même si l'autre
réussit). Malheureusement, il arrive que ces paquets ICMP soient
filtrés (par exemple, suite à l'incompétence de l'administrateur qui
croit que l'attaque mal nommée <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Ping%20of%20death" title="Consultez l'article &quot;Ping of death&quot; de l'encyclopédie libre Wikipedia (en anglais)">ping of death</a></b></i> a un rapport avec ping
alors qu'elle n'en a pas).</p></div>
<div class="para"><p>Après ping, l'outil d'OAM le plus connu et le plus utilisé est sans
doute <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/traceroute" title="Consultez l'article &quot;traceroute&quot; de l'encyclopédie libre Wikipedia">traceroute</a></b>. Comme ping, il n'y a pas de
texte sacré de référence le décrivant. À l'époque, on codait d'abord,
on documentait ensuite (parfois). Les textes les plus canoniques sur
traceroute semblent être les <a href="http://www.rfc-editor.org/rfc/rfc1470.txt" class="rfc" title="Consultez le texte intégral du RFC 1470">RFC 1470</a> et <a href="http://www.rfc-editor.org/rfc/rfc2151.txt" class="rfc" title="Consultez le texte intégral du RFC 2151">RFC 2151</a>.</p></div>
<div class="para"><p>traceroute sert à découvrir le chemin pris par les paquets entre
l'initiateur de la requête et une cible. Il envoie un paquet
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b> à destination du
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Port%20(logiciel)" title="Consultez l'article &quot;Port (logiciel)&quot; de l'encyclopédie libre Wikipedia">port</a></b> 33434 en mettant dans l'en-tête
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b> un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Time%20to%20Live#Le_Time_to_Live_sur_les_paquets_IP" title="Consultez l'article &quot;Time to Live&quot; de l'encyclopédie libre Wikipedia">TTL</a></b> inhabituel, de
1. Vu avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/tcpdump" title="Consultez l'article &quot;tcpdump&quot; de l'encyclopédie libre Wikipedia">tcpdump</a></b>, cela donne (notez le
<code>ttl 1</code>) :
</p><pre>
22:10:20.369307 IP (tos 0x0, ttl 1, id 19164, offset 0, flags [none], proto UDP (17), length 60)
    192.168.2.1.44024 &gt; 213.154.224.1.33434: UDP, length 32
</pre><p>
Le premier <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/routeur" title="Consultez l'article &quot;routeur&quot; de l'encyclopédie libre Wikipedia">routeur</a></b> rencontré va donc
considérer ce paquet comme trop ancien, le jeter, et envoyer un paquet
ICMP de type <i class="foreign" xml:lang="en">Time exceeded</i> à la source, qui aura
ainsi l'adresse IP du premier routeur :
</p><pre>
22:17:46.359084 IP (tos 0xc0, ttl 64, id 64893, offset 0, flags [none], proto ICMP (1), length 88)
    192.168.2.254 &gt; 192.168.2.1: ICMP time exceeded in-transit, length 68
	IP (tos 0x0, ttl 1, id 19239, offset 0, flags [none], proto UDP (17), length 60)
    192.168.2.1.34315 &gt; 213.154.224.1.33434: UDP, length 32
</pre><p>
Ensuite, traceroute itère : il incrémente le numéro de port et le TTL
et trouve ainsi le deuxième routeur. Le jeu s'arrête lorsque traceroute
reçoit un paquet ICMP <i class="foreign" xml:lang="en">Port unreachable</i> lorsque le
paquet UDP atteint sa cible et que celle-ci, n'ayant pas de service
sur ce port, répondra négativement :
</p><pre>
22:19:20.648790 IP (tos 0x0, ttl 53, id 11453, offset 0, flags [none], proto ICMP (1), length 56)
    213.136.31.102 &gt; 192.168.2.1: ICMP 213.154.224.1 udp port 33445 unreachable, length 36
	IP (tos 0x0, ttl 1, id 19325, offset 0, flags [none], proto UDP (17), length 60)
    192.168.2.1.57471 &gt; 213.154.224.1.33445: UDP, length 32
</pre><p>
Utilisant toutes ces informations, traceroute peut alors afficher le
chemin :
</p><pre>
% traceroute -q 1 www.nlnetlabs.nl
traceroute to www.nlnetlabs.nl (213.154.224.1), 30 hops max, 60 byte packets
 1  freebox (192.168.2.254)  13.646 ms
 2  88.189.152.254 (88.189.152.254)  37.136 ms
 3  78.254.1.62 (78.254.1.62)  37.133 ms
 4  rke75-1-v900.intf.nra.proxad.net (78.254.255.42)  46.845 ms
 5  cev75-1-v902.intf.nra.proxad.net (78.254.255.46)  39.030 ms
 6  p16-6k-1-po12.intf.nra.proxad.net (78.254.255.50)  43.658 ms
 7  bzn-crs16-1-be1024.intf.routers.proxad.net (212.27.56.149)  43.662 ms
 8  bzn-crs16-1-be1106.intf.routers.proxad.net (212.27.59.101)  43.637 ms
 9  londres-6k-1-po101.intf.routers.proxad.net (212.27.51.186)  55.973 ms
10  *
11  amsix-501.xe-0-0-0.jun1.bit-1.network.bit.nl (195.69.144.200)  60.693 ms
12  nlnetlabs-bit-gw.nlnetlabs.nl (213.136.31.102)  62.287 ms
</pre><p>
(On note que le routeur n° 10 a refusé de répondre, ce qui arrive, ou
que sa réponse s'est perdue, ce qui arrive aussi.)</p></div>
<div class="para"><p>Sur une machine <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unix" title="Consultez l'article &quot;Unix&quot; de l'encyclopédie libre Wikipedia">Unix</a></b> d'aujourd'hui, il
existe souvent plusieurs mises en œuvre différentes de
traceroute. traceroute est une idée, pas un programme unique. Par
exemple, <a href="http://www.paris-traceroute.net/">Paris traceroute</a> fait varier l'en-tête
IP pour essayer de découvrir plusieurs chemins lorsqu'il y a de
l'<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Equal-cost%20multi-path%20routing" title="Consultez l'article &quot;Equal-cost multi-path routing&quot; de l'encyclopédie libre Wikipedia (en anglais)">ECMP</a></b>. Des traceroutes ont des options pour
utiliser ICMP et pas UDP (c'est le cas des <a href="traceroute-atlas.html" title="Consultez ce blog à propos de &quot;traceroute-atlas&quot;">sondes Atlas</a>). Il existe des
extensions à ICMP pour rendre traceroute plus utile, comme celles du
<a href="4950.html" class="rfc" title="Consultez l'analyse du RFC 4950">RFC 4950</a> ou <a href="5837.html" class="rfc" title="Consultez l'analyse du RFC 5837">RFC 5837</a>.</p></div>
<div class="para"><p>Attention aux limites de traceroute : il ne montre que le chemin
aller. Le routage sur l'Internet pouvant être asymétrique, rien ne dit
que le chemin de retour sera le même.</p></div>
<div class="para"><p>Après, le RFC passe à des outils moins connus du grand
public. D'abord, les outils <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Bidirectional%20Forwarding%20Detection" title="Consultez l'article &quot;Bidirectional Forwarding Detection&quot; de l'encyclopédie libre Wikipedia (en anglais)">BFD</a></b>. Normalisé dans
le <a href="5880.html" class="rfc" title="Consultez l'analyse du RFC 5880">RFC 5880</a>, BFD permet de tester la
connectivité dans le contexte d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol" title="Consultez l'article &quot;Internet Protocol&quot; de l'encyclopédie libre Wikipedia">IP</a></b> (<a href="5881.html" class="rfc" title="Consultez l'analyse du RFC 5881">RFC 5881</a>) mais aussi
de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multiprotocol%20Label%20Switching" title="Consultez l'article &quot;Multiprotocol Label Switching&quot; de l'encyclopédie libre Wikipedia">MPLS</a></b> (<a href="http://www.rfc-editor.org/rfc/rfc5884.txt" class="rfc" title="Consultez le texte intégral du RFC 5884">RFC 5884</a>) et de bien
d'autres. Il fonctionne en mode connecté : les deux machines
établissent une session BFD. Ensuite, elles échangent des paquets BFD,
soit périodiquement, soit à la demande. La bonne arrivée de ces
paquets indique que la connexion avec le pair fonctionne. Il existe
aussi un mode où BFD envoie des paquets « demande
d'écho » et attend une réponse.</p></div>
<div class="para"><p>Il existe ensuite plusieurs outils d'OAM pour le monde
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Multiprotocol%20Label%20Switching" title="Consultez l'article &quot;Multiprotocol Label Switching&quot; de l'encyclopédie libre Wikipedia">MPLS</a></b>, le plus important étant LSP-Ping, décrit
dans le <a href="http://www.rfc-editor.org/rfc/rfc4379.txt" class="rfc" title="Consultez le texte intégral du RFC 4379">RFC 4379</a>. S'il assure des fonctions analogues à ping,
comme son nom l'indique, il en fait aussi qui sont équivalentes à
traceroute. Répondre à une demande d'écho est moins trivial en MPLS
qu'en IP. Par exemple, un chemin (un LSP, <i class="foreign" xml:lang="en">Label Switched
Path</i>) peut n'être établi que dans une seule direction,
rendant impossible de répondre en MPLS à un LSP-Ping.</p></div>
<div class="para"><p>Les autres outils MPLS sont décrits en détail dans les sections 4.4
et 4.5 de notre RFC. Sinon, la problématique générale de l'OAM en
environnement MPLS est dans les <a href="http://www.rfc-editor.org/rfc/rfc4377.txt" class="rfc" title="Consultez le texte intégral du RFC 4377">RFC 4377</a> et <a href="http://www.rfc-editor.org/rfc/rfc4378.txt" class="rfc" title="Consultez le texte intégral du RFC 4378">RFC 4378</a>. (L'OAM de MPLS a d'ailleurs suscité un affrontement
entre l'IETF et l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Union%20internationale%20des%20t%C3%A9l%C3%A9communications" title="Consultez l'article &quot;Union internationale des télécommunications&quot; de l'encyclopédie libre Wikipedia">UIT</a></b>, le point de vue de
l'IETF étant exposé dans le <a href="http://www.rfc-editor.org/rfc/rfc5704.txt" class="rfc" title="Consultez le texte intégral du RFC 5704">RFC 5704</a>.)</p></div>
<div class="para"><p>ping sur un réseau IP a plusieurs limites : il mesure un
aller-retour (alors que les chemins peuvent être différents, avec des
caractéristiques très différentes), et il n'est pas défini avec une
grande précision donc la sémantique du <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Round-Trip%20delay%20Time" title="Consultez l'article &quot;Round-Trip delay Time&quot; de l'encyclopédie libre Wikipedia">RTT</a></b>, par
exemple, n'est pas rigoureuse. L'IETF, via son groupe de travail <a href="/search?pattern=ippm">IPPM</a>, a deux protocoles qui traitent
ces limites, OWAMP et
TWAMP. Outre des définitions rigoureuses de
métriques comme le délai d'acheminement aller-simple (<a href="2679.html" class="rfc" title="Consultez l'analyse du RFC 2679">RFC 2679</a>), ou comme la connectivité (<a href="http://www.rfc-editor.org/rfc/rfc2678.txt" class="rfc" title="Consultez le texte intégral du RFC 2678">RFC 2678</a>), IPPM a produit ces deux protocoles qui établissent
une session de contrôle entre deux points, sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transmission%20Control%20Protocol" title="Consultez l'article &quot;Transmission Control Protocol&quot; de l'encyclopédie libre Wikipedia">TCP</a></b>, avant de lancer une mesure
précise avec <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b>. OWAMP (<a href="4656.html" class="rfc" title="Consultez l'analyse du RFC 4656">RFC 4656</a>) mesure un aller-simple
alors que TWAMP (<a href="5357.html" class="rfc" title="Consultez l'analyse du RFC 5357">RFC 5357</a>) mesure un
aller-retour (comme ping).</p></div>
<div class="para"><p>À noter que, pour mesurer les performances, il existe bien d'autres
outils comme les <a href="ethernet-oam.html" title="Consultez ce blog à propos de &quot;ethernet-oam&quot;">outils OAM d'Ethernet</a>.</p></div>
<div class="para"><p>Enfin, la section 4 se termine par une section sur
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/TRILL%20(computing)" title="Consultez l'article &quot;TRILL (computing)&quot; de l'encyclopédie libre Wikipedia (en anglais)">TRILL</a></b> (<a href="http://www.rfc-editor.org/rfc/rfc6325.txt" class="rfc" title="Consultez le texte intégral du RFC 6325">RFC 6325</a>). Trop récent, ce système n'a pas encore
beaucoup d'outils OAM. Il existe un cahier des charges pour ces
outils, le <a href="6905.html" class="rfc" title="Consultez l'analyse du RFC 6905">RFC 6905</a>, qui demande des outils pour
tester la connectivité, découvrir le chemin suivant et mesurer des
indicateurs comme le temps d'acheminement d'un paquet.</p></div>
<div class="para"><p>La section 5 du RFC résume tous les outils décrits, sous forme d'un
tableau donnant le nom des outils, un résumé de leur fonctionnement,
et le protocole auquel ils s'appliquent (IP, MPLS, TRILL,
etc). Pratique pour les lecteurs pressés.</p></div>
<div class="para"><p>Il reste enfin la classique section de sécurité, la section 6. Un
système d'OAM soulève évidemment des enjeux de sécurité. Par exemple,
un attaquant qui contrôle l'OAM pourrait créer l'illusion de pannes
non-existantes, forçant les équipes du réseau à perdre du temps. Ou il
pourrait empêcher la détection de pannes réelles, ce qui aggraverait
le déni de service.</p></div>
<div class="para"><p>Certains des outils d'OAM présentés dans ce RFC ont des fonctions
de sécurité, empêchant par exemple la modification des données par un
tiers. BFD a un mécanisme d'authentification. OWAMP et TWAMP peuvent
authentifier (via un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Keyed-Hash%20Message%20Authentication%20Code" title="Consultez l'article &quot;Keyed-Hash Message Authentication Code&quot; de l'encyclopédie libre Wikipedia">HMAC</a></b>) et/ou chiffrer leurs
communications (en <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Advanced%20Encryption%20Standard" title="Consultez l'article &quot;Advanced Encryption Standard&quot; de l'encyclopédie libre Wikipedia">AES</a></b>). Ceci dit, la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/confidentialit%C3%A9" title="Consultez l'article &quot;confidentialité&quot; de l'encyclopédie libre Wikipedia">confidentialité</a></b> n'est pas en général considérée comme un problème pour
l'OAM, seules l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/authentification" title="Consultez l'article &quot;authentification&quot; de l'encyclopédie libre Wikipedia">authentification</a></b> et
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Int%C3%A9grit%C3%A9%20(cryptographie)" title="Consultez l'article &quot;Intégrité (cryptographie)&quot; de l'encyclopédie libre Wikipedia">intégrité</a></b> le sont. D'autres outils n'ont aucune
sécurité (traceroute peut facilement être trompé, comme <a href="http://thenextweb.com/insider/2013/03/04/the-pirate-bay-may-or-may-not-have-been-invited-to-north-korea-but-its-not-being-hosted-there/">l'avait
montré The Pirate Bay</a>).</p></div>
<div class="para"><p>Les outils d'OAM peuvent aussi être utilisés pour la
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Ping%20sweep" title="Consultez l'article &quot;Ping sweep&quot; de l'encyclopédie libre Wikipedia (en anglais)">reconnaissance</a></b> : par exemple, l'option <code>-g</code> de
<a href="http://fping.org/">fping</a> ou la possibilité d'indiquer un préfixe
IP (et pas juste une adresse) à <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/nmap" title="Consultez l'article &quot;nmap&quot; de l'encyclopédie libre Wikipedia">nmap</a></b>,
permettent de découvrir les machines existant sur le réseau.</p></div> 
<div class="para"><p>L'annexe A termine le RFC en énumérant une (longue) liste de
documents de normalisation sur l'OAM, y compris des documents non-IETF.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7276.txt">Téléchargez le RFC 7276</a></p>
<br />
<a href="7276.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7269.txt">RFC 7269</a>: NAT64 Deployment Options and Experience</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : G. Chen, Z. Cao (China
Mobile), C. Xie (China
Telecom), D. Binet (France
Telecom-Orange)<br/>Pour information<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/v6ops">v6ops</a></b><br/>Première rédaction de cet article le 20 juin 2014<br/></p><hr/>
<div class="para"><p>L'<a href="epuisement-adresses-ipv4.html" title="Consultez ce blog à propos de &quot;epuisement-adresses-ipv4&quot;">épuisement des adresses
IPv4</a> étant allé plus vite que le déploiement
d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b> (qui est freiné par la passivité de
nombreux acteurs), il y a de plus en plus souvent le problème de
connecter des réseaux modernes, entièrement en IPv6, à des machines
anciennes restées en IPv4. La solution de
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> à ce problème est le déploiement de
NAT64, normalisé dans le <a href="6144.html" class="rfc" title="Consultez l'analyse du RFC 6144">RFC 6144</a>. Ce nouveau
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> documente l'expérience concrète de trois
gros opérateurs avec NAT64. Qu'est-ce qui a marché, qu'est-ce qui a
raté ?</p></div>
<div class="para"><p>Ces réseaux entièrement <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b> ont l'avantage
de ne pas avoir de problème de manque d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Adresse%20IP" title="Consultez l'article &quot;Adresse IP&quot; de l'encyclopédie libre Wikipedia">adresses IP</a></b> (même les préfixes du <a href="1918.html" class="rfc" title="Consultez l'analyse du RFC 1918">RFC 1918</a> peuvent être insuffisants pour un grand réseau) et de
permettre d'utiliser un plan d'adressage propre dès le début (pas de
contorsions pour faire durer les adresses) et une architecture unique
(un seul protocole à gérer). Pour les réseaux
mobiles, par exemple, cela signifie un seul contexte
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Packet%20Data%20Protocol" title="Consultez l'article &quot;Packet Data Protocol&quot; de l'encyclopédie libre Wikipedia">PDP</a></b>, ce qui simplifie les choses. Mais, comme vu plus haut, leur
inconvénient est qu'ils ne peuvent pas accéder aux services qui
restent archaïquement en IPv4 seul comme <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Twitter" title="Consultez l'article &quot;Twitter&quot; de l'encyclopédie libre Wikipedia">Twitter</a></b> ou
<code>impots.gouv.fr</code>. Et, même si les
professionnels sérieux ont compris depuis longtemps l'importance de
migrer vers IPv6, les résistances des plus attardés vont sans doute
durer longtemps et on peut penser que des réseaux uniquement IPv4
seront encore en fonctionnement pendant de longues années. Au lieu du
plan de transition envisagé au début (« tout le monde en IPv4 » -&gt;
« double-pile - IPv4 et IPv6 - déployée progressivement » -&gt; « tout
le monde en IPv6 »), il faut maintenant travailler dans le cadre d'un
nouveau plan, « tout le monde en IPv4 » -&gt;
« certains réseaux en v4 seul et certains en v6 seul » -&gt; « tout
le monde en IPv6 ». L'étape intermédiaire a été décrite dans les <a href="6145.html" class="rfc" title="Consultez l'analyse du RFC 6145">RFC 6145</a> et
<a href="6146.html" class="rfc" title="Consultez l'analyse du RFC 6146">RFC 6146</a> et son composant le plus connu est
nommé <b class="emphasis">NAT64</b>. NAT64 effectue une traduction
d'adresses de IPv6 vers IPv4 en sortie du réseau moderne vers le
réseau archaïque et l'inverse lorsque la réponse arrive.</p></div>
<div class="para"><p>NAT64 a donc une partie des inconvénients du NAT IPv4 traditionnel
(NAT44), comme le montre le compte-rendu d'expérience du <a href="6586.html" class="rfc" title="Consultez l'analyse du RFC 6586">RFC 6586</a> mais il parait incontournable, sauf si le
déploiement d'IPv6 s'accélérait subitement dans l'Internet, ce qu'on
ne voit pas venir.</p></div>
<div class="para"><p>30 % des opérateurs, selon un sondage signalé dans le <a href="6036.html" class="rfc" title="Consultez l'analyse du RFC 6036">RFC 6036</a> prévoient de déployer NAT64 ou un système
équivalent. NAT64 est également systématiquement présent lors des
réunions des organismes de normalisation ou de gestion des ressources
réseau, comme l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> ou le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/RIPE" title="Consultez l'article &quot;RIPE&quot; de l'encyclopédie libre Wikipedia">RIPE</a></b>. À chaque réunion, un des réseaux
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Wi-Fi%20(protocole%20de%20communication)" title="Consultez l'article &quot;Wi-Fi (protocole de communication)&quot; de l'encyclopédie libre Wikipedia">WiFi</a></b> est « IPv6 seulement » et bénéficie d'une
passerelle NAT64 vers l'extérieur. De nombreux experts peuvent ainsi
tester en vrai les technologies modernes. Bref, NAT64 est désormais
une technique importante et il est donc nécessaire d'étudier ses
conséquences pratiques. C'est le rôle de ce nouveau RFC, qui ne décrit
pas un nouveau protocole mais offre simplement un retour
d'expérience.</p></div>
<div class="para"><p>À noter que NAT64 peut être déployé en deux endroits :
</p><ul>
<li>Côté FAI, ce qu'on appelle le
NAT64-CGN (pour <i class="foreign" xml:lang="en">Carrier-Grade NAT</i>), sous forme d'un
gros traducteur NAT dans le réseau du FAI,</li>
<li>Ou bien côté fournisseur de services/contenus, ce qu'on appelle
le NAT64-FE (pour <i class="foreign" xml:lang="en">Front End</i>), sous forme d'un
traducteur NAT dans le <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Centre%20de%20traitement%20de%20donn%C3%A9es" title="Consultez l'article &quot;Centre de traitement de données&quot; de l'encyclopédie libre Wikipedia">data
center</a></b></i>, devant les serveurs.</li>
</ul><p>
Le premier cas est celui du FAI tout en IPv6 mais qui veut permettre à
ses clients d'accéder à des services IPv4. Le second est celui du
fournisseur de services ou de contenus dont l'infrastructure est
malheureusement entièrement ou partiellement en IPv4 mais qui veut
fournir un accès IPv6, en ne gérant qu'un traducteur, au lieu de
mettre à jour tous ses systèmes. (Le RFC ne discute pas la question de
savoir si c'est une idée intelligente ou pas...)</p></div>
<div class="para"><p>À noter que le cas
d'un NAT64 chez l'utilisateur (le célèbre M. Michu), dans son
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Customer%20Premises%20Equipment" title="Consultez l'article &quot;Customer Premises Equipment&quot; de l'encyclopédie libre Wikipedia">CPE</a></b>, n'est pas mentionné. Un NAT64 dans le CPE
imposerait un réseau du FAI qui soit en IPv4 jusqu'au client,
justement ce qu'on voudrait éviter. 
Le RFC recommande plutôt de mettre
les traducteurs NAT64 près de la sortie du FAI, de façon à permettre à
celui-ci de conserver un réseau propre, entièrement IPv6 (section
3.1.3). Certes, cela va concentrer une bonne partie du trafic dans ces
traducteurs mais NAT64 est fondé sur l'idée que la proportion de
trafic IPv4 va diminuer avec le temps : les traducteurs n'auront pas
besoin de grossir. Aujourd'hui, 43 des cent plus gros sites Web
(selon <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Alexa%20Internet" title="Consultez l'article &quot;Alexa Internet&quot; de l'encyclopédie libre Wikipedia">Alexa</a></b>) ont déjà un AAAA et
court-circuitent donc complètement le NAT64.</p></div>
<div class="para"><p>Autre problème avec la centralisation, le risque de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Point%20individuel%20de%20d%C3%A9faillance" title="Consultez l'article &quot;Point individuel de défaillance&quot; de l'encyclopédie libre Wikipedia">SPOF</a></b>. Si le CPE de M. Michu plante, cela
n'affecte que M. Michu. Si un gros traducteur NAT64, gérant des
milliers de clients, plante, cela va faire mal. Il faut donc soigner
la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Haute%20disponibilit%C3%A9" title="Consultez l'article &quot;Haute disponibilité&quot; de l'encyclopédie libre Wikipedia">disponibilité</a></b> (voir section 4).</p></div>
<div class="para"><p>Centraliser dans un petit nombre de traducteurs près de la sortie évite également d'avoir plusieurs équipements NAT64, avec les
problèmes de traçabilité que cela poserait, par exemple s'ils ont des
formats de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Historique%20(informatique)" title="Consultez l'article &quot;Historique (informatique)&quot; de l'encyclopédie libre Wikipedia">journaux</a></b> différents.</p></div>
<div class="para"><p>NAT64 nécessite un résolveur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Domain%20Name%20System" title="Consultez l'article &quot;Domain Name System&quot; de l'encyclopédie libre Wikipedia">DNS</a></b> spécial,
utilisant DNS64 (<a href="6147.html" class="rfc" title="Consultez l'analyse du RFC 6147">RFC 6147</a>). En effet, les
clients, n'ayant qu'IPv6, ne demanderont que des enregistrements AAAA
(adresses IPv6) dans le DNS. Le résolveur DNS64 doit donc en
synthétiser si le site original (par exemple
<code>twitter.com</code>) n'en a pas. Dans certains cas,
par exemple une page Web où les liens contiennent des adresses IPv4
littérales (comme <code>&lt;a
href="http://192.0.2.80/"&gt;</code>), la solution 464xlat du <a href="http://www.rfc-editor.org/rfc/rfc6877.txt" class="rfc" title="Consultez le texte intégral du RFC 6877">RFC 6877</a> permet de se passer de DNS64. Mais, dans la
plupart des déploiements NAT64, DNS64 sera indispensable.</p></div>
<div class="para"><p>NAT64 va probablement coexister avec NAT44 (le <a href="nats.html" title="Consultez ce blog à propos de &quot;nats&quot;">NAT majoritaire
aujourd'hui</a>), les réseaux locaux chez l'utilisateur gardant un
certain nombre de machines IPv4. Si le <a href="6724.html" class="rfc" title="Consultez l'analyse du RFC 6724">RFC 6724</a>
donne par défaut la priorité à IPv6, quelque soit le type de
connectivité IPv6, les algorithmes comme celui des
globes oculaires heureux (<a href="6555.html" class="rfc" title="Consultez l'analyse du RFC 6555">RFC 6555</a>) peuvent mener
à préférer IPv6 ou IPv4 et même à en changer d'un moment à l'autre, en
fonction de leurs performances respectives. Ces changements ne seront
pas forcément bons pour l'expérience utilisateur.</p></div>
<div class="para"><p>Pour le NAT64-FE (juste en face des serveurs), le <a href="6883.html" class="rfc" title="Consultez l'analyse du RFC 6883">RFC 6883</a> donnait quelques indications, qui peuvent s'appliquer à
NAT64. Ici, DNS64 n'est pas forcément nécessaire, les adresses IPv6
servant à adresser les serveurs sont en nombre limité et peuvent être
mises dans le DNS normal.</p></div>
<div class="para"><p>La section 4 de notre RFC revient sur l'exigence de haute
disponibilité, essentielle si on veut que le passage de IPv4+IPv6 à
IPv6+NAT64 ne diminue pas la fiabilité du service. Je me souviens
d'une réunion <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/RIPE" title="Consultez l'article &quot;RIPE&quot; de l'encyclopédie libre Wikipedia">RIPE</a></b> où il n'y avait qu'un seul
résolveur DNS64 et, un matin, il avait décidé de faire grève. DNS64
étant indispensable à NAT64, les clients étaient fort marris. Mais la
redondance des résolveurs DNS est un problème connu, et relativement
simple puisqu'ils n'ont pas d'état. Le RFC se focalise surtout sur la
haute disponibilité des traducteurs NAT64 car eux peuvent avoir un
état (comme les traducteurs NAT44 d'aujourd'hui). Il y a trois types
de haute disponibilité : le remplaçant froid, qui est un traducteur
NAT64 inactif en temps normal, et qui ne se synchronise pas avec le
traducteur actif. Il est typiquement activé manuellement quand le
traducteur actif tombe en panne. Comme il n'a pas de copie de l'état
(la table des sessions en cours, aussi nommée BIB pour
<i class="foreign" xml:lang="en">Binding Information Base</i>), toutes les connexions casseront et
devront être réétablies. Le second type est le remplaçant tiède. Il ne
synchronise pas les sessions mais il remplace automatiquement le
traducteur NAT64 principal, par exemple grâce à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Virtual%20Router%20Redundancy%20Protocol" title="Consultez l'article &quot;Virtual Router Redundancy Protocol&quot; de l'encyclopédie libre Wikipedia">VRRP</a></b> (<a href="5798.html" class="rfc" title="Consultez l'analyse du RFC 5798">RFC 5798</a>). Au cours
des tests faits par les auteurs du RFC, il fallait une minute pour que
VRRP bascule et que les trente millions de sessions de la BIB soient
établies à nouveau. Enfin, il y a le remplaçant chaud, qui synchronise
en permanence l'état des sessions. Cette fois, la bascule vers le
remplaçant est indétectable par les clients. Pour s'apercevoir
rapidement de
la panne du traducteur principal, le test a utilisé
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Bidirectional%20Forwarding%20Detection" title="Consultez l'article &quot;Bidirectional Forwarding Detection&quot; de l'encyclopédie libre Wikipedia">BFD</a></b> (<a href="5880.html" class="rfc" title="Consultez l'analyse du RFC 5880">RFC 5880</a>) en
combinaison avec VRRP. Cette fois, la bascule des trente millions de
sessions n'a pris que trente-cinq millisecondes, soit une
quasi-continuité de service.  Évidemment, cela nécessite du logiciel
plus complexe dans les traducteurs, surtout vu l'ampleur de la tâche : avec 200 000
utilisateurs, il faut créer et détruire environ 800 000 sessions par
seconde ! Un lien à 10 Gb/s entre les traducteurs n'est pas de trop,
pour transporter les données nécessaires pendant les pics de
trafic.</p></div>
<div class="para"><p>Alors, remplaçant froid, tiède ou chaud ? Notre RFC ne tranche pas
définitivement, disant que cela dépend des applications. (L'annexe A
du RFC contient des tests spécifiques à certaines applications.)
Environ 90 % du trafic pendant les tests était dû à
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b>. Ce protocole n'a pas besoin de continuité
de service, chaque requête HTTP étant indépendante. Le traducteur
chaud n'est donc pas indispensable si HTTP continue à dominer (au
passage, c'est pour une raison analogue que la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Mobilit%C3%A9%20IP" title="Consultez l'article &quot;Mobilité IP&quot; de l'encyclopédie libre Wikipedia">mobilité
IP</a></b> n'a jamais été massivement utilisée). En
revanche, le <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/streaming" title="Consultez l'article &quot;streaming&quot; de l'encyclopédie libre Wikipedia">streaming</a></b></i>
souffrirait davantage en cas de coupure des sessions. (Curieusement,
le RFC cite aussi le pair-à-pair comme intolérant aux coupures de
session, alors que les clients <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/BitTorrent%20(protocole)" title="Consultez l'article &quot;BitTorrent (protocole)&quot; de l'encyclopédie libre Wikipedia">BitTorrent</a></b>, par
exemple, s'en tirent très bien et réétablissent automatiquement des
sessions.)</p></div>
<div class="para"><p>Le trafic d'un traducteur NAT64-CGN peut être intense et, même en
l'absence de pannes, il est raisonnable de prévoir plusieurs
traducteurs, afin de répartir la charge. Attention, si on fait du
NAT64 avec état (le plus courant), il faut s'assurer que les paquets
d'une session donnée arrivent toujours au même traducteur. Une façon de distribuer les
requêtes entre les traducteurs, pour le NAT64-CGN, est de demander au serveur DNS64 de
synthétiser des préfixes différents selon le client, et d'envoyer les
différents préfixes à différents traducteurs, en utilisant le
classique routage IP. Pour le NAT64-FE, les techniques classiques des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/R%C3%A9partition%20de%20charge" title="Consultez l'article &quot;Répartition de charge&quot; de l'encyclopédie libre Wikipedia">répartiteurs de charge</a></b>
(<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Fonction%20de%20hachage" title="Consultez l'article &quot;Fonction de hachage&quot; de l'encyclopédie libre Wikipedia">condensation</a></b> de certains paramètres puis
répartition en fonction du condensat) conviennent.</p></div>
<div class="para"><p>La section 5 du RFC se penche ensuite sur le problème de l'adresse
IP source. À partir du moment où on fait du NAT (quel que soit le NAT
utilisé), l'adresse IP source vue par le destinataire n'est pas celle
de l'émetteur mais celle du traducteur NAT. Cela entraine tout un tas
de problèmes. D'abord, la traçabilité. Un serveur voit un comportement
illégal ou asocial (par exemple, pour un serveur HTTP, des
requêtes identiques coûteuses répétées, pour réaliser une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Attaque%20par%20d%C3%A9ni%20de%20service" title="Consultez l'article &quot;Attaque par déni de service&quot; de l'encyclopédie libre Wikipedia">attaque par
déni de service</a></b>). Son administrateur note l'adresse IP du
coupable. Qu'en fait-il ? Pour pouvoir remonter de cette adresse IP au
client individuel, il faut garder les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Historique%20(informatique)" title="Consultez l'article &quot;Historique (informatique)&quot; de l'encyclopédie libre Wikipedia">journaux</a></b>
du traducteur NAT (et aussi, le RFC l'oublie, que le serveur note
l'heure exacte et le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Port%20(logiciel)" title="Consultez l'article &quot;Port (logiciel)&quot; de l'encyclopédie libre Wikipedia">port</a></b>, comme rappelé par le
<a href="6302.html" class="rfc" title="Consultez l'analyse du RFC 6302">RFC 6302</a>). Les auteurs du RFC ont tenté l'expérience avec
200 000 clients humains pendant 60 jours. Les informations sur les
sessions étaient transmises par <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/syslog" title="Consultez l'article &quot;syslog&quot; de l'encyclopédie libre Wikipedia">syslog</a></b> (<a href="5424.html" class="rfc" title="Consultez l'analyse du RFC 5424">RFC 5424</a>) à une station d'archivage. Avec toutes les
informations conservées (heure, protocole de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Couche%204" title="Consultez l'article &quot;Couche 4&quot; de l'encyclopédie libre Wikipedia">transport</a></b>, adresse IPv6 source originelle - et son port, adresse
IPv4 source traduite - et son port), soit 125 octets, les 72 000
sessions par seconde ont produit pas moins de 29 téra-octets de
données. La seule activité de journalisation, pour faire plaisir au
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Conseil%20sup%C3%A9rieur%20de%20l'audiovisuel%20(France)" title="Consultez l'article &quot;Conseil supérieur de l'audiovisuel (France)&quot; de l'encyclopédie libre Wikipedia">CSA</a></b>, nécessite donc une infrastructure dédiée
(machines, disques et liens) et coûteuse.</p></div>
<div class="para"><p>Le système pourrait toutefois être amélioré. Au lieu de noter le
port pour chaque session, on pourrait allouer une plage de ports à
chaque client et réduire ainsi le volume à journaliser (seule
l'allocation de la plage serait notée ; ceci dit, cela compliquera
sérieusement le logiciel de recherche, qui aura moins de données à
fouiller mais davantage de calculs à faire). On peut même statiquement
allouer des plages de port à chaque client, supprimant ainsi une
grande partie de la journalisation. Mais attention, ces méthodes
d'optimisation ont deux gros défauts : elles diminuent l'efficacité du
multiplexage (certains client vont tomber à court de ports alors que
d'autres en auront des inutilisés) et elle est contraire aux
recommandations de sécurité du <a href="6056.html" class="rfc" title="Consultez l'analyse du RFC 6056">RFC 6056</a>, qui
prescrit des ports sources difficiles à deviner, pour compliquer la
tâche d'un attaquant.</p></div>
<div class="para"><p>Autre problème lié à la traduction d'adresses, la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/g%C3%A9olocalisation" title="Consultez l'article &quot;géolocalisation&quot; de l'encyclopédie libre Wikipedia">géolocalisation</a></b>. Un serveur qui géolocalise
en se fondant sur l'adresse IP source trouvera la position du
traducteur, pas celle de l'utilisateur. Parfois, cela peut être
gênant. Le <a href="6967.html" class="rfc" title="Consultez l'analyse du RFC 6967">RFC 6967</a> cite quelques solutions
possibles, mais aucune n'est parfaite : on peut par exemple se servir
d'informations applicatives comme l'en-tête
<code>Forwarded:</code> de HTTP (<a href="7239.html" class="rfc" title="Consultez l'analyse du RFC 7239">RFC 7239</a>), ce qui ne marche évidemment qu'avec ce protocole.</p></div>
<div class="para"><p>La section 6 revient vers les problèmes de M. Michu, heureux
utilisateur, sans le savoir, d'un traducteur NAT64. Quelle va être la
qualité de son vécu d'utilisateur ? Ou, dit plus trivialement, est-ce
que ça va marcher ou planter ? Certaines applications fonctionnent
facilement et simplement à travers <a href="nats.html" title="Consultez ce blog à propos de &quot;nats&quot;">n'importe quel
NAT</a>, comme HTTP ou <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Secure%20Shell" title="Consultez l'article &quot;Secure Shell&quot; de l'encyclopédie libre Wikipedia">SSH</a></b>. D'autres
nécessitent un relais, une <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Application-level%20gateway" title="Consultez l'article &quot;Application-level gateway&quot; de l'encyclopédie libre Wikipedia (en anglais)">ALG</a></b>. Les traducteurs
NAT64 fournissent en général une ALG pour <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/File%20Transfer%20Protocol" title="Consultez l'article &quot;File Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">FTP</a></b>
(<a href="http://www.rfc-editor.org/rfc/rfc6384.txt" class="rfc" title="Consultez le texte intégral du RFC 6384">RFC 6384</a>). Même pour les protocoles qui
marchent « tout seuls » à travers NAT64, une ALG peut être utile pour
la traçabilité, par exemple insérer des en-têtes
<code>Via:</code> dans une requête HTTP ou
<code>Received:</code> dans un message transmis en
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Simple%20Mail%20Transfer%20Protocol" title="Consultez l'article &quot;Simple Mail Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">SMTP</a></b>.</p></div>
<div class="para"><p>En testant des applications réelles, comme l'avait fait le <a href="6586.html" class="rfc" title="Consultez l'analyse du RFC 6586">RFC 6586</a>, les auteurs de ce RFC ont trouvé que plusieurs
continuent à planter, ce qui plaiderait pour l'ajout à NAT64 des
fonctions 464xlat du <a href="http://www.rfc-editor.org/rfc/rfc6877.txt" class="rfc" title="Consultez le texte intégral du RFC 6877">RFC 6877</a>. Ainsi,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Session%20Initiation%20Protocol" title="Consultez l'article &quot;Session Initiation Protocol&quot; de l'encyclopédie libre Wikipedia">SIP</a></b> n'a pas réussi à appeler depuis la machine
IPv6 pure vers un <i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/softphone" title="Consultez l'article &quot;softphone&quot; de l'encyclopédie libre Wikipedia">softphone</a></b></i>
en IPv4 pur (les adresses IP sont transmises dans la signalisation, et
ne sont pas traduites par NAT64). Il faut donc, comme recommandé par
le <a href="http://www.rfc-editor.org/rfc/rfc6157.txt" class="rfc" title="Consultez le texte intégral du RFC 6157">RFC 6157</a>, que les clients SIP
utilisent <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Interactive%20Connectivity%20Establishment" title="Consultez l'article &quot;Interactive Connectivity Establishment&quot; de l'encyclopédie libre Wikipedia (en anglais)">ICE</a></b> (<a href="5245.html" class="rfc" title="Consultez l'analyse du RFC 5245">RFC 5245</a>), qui a l'avantage de traiter également le problème des
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Pare-feu%20(informatique)" title="Consultez l'article &quot;Pare-feu (informatique)&quot; de l'encyclopédie libre Wikipedia">pare-feux</a></b>.</p></div>
<div class="para"><p>Pour <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Protocol%20Security" title="Consultez l'article &quot;Internet Protocol Security&quot; de l'encyclopédie libre Wikipedia">IPsec</a></b>, le bilan est également mitigé :
comme prévu, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Authentication%20Header" title="Consultez l'article &quot;Authentication Header&quot; de l'encyclopédie libre Wikipedia">AH</a></b> n'a pas fonctionné (puisque son
but est d'empêcher toute modification des en-têtes, donc des adresses
IP source et destination), mais <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Encapsulating%20Security%20Payload" title="Consultez l'article &quot;Encapsulating Security Payload&quot; de l'encyclopédie libre Wikipedia">ESP</a></b> non plus,
les paquets du protocole de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/couche%204" title="Consultez l'article &quot;couche 4&quot; de l'encyclopédie libre Wikipedia">couche 4</a></b> 50, le protocole d'ESP, n'étant
pas traduits. Utiliser ESP sur <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/User%20Datagram%20Protocol" title="Consultez l'article &quot;User Datagram Protocol&quot; de l'encyclopédie libre Wikipedia">UDP</a></b>, comme
décrit dans le <a href="http://www.rfc-editor.org/rfc/rfc3947.txt" class="rfc" title="Consultez le texte intégral du RFC 3947">RFC 3947</a>, aurait probablement résolu ce
problème.</p></div>
<div class="para"><p>Le tableau de la section 6.1 résume les applications testées et les
résultats :
</p><ul>
<li>Web : pas de problème, sauf les rares cas où un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Uniform%20Resource%20Locator" title="Consultez l'article &quot;Uniform Resource Locator&quot; de l'encyclopédie libre Wikipedia">URL</a></b> inclut une adresse IPv4 littérale,</li>
<li>Messagerie instantanée : la plupart des services testés ont
échoué (mon expérience personnelle est que <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Extensible%20Messaging%20and%20Presence%20Protocol" title="Consultez l'article &quot;Extensible Messaging and Presence Protocol&quot; de l'encyclopédie libre Wikipedia">XMPP</a></b>
et <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Relay%20Chat" title="Consultez l'article &quot;Internet Relay Chat&quot; de l'encyclopédie libre Wikipedia">IRC</a></b> fonctionnent très bien à travers NAT64,
donc je suppose qu'il s'agissait de protocoles fermés et de logiciels
privateurs),</li>
<li>Jeux : les jeux non-Web ont presque tous échoué,</li>
<li>SIP : échec,</li>
<li>IPsec : échec (vor ci-dessus),</li>
<li>Partage de fichiers en pair-à-pair : échec, par exemple avec
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/eMule" title="Consultez l'article &quot;eMule&quot; de l'encyclopédie libre Wikipedia">eMule</a></b>,</li>
<li>Courrier électronique : pas de problème,</li>
<li>FTP : pas de problème.</li>
</ul><p>
L'annexe A décrit en outre les délais acceptables pour ces
applications, lorsque le traducteur NAT64 tombe en panne et est
remplacé. Les jeux interactifs, par exemple, ne supportent pas les longues interruptions.
</p></div>
<div class="para"><p>Comme un traducteur NAT64 gène certains services, il serait utile
de fournir aux clients un moyen de contrôler, par exemple, l'ouverture
de <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/ports" title="Consultez l'article &quot;ports&quot; de l'encyclopédie libre Wikipedia">ports</a></b> entrants, les ports sortants affectés,
etc. Il existe un protocole standard pour cela,
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Port%20Control%20Protocol" title="Consultez l'article &quot;Port Control Protocol&quot; de l'encyclopédie libre Wikipedia (en anglais)">PCP</a></b> (<a href="6887.html" class="rfc" title="Consultez l'analyse du RFC 6887">RFC 6887</a>), qui
serait un ajout très utile aux traducteurs NAT64 mais, pour l'instant,
aucun n'en dispose encore.</p></div>
<div class="para"><p>La section 7 du RFC se penche ensuite sur les problèmes de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Maximum%20Transmission%20Unit" title="Consultez l'article &quot;Maximum Transmission Unit&quot; de l'encyclopédie libre Wikipedia">MTU</a></b>. Certes, il n'y a pas de
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Tunnel%20(r%C3%A9seau%20informatique)" title="Consultez l'article &quot;Tunnel (réseau informatique)&quot; de l'encyclopédie libre Wikipedia">tunnel</a></b> avec NAT64, mais il peut y avoir des
liens IPv4 dont la MTU est inférieure à 1 280 octets, le minimum des
liens IPv6. Il n'y a pas de moyen simple, en NAT64-CGN, de gérer ce problème.</p></div>
<div class="para"><p>Bon, et la sécurité ? La section 9 étudie la question. NAT64 fait
du suivi des sessions TCP et est donc normalement à l'abri de pas mal
de types d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Attaque%20par%20d%C3%A9ni%20de%20service" title="Consultez l'article &quot;Attaque par déni de service&quot; de l'encyclopédie libre Wikipedia">attaques par déni de service</a></b>. On
peut renforcer sa sécurité en déployant <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Reverse%20path%20forwarding" title="Consultez l'article &quot;Reverse path forwarding&quot; de l'encyclopédie libre Wikipedia">RPF</a></b>
(<a href="3704.html" class="rfc" title="Consultez l'analyse du RFC 3704">RFC 3704</a>), pour empêcher les usurpations
d'adresses IPv6.</p></div>
<div class="para"><p>Pour NAT64-FE, une attaque possible serait de remplir la table des
sessions en commençant plein de sessions vers les serveurs situés
derrière le traducteur NAT64-FE. Celui-ci doit donc avoir un mécanisme
de limitation de trafic.</p></div>
<div class="para"><p>Ah, et puis il faut rappeler qu'un résolveur DNS64, étant un
résolveur menteur (pour la bonne cause, certes, mais menteur tout de
même), s'entend mal avec DNSSEC. Le <a href="6147.html" class="rfc" title="Consultez l'analyse du RFC 6147">RFC 6147</a>
contient de nombreuses notes à ce sujet.</p></div>
<div class="para"><p>Ce RFC est issu d'un processus qui a commencé par <a href="http://www.ietf.org/proceedings/82/slides/v6ops-5.pdf">un exposé
à l'IETF</a>. Il y a eu quelques objections de principe (un certain
nombre de participants à l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b> estiment que
toute traduction est une erreur, NAT64 comme les autres).</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7269.txt">Téléchargez le RFC 7269</a></p>
<br />
<a href="7269.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="fr">Version 7 d'Unicode</h2><p>Première rédaction de cet article le 19 juin 2014<br/></p><hr/><div xml:lang="fr">
<div class="para"><p>Le 16 juin a vu la sortie d'une <a href="http://unicode-inc.blogspot.fr/2014/06/announcing-unicode-standard-version-70.html">nouvelle version</a> du jeu de
caractères <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unicode" title="Consultez l'article &quot;Unicode&quot; de l'encyclopédie libre Wikipedia">Unicode</a></b>, la 7.0. On peut trouver une
description des principaux changements en <a href="http://www.unicode.org/versions/Unicode7.0.0/"><code>http://www.unicode.org/versions/Unicode7.0.0/</code></a> mais voici ceux
qui m'ont intéressé particulièrement. (Il n'y a pas de changement radical.)</p></div>
<div class="para"><p>Pour explorer plus facilement la grande base
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Unicode" title="Consultez l'article &quot;Unicode&quot; de l'encyclopédie libre Wikipedia">Unicode</a></b>,  j'utilise un <a href="unicode-to-sql.html" title="Consultez ce blog à propos de &quot;unicode-to-sql&quot;">programme qui la convertit en SQL</a> et
permet ensuite de faire des analyses variées.  Faisons quelques requêtes SQL :
</p><pre>
ucd=&gt; SELECT count(*) AS Total FROM Characters;
 total  
--------
 113021
</pre><p>
Plus de 113 000 caractères. Lesquels ont été apportés par la version 7 ?
</p><pre>

ucd=&gt; SELECT version,count(version) FROM Characters GROUP BY version ORDER BY version;
 version | count 
---------+-------
...
 6.0     |  2088
 6.1     |   732
 6.2     |     1
 6.3     |     5
 7.0     |  2834
</pre><p>
2 834 nouveaux. Lesquels ?
</p><pre>
ucd=&gt; SELECT To_U(codepoint) AS Codepoint, name FROM Characters WHERE version='7.0';
 codepoint |                                    name                                    
-----------+----------------------------------------------------------------------------
...
 U+2B5E    | BENT ARROW POINTING DOWNWARDS THEN NORTH EAST
...
 U+10350   | OLD PERMIC LETTER AN
...
 U+10500   | ELBASAN LETTER A
...
 U+10600   | LINEAR A SIGN AB001
...
 U+10880   | NABATAEAN LETTER FINAL ALEPH
...
 U+1236F   | CUNEIFORM SIGN KAP ELAMITE
...
 U+1F57D   | RIGHT HAND TELEPHONE RECEIVER
...
 U+1F6F2   | DIESEL LOCOMOTIVE
...
</pre><p>
Comme on le voit, c'est varié. On trouve vingt-trois nouveaux alphabets,
ayant souvent cessés d'être utilisés, et intégrés à Unicode surtout pour les
recherches historiques, comme par exemple le <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Old%20Permic%20alphabet" title="Consultez l'article &quot;Old Permic alphabet&quot; de l'encyclopédie libre Wikipedia (en anglais)">vieux permien</a></b>, l'<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Elbasan%20alphabet" title="Consultez l'article &quot;Elbasan alphabet&quot; de l'encyclopédie libre Wikipedia (en anglais)">elbasan</a></b>, le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Alphabet%20nabat%C3%A9en" title="Consultez l'article &quot;Alphabet nabatéen&quot; de l'encyclopédie libre Wikipedia">nabatéen</a></b> 
ou le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Lin%C3%A9aire%20A" title="Consultez l'article &quot;Linéaire A&quot; de l'encyclopédie libre Wikipedia">Linéaire A</a></b>,
toujours pas déchiffré (ce qui explique les noms des caractères, qui
sont des chiffres sans sémantique). Il y a aussi l'ajout de plus de
mille nouveaux caractères <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cun%C3%A9iforme" title="Consultez l'article &quot;Cunéiforme&quot; de l'encyclopédie libre Wikipedia">cunéiformes</a></b>.</p></div>
<div class="para"><p>La partie la plus spectaculaire, mais pas forcément la plus utile,
est l'ajout de nombreux symboles, comme les innombrables flèches
(comme la U+2B5E ci-dessus), ou la locomotive
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Moteur%20Diesel" title="Consultez l'article &quot;Moteur Diesel&quot; de l'encyclopédie libre Wikipedia">Diesel</a></b> U+1F6F2... À ceux qui disent « digital »
pour numérique (comme les innombrables « agences digitales » qui font
de la « stratégie digitale »), on pourra désormais répondre avec
l'image du caractère U+1F595, « <i class="foreign" xml:lang="en">REVERSED HAND WITH MIDDLE FINGER EXTENDED</i> »...
Pour mieux apprécier ces nouveaux symboles
(avec des représentations graphiques), vous pouvez regarder la liste
de ceux de <a href="http://www.unicode.org/charts/PDF/U1F300.pdf ">la série U+1F300</a> et suivants... Si vous avez les bonnes
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Police%20d'%C3%A9criture" title="Consultez l'article &quot;Police d'écriture&quot; de l'encyclopédie libre Wikipedia">polices de caractères</a></b>, voici les caractères
pris en exemple plus haut : ⭞ 𐍐 𐔀  𐘀
𐢀 𒍯 🕽 🛲 🖕 ... Une autre solution est de
se servir d'<a href="http://people.w3.org/rishida/uniview/">UniView</a> qui a été
mis à jour avec les données de la version 7. Quant aux noms officiels en français de
tous ces caractères, ils sont <a href="http://hapax.qc.ca/ListeDesNoms-7.0%282014-06-11%29.txt">en ligne</a>.</p></div>

</div>
<br />
<a href="unicode-7-0.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7211.txt">RFC 7211</a>: Operations Model for Router Keying</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : S. Hartman (Painless Security), D. Zhang (Huawei)<br/>Pour information<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/karp">karp</a></b><br/>Première rédaction de cet article le 19 juin 2014<br/></p><hr/>
<div class="para"><p>Il y a un gros travail en cours à l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Engineering%20Task%20Force" title="Consultez l'article &quot;Internet Engineering Task Force&quot; de l'encyclopédie libre Wikipedia">IETF</a></b>
pour améliorer la sécurité du <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/routage" title="Consultez l'article &quot;routage&quot; de l'encyclopédie libre Wikipedia">routage</a></b> sur
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet" title="Consultez l'article &quot;Internet&quot; de l'encyclopédie libre Wikipedia">Internet</a></b>. L'un des aspects de ce travail
concerne la gestion des <b class="emphasis">clés</b> par les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Routeur" title="Consultez l'article &quot;Routeur&quot; de l'encyclopédie libre Wikipedia">routeurs</a></b>. Bien des solutions de sécurité
nécessitent que les routeurs disposent de clés secrètes. Le groupe de
travail <a href="http://tools.ietf.org/wg/karp">KARP</a>
travaille sur les problèmes de gestion de ces clés (cf. <a href="6518.html" class="rfc" title="Consultez l'analyse du RFC 6518">RFC 6518</a>). Ce nouveau RFC du
groupe décrit les problèmes opérationnels et les pratiques actuelles
de gestion des clés dans les routeurs.</p></div>
<div class="para"><p>KARP a déjà produit <a href="/search?pattern=karp%26(routage|routeur)">plusieurs
RFC</a>. Celui-ci se veut particulièrement terre-à-terre. Il existe
des tas de techniques pour sécuriser la communication entre
routeurs. Mais comment sont-elles effectivement déployées ? Pour le
savoir, il faut disposer d'un modèle décrivant les opérations de
gestion de clés. C'est
d'autant plus crucial que la sécurisation du routage présente quelques
défis spécifiques. Par exemple, comme il faut que le routage
fonctionne pour pouvoir contacter d'autres machines du réseau, les
solutions fondées sur un serveur d'authentification central ne
conviennent pas.</p></div>
<div class="para"><p>D'abord, le modèle de configuration d'un routeur, en section 3. La
configuration consiste à indiquer au routeur les clés qu'il utilisera
pour s'authentifier, ainsi que divers paramètres. Cela peut se faire
manuellement ou automatiquement. La configuration automatique étant
encore un sujet d'étude, notre RFC se concentre sur la configuration
manuelle, via une structure abstraite, la <b class="emphasis">table des clés</b>. Ce n'est déjà pas évident car
certains protocoles nécessitent une clé commune à tous les routeurs,
et d'autres pas. Il faut donc pouvoir configurer les clés par
interface réseau et par pair. Prenons l'exemple
d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Open%20shortest%20path%20first" title="Consultez l'article &quot;Open shortest path first&quot; de l'encyclopédie libre Wikipedia">OSPF</a></b> (<a href="2328.html" class="rfc" title="Consultez l'analyse du RFC 2328">RFC 2328</a>) : sur
tout lien réseau, tous les routeurs doivent utiliser la même clé. En
revanche, d'un lien à l'autre, un même routeur peut se trouver à
utiliser plusieurs clés différentes. Mais ce n'est pas obligatoire et,
dans certaines organisations, on aura peut-être une clé pour chaque
zone (<i class="foreign" xml:lang="en">area</i>) OSPF, avec seuls les ABR (<i class="foreign" xml:lang="en">Area
Border Router</i>) utilisant plusieurs clés. Bien sûr, avec une
table de clés OSPF où les clés sont rangées par lien, on peut réaliser
la politique « une clé par zone » en mettant la même clé pour tous les
liens de la zone. Mais, si ce n'est pas vérifié par le système de
gestion de la table de clés, il y a un risque de désynchronisation,
par exemple parce qu'on change la clé d'un lien en oubliant les autres
liens de la zone. Il serait donc souhaitable d'avoir un mécanisme
d'héritage (« la clé du lien dépend de la zone ») permettant d'éviter
cette désynchronisation accidentelle.</p></div>
<div class="para"><p>L'intégrité de la table des clés par rapport aux règles techniques
des protocoles de routage est évidemment essentielle. Le routeur doit
donc s'assurer que les algorithmes de cryptographie indiqués sont
compatibles avec le protocole de routage, que la <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Key%20derivation%20function" title="Consultez l'article &quot;Key derivation function&quot; de l'encyclopédie libre Wikipedia (en anglais)">fonction
de dérivation</a></b> l'est également, etc. La table peut être
modifiée via une quantité de méthodes (<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Gestion%20de%20configuration" title="Consultez l'article &quot;Gestion de configuration&quot; de l'encyclopédie libre Wikipedia">système de gestion
de configuration</a></b>, interface Web,
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Interface%20en%20ligne%20de%20commande" title="Consultez l'article &quot;Interface en ligne de commande&quot; de l'encyclopédie libre Wikipedia">CLI</a></b>, etc) du moment que son intégrité est
vérifiée.</p></div>
<div class="para"><p>Afin d'éviter les « clés éternelles », jamais changées (même
lorsqu'un employé qui les connait quitte l'organisation), il faut
aussi que le table prévoit un système d'expiration, pour pouvoir
indiquer « cette clé est valable jusqu'au 15 avril 2014 » et qu'elle
soit automatiquement marquée comme expirée après cette date.</p></div>
<div class="para"><p>Il existe des tas de façons d'utiliser des clés en
cryptographie. La plus simple (et sans doute la plus courante
aujourd'hui) est que les clés configurées dans le
routeur soient partagées, et utilisées telles quelles dans le protocole de
routage. Mais on peut aussi passer par une <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Key%20derivation%20function" title="Consultez l'article &quot;Key derivation function&quot; de l'encyclopédie libre Wikipedia (en anglais)">fonction de
dérivation</a></b>, qui va combiner la clé partagée avec des paramètres
d'une session particulière, rendant ainsi la tâche plus difficile pour
l'attaquant (même s'il a la clé, il ne pourra pas forcément s'insérer
dans une session en cours). C'est par exemple ce que fait le protocole
AO du <a href="5925.html" class="rfc" title="Consultez l'analyse du RFC 5925">RFC 5925</a> (dans sa section 5.2). Ou bien on
peut se servir des clés préconfigurées pour s'authentifier le temps de
générer des clés de session, par exemple avec
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/%C3%89change%20de%20cl%C3%A9s%20Diffie-Hellman" title="Consultez l'article &quot;Échange de clés Diffie-Hellman&quot; de l'encyclopédie libre Wikipedia">Diffie-Hellman</a></b>. Les clés sont parfois
identifiées par un nombre court, parfois pas identifiées du tout et un
routeur peut avoir à en essayer plusieurs avant de tomber sur la bonne.</p></div>
<div class="para"><p>Enfin, il y a le cas où les routeurs utilisent de la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/cryptographie%20asym%C3%A9trique" title="Consultez l'article &quot;cryptographie asymétrique&quot; de l'encyclopédie libre Wikipedia">cryptographie asymétrique</a></b>. La clé privée de
chaque routeur ne quittera alors jamais le routeur, ce qui augmente la
sécurité. (Ceci dit, cela empêchera de remplacer rapidement un
routeur, ce qui est une opération souhaitable, et qui justifie donc
une gestion centrale des clés.) L'authentification des autres routeurs pourra se faire via
une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Infrastructure%20%C3%A0%20cl%C3%A9s%20publiques" title="Consultez l'article &quot;Infrastructure à clés publiques&quot; de l'encyclopédie libre Wikipedia">PKI</a></b> (ce qui peut être compliqué à mettre en
place), ou bien en ajoutant la clé publique de
chaque routeur à tous ses pairs (ce qui n'est pas pratique si on
ajoute souvent de nouveaux routeurs). Pour identifier les clés, notre
RFC recommande
de se servir du <a href="http://www.rfc-editor.org/rfc/rfc4572.txt" class="rfc" title="Consultez le texte intégral du RFC 4572">RFC 4572</a> (section 5). Ensuite, les
autorisations de tel ou tel routeur pair peuvent se faire en indiquant
les clés (ce qui a l'inconvénient qu'il faut les refaire si un routeur
change de clé) ou en indiquant une identité du routeur (ce qui
nécessite, pour cette indirection supplémentaire, un moyen sécurisé de
passer de l'identité du routeur à sa ou ses clés). Avec une PKI, le
problème ne se posera évidemment pas.</p></div>
<div class="para"><p>On l'a vu, un problème spécifique à la sécurisation du routage est
qu'il faut que le mécanisme marche sans dépendre du réseau puisque,
avant que les routeurs soient authentifiés et échangent les routes, on
n'aura peut-être pas de réseau. Cela limite sérieusement le rôle que
peuvent jouer des serveurs centraux, genre
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Remote%20Authentication%20Dial-In%20User%20Service" title="Consultez l'article &quot;Remote Authentication Dial-In User Service&quot; de l'encyclopédie libre Wikipedia">RADIUS</a></b> (<a href="2865.html" class="rfc" title="Consultez l'analyse du RFC 2865">RFC 2865</a>). Pas
question par exemple que le seul moyen d'obtenir les clés des pairs
soit de demander à un serveur central. Cela ne veut pas dire que ces
serveurs centraux soient inutiles. Ils peuvent aider à des opérations
comme la diffusion de nouvelles clés en cas de préparation à un
remplacement de clés ou comme la distribution de la clé d'un nouveau
pair. Simplement, le réseau doit pouvoir démarrer et fonctionner sans
eux.</p></div>
<div class="para"><p>La section 6 de notre RFC est consacrée au rôle de l'administrateur
humain dans la gestion des clés. Deux exemples typiques où il est
indispensable, l'arrivée d'un nouveau pair (il faut décider si on le
laisse entrer ou pas) et la réparation en cas de problème. Si le
réseau fonctionne déjà, l'arrivée d'un nouveau pair peut être
simplifiée car il peut suffire d'inscrire ce routeur dans une base de
données et toutes les informations nécessaires peuvent être propagées
aux autres routeurs en utilisant le réseau. Le cas d'un réseau tout
nouveau démarrant à froid est évidemment plus compliqué.</p></div>
<div class="para"><p>Naturellement, le nouveau routeur doit être proprement configuré
sur le plan de la sécurité ; il ne servirait à rien de protéger les
clés utilisées par les protocoles de routage si on pouvait se
connecter en <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Secure%20Shell" title="Consultez l'article &quot;Secure Shell&quot; de l'encyclopédie libre Wikipedia">SSH</a></b> sur le routeur avec
<code>login: admin password: admin</code> !</p></div>
<div class="para"><p>Et les pannes ? C'est que la sécurité apporte ses propres causes de
panne. Vouloir sécuriser un réseau peut l'empêcher de
fonctionner. Ainsi, l'expiration d'un certificat entraîne son refus
par les autres routeurs et le retrait du routeur au certificat trop
vieux... Même si le RFC n'en parle pas, une des raisons du faible
déploiement des solutions de sécurisation du routage est la crainte
d'avoir davantage de pannes. Le déploiement de toute solution de
sécurité nécessitera des pratiques plus rigoureuses, par exemple une
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/supervision" title="Consultez l'article &quot;supervision&quot; de l'encyclopédie libre Wikipedia">supervision</a></b> des dates d'expiration des
certificats.</p></div>
<div class="para"><p>Et une fois qu'on a décidé de déployer une jolie sécurité toute
neuve avec une meilleure gestion des lettres de créance des routeurs,
comment on fait ? La section 7 fait remarquer que le passage du
système actuel au nouveau ne va pas forcément être sans douleur. Si on
conçoit un réseau tout neuf, on peut le faire proprement dès le
début. Mais si on a un réseau existant et qu'on veut y introduire de
nouvelles pratiques ? Et sans tout casser ? Aujourd'hui, si des clés
comme celles d'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Open%20shortest%20path%20first" title="Consultez l'article &quot;Open shortest path first&quot; de l'encyclopédie libre Wikipedia">OSPF</a></b> ou bien celles utilisées
entre routeurs <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Border%20Gateway%20Protocol" title="Consultez l'article &quot;Border Gateway Protocol&quot; de l'encyclopédie libre Wikipedia">BGP</a></b> sont très rarement changées,
c'est souvent par peur que ce changement coupe le routage. Pour deux
routeurs BGP appartenant à des organisations différentes, le
changement du mot de passe MD5 (<a href="2385.html" class="rfc" title="Consultez l'analyse du RFC 2385">RFC 2385</a>) doit
être soigneusement coordonné et il faut que le pair respecte
rigoureusement la procédure qui a été définie, notamment le moment du
changement. Comme on s'en doute, c'est rarement fait.</p></div>
<div class="para"><p>Prenons l'exemple du nouveau mécanisme AO (<a href="5925.html" class="rfc" title="Consultez l'analyse du RFC 5925">RFC 5925</a>) qui remplace l'authentification MD5. Il n'existe pas
de mécanisme automatique pour savoir si le pair BGP utilise MD5 ou
AO. Il faut donc un changement coordonné (« le 11 mars à 13h37 UTC, on
passe à AO »). Si le logiciel utilisé permet de grouper les
configurations en traitant tout un ensemble de pairs de la même façon,
il faut en prime faire cela pour tous les pairs à la fois. Vu cette
difficulté, il n'est pas étonnant que peu de sessions BGP soient
aujourd'hui protégées par AO.</p></div>
<div class="para"><p>Enfin, le rappelle la section 8, beaucoup de mécanismes de sécurité
dépendent d'une horloge à l'heure. Il est donc crucial de s'assurer
que l'heure sur les routeurs est correctement synchronisée.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7211.txt">Téléchargez le RFC 7211</a></p>
<br />
<a href="7211.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7240.txt">RFC 7240</a>: Prefer Header for HTTP</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : J. Snell<br/>Chemin des normes<br/>Première rédaction de cet article le 18 juin 2014<br/></p><hr/>
<div class="para"><p>Dans certains cas, la norme du protocole
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b> laisse un serveur choisir entre plusieurs
comportements, tous légaux. Un client peut avoir une préférence
personnelle et ce nouvel en-tête <code>Prefer:</code>, dans la
requête HTTP, permet à ce client de la spécifier. Ce n'est pas un
ordre, le serveur peut ignorer cette préférence.</p></div>
<div class="para"><p>Un exemple de cette latitude laissée aux serveurs ? Lorsqu'un
client modifie une ressource Web avec la commande
<code>PUT</code> (cf. <a href="5023.html" class="rfc" title="Consultez l'analyse du RFC 5023">RFC 5023</a>), le
serveur peut retourner la nouvelle ressource, complète, ou bien
seulement la modification faite. Le client pourrait dire « je ne vais
même pas lire ce texte, envoie le minimum » ou bien « je vais tout
vérifier soigneusement, envoie la ressource après modification, pour
m'éviter un <code>GET</code> ultérieur ». Le peut-il
aujourd'hui avec l'en-tête <code>Expect:</code> (section 14.20
du <a href="2616.html" class="rfc" title="Consultez l'analyse du RFC 2616">RFC 2616</a>) ? Non, car
<code>Expect:</code> est impératif : tout serveur, ou même
tout intermédiaire (par exemple un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/relais" title="Consultez l'article &quot;relais&quot; de l'encyclopédie libre Wikipedia">relais</a></b>) qui
ne le comprend pas, ou ne peut lui obéir, doit rejeter la
requête. <code>Expect:</code> ne convient donc pas pour le cas
où on veut dire « si tu arrives à le faire comme cela, ça
m'arrangerait mais ne te casse pas trop la tête ». Comme le dit le
RFC, dans un style très <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Jane%20Austen" title="Consultez l'article &quot;Jane Austen&quot; de l'encyclopédie libre Wikipedia">Jane Austen</a></b>,
« <i class="foreign" xml:lang="en">preferences cannot be used as expectations</i> ». C'est
d'autant plus important que certaines préférences peuvent avoir un
coût de traitement élevé pour le serveur et que, si celui-ci les
acceptait aveuglément, il pourrait se retrouver victime d'un
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Attaque%20par%20d%C3%A9ni%20de%20service" title="Consultez l'article &quot;Attaque par déni de service&quot; de l'encyclopédie libre Wikipedia">déni de service</a></b> (cf. section 6).</p></div>
<div class="para"><p>La section 2 spécifie la syntaxe du nouvel en-tête
<code>Prefer:</code>. Sa sémantique, on l'a vu, est qu'il n'est
pas impératif. Le serveur qui ne comprend pas un
<code>Prefer:</code> ou ne peut pas ou ne veut pas le
respecter continue le traitement de la requête en ignorant cet
en-tête. Il peut y avoir plusieurs en-têtes
<code>Prefer:</code> ou bien un seul avec une liste de
préférences séparées par des virgules, comme ici :
</p><pre>
GET /coffee HTTP/1.1
Prefer: no-sugar, no-milk, hot
</pre><p>
Certaines préférences prennent une valeur, après un signe
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/%3D" title="Consultez l'article &quot;=&quot; de l'encyclopédie libre Wikipedia">=</a></b> :
</p><pre>
GET /coffee HTTP/1.1
Prefer: sugar=2
</pre><p>
Il peut aussi
y avoir des paramètres à certaines préférences, après un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/%3B" title="Consultez l'article &quot;;&quot; de l'encyclopédie libre Wikipedia">;</a></b> comme :
</p><pre>
GET /coffee HTTP/1.1
Prefer: milk; organic="true"
</pre><p>
Vu le caractère optionnel de ce système de préférences, on ne
s'étonnera pas que le RFC demande aux serveurs HTTP d'ignorer les
préférences inconnues (ce qui est le cas de <code>milk</code>
ou <code>sugar</code>, qui ne sont pas dans <a href="https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#preferences">le registre officiel</a>...)
</p></div>
<div class="para"><p>Que peut-on mettre dans un champ
<code>Prefer:</code> ? Uniquement des préférences <a href="https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#preferences">enregistrées</a>. La section 4 décrit les préférences
existant actuellement :
</p><ul>
<li><code>respond-async</code> indique que le client n'aime
pas attendre et préfère une réponse asynchrone plus tard. Le serveur
qui acceptera enverra alors un code de retour 202, accompagné d'un
champ <code>Location:</code> pour indiquer où récupérer la
réponse lorsqu'elle sera prête. Cette préférence ne prend pas de
valeur.</li>
<li>Par contre, la préférence <code>wait</code> prend une valeur, le nombre de
secondes qu'on est prêt à attendre, ce qui est utile en combinaison
avec <code>respond-async</code>. Ainsi, <code>Prefer:
respond-async, wait=30</code> signifiera qu'on est prêt à attendre
une demi-minute, puis qu'on préférerait une réponse asynchrone
ensuite.</li>
<li><code>return</code> a aussi une
valeur, indiquant si le client préfère recevoir la ressource entière
ou bien une version allégée. <code>Prefer:
return=representation</code> exprime le premier choix et
<code>Prefer: return=minimal</code> le second (c'est sans
doute ce que demanderont les clients connectés à un réseau très lent).</li>
<li>Enfin, <code>handling</code> indique où le client met le
curseur entre le libéralisme et la
rigidité. <code>handling=lenient</code> signifie que le client
préférerait que le serveur soit libéral, où cas où la requête
contienne quelques erreurs mineures,
<code>handling=strict</code>, que le client demande au serveur
de n'accepter que des requêtes parfaites.</li>
</ul></div>
<div class="para"><p>Comme le respect de <code>Prefer:</code> est facultatif,
attention à ne pas l'utiliser comme substitut de la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/n%C3%A9gociation%20de%20contenu" title="Consultez l'article &quot;négociation de contenu&quot; de l'encyclopédie libre Wikipedia">négociation de contenu</a></b>. En effet, il peut être
ignoré par les <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cache%20web" title="Consultez l'article &quot;Cache web&quot; de l'encyclopédie libre Wikipedia">caches</a></b>, 
qui pourraient mémoriser un contenu correspondant à certaines
préférences et le servir à d'autres clients qui auraient d'autres
préférences. Si le serveur sert des contenus différents selon les
préférences, il doit penser à mettre un <code>Vary:</code>
dans la réponse.</p></div>
<div class="para"><p>Si le serveur HTTP est sympa, il peut inclure dans la réponse un
en-tête <code>Preference-Applied:</code> qui indique quelles
préférences ont été effectivement appliquées. Un exemple avec la
commande <code>PATCH</code> du <a href="5789.html" class="rfc" title="Consultez l'analyse du RFC 5789">RFC 5789</a> et le format du <a href="6902.html" class="rfc" title="Consultez l'analyse du RFC 6902">RFC 6902</a> :
</p><pre>
PATCH /my-document HTTP/1.1
Host: example.org
Content-Type: application/json-patch
Prefer: return=representation

[{"op": "add", "path": "/a", "value": 1}]
</pre><p>
qui entraîne la réponse :
</p><pre>
HTTP/1.1 200 OK
Content-Type: application/json
Preference-Applied: return=representation
Content-Location: /my-document

{"a": 1}
</pre></div>
<div class="para"><p>Les détails bureaucratiques sont en section 5, consacrée aux
registres <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Internet%20Assigned%20Numbers%20Authority" title="Consultez l'article &quot;Internet Assigned Numbers Authority&quot; de l'encyclopédie libre Wikipedia">IANA</a></b>. Les en-têtes
<code>Prefer:</code> et
<code>Preference-Applied:</code> sont ajoutés au <a href="http://www.iana.org/assignments/message-headers/perm-headers.html">registre
des en-têtes</a>. Un nouveau registre, pour stocker les
préférences, est <a href="https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#preferences">créé</a>. Les
enregistrements se feront selon la politique « Norme nécessaire » du
<a href="5226.html" class="rfc" title="Consultez l'analyse du RFC 5226">RFC 5226</a> : chaque préférence devra être décrite
dans un document stable, décrivant ses caractéristiques syntaxiques et
sémantiques. Le tout sera envoyé à la liste
<code>ietf-http-wg@w3.org</code> pour un premier examen, puis
approuvé ou rejeté par l'expert nommé par l'IANA.</p></div>
<div class="para"><p>Début 2013, il semble que cet en-tête <code>Prefer:</code>
soit déjà géré par <b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Apache%20Abdera" title="Consultez l'article &quot;Apache Abdera&quot; de l'encyclopédie libre Wikipedia (en anglais)">Abdera</a></b>. Le protocole
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Open%20Data%20Protocol" title="Consultez l'article &quot;Open Data Protocol&quot; de l'encyclopédie libre Wikipedia">OData</a></b> cite aussi cet en-tête. Mais on ne
s'attend pas à ce qu'il soit massivement utilisé par les
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Navigateur%20Web" title="Consultez l'article &quot;Navigateur Web&quot; de l'encyclopédie libre Wikipedia">navigateurs</a></b> : il est plutôt prévu pour des
clients automatiques, appelant une <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Interface%20de%20programmation" title="Consultez l'article &quot;Interface de programmation&quot; de l'encyclopédie libre Wikipedia">API</a></b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Representational%20State%20Transfer" title="Consultez l'article &quot;Representational State Transfer&quot; de l'encyclopédie libre Wikipedia">REST</a></b>.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7240.txt">Téléchargez le RFC 7240</a></p>
<br />
<a href="7240.html">
L'article seul
</a>
<hr class="wide"/>
<h2 xml:lang="en"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7239.txt">RFC 7239</a>: Forwarded HTTP Extension</h2><p>Date de publication du RFC : Juin 2014<br/>Auteur(s) du RFC : A. Petersson, M. Nilsson (Opera Software)<br/>Chemin des normes<br/>Réalisé dans le cadre du groupe de travail IETF <b><a href="http://tools.ietf.org/wg/appsawg">appsawg</a></b><br/>Première rédaction de cet article le 17 juin 2014<br/></p><hr/>
<div class="para"><p>Lorsqu'un <b class="emphasis">client</b> <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Hypertext%20Transfer%20Protocol" title="Consultez l'article &quot;Hypertext Transfer Protocol&quot; de l'encyclopédie libre Wikipedia">HTTP</a></b> se connecte
directement à un <b class="emphasis">serveur</b> HTTP, ce dernier voit
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/adresse%20IP" title="Consultez l'article &quot;adresse IP&quot; de l'encyclopédie libre Wikipedia">adresse IP</a></b> du client et peut la
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Historique%20(informatique)" title="Consultez l'article &quot;Historique (informatique)&quot; de l'encyclopédie libre Wikipedia">journaliser</a></b> pour la traçabilité, faire du contrôle d'accès, des statistiques,
etc. Mais si le client est passé par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Proxy" title="Consultez l'article &quot;Proxy&quot; de l'encyclopédie libre Wikipedia">relais</a></b>
(<i class="foreign" xml:lang="en">proxy</i>) ? La solution proposée par notre
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Request%20for%20comments" title="Consultez l'article &quot;Request for comments&quot; de l'encyclopédie libre Wikipedia">RFC</a></b> est que le relais ajoute un en-tête,
<code>Forwarded:</code>, à la requête, reprenant l'information
que le passage par le relais a fait perdre. Il existait déjà des
en-têtes non standards pour ce rôle, ce RFC est le premier à
normaliser.</p></div>
<div class="para"><p>Notez que, non seulement les relais sont d'un usage très fréquent
dans le <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/World%20Wide%20Web" title="Consultez l'article &quot;World Wide Web&quot; de l'encyclopédie libre Wikipedia">Web</a></b> d'aujourd'hui, mais qu'ils sont
souvent inconnus du client, par exemple parce qu'ils s'insèrent
automatiquement dans la requête HTTP, sans configuration
explicite. Même s'il voulait indiquer son adresse IP, le client ne
pourrait pas. Il est donc nécessaire que ce soit le relais qui le
fasse. La plupart du temps, la perte d'information due au relais (on
n'a plus accès à l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/adresse%20IP" title="Consultez l'article &quot;adresse IP&quot; de l'encyclopédie libre Wikipedia">adresse IP</a></b> du client) n'est
pas le but principal du relais, ni même un effet souhaité. Le relais
vise par exemple à diminuer l'usage de la liaison Internet en gardant
les ressources Web dans son cache. Dans ce cas, la perte d'information
est un effet de bord non désiré et on peut souhaiter que le relais
répare le problème qu'il a causé.</p></div>
<div class="para"><p>À noter qu'il existe aussi souvent des relais situés, non pas à
proximité du client, mais proche du serveur, par exemple pour lui
ajouter une fonction de cache des données souvent accédées (le
logiciel le plus connu pour cette tâche est
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Varnish%20(software)" title="Consultez l'article &quot;Varnish (software)&quot; de l'encyclopédie libre Wikipedia (en anglais)">Varnish</a></b>). Ces relais (parfois appelés « relais
inverses ») posent le même problème (de perte d'information) et
peuvent utiliser la même solution.</p></div>
<div class="para"><p>Il existe déjà plusieurs en-têtes pour transporter l'information
jusqu'au serveur (comme <code><b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/X-Forwarded-For" title="Consultez l'article &quot;X-Forwarded-For&quot; de l'encyclopédie libre Wikipedia (en anglais)">X-Forwarded-For:</a></b></code>) mais
aucun n'avait encore été normalisé, ce qui fait que l'interopérabilité
ne pouvait être garantie. <code>Forwarded:</code> est
désormais dans le <a href="http://www.iana.org/assignments/message-headers/perm-headers.html">registre des en-têtes</a>
(section 9).</p></div>
<div class="para"><p>Parfois, le relais a au contraire pour but de dissimuler les
clients (par exemple pour permettre l'accès
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Anonymat" title="Consultez l'article &quot;Anonymat&quot; de l'encyclopédie libre Wikipedia">anonyme</a></b> au Web) et, dans ce cas, il ne va
évidemment pas utiliser la technique de ce RFC :
<code>Forwarded:</code> n'est pas obligatoire.</p></div>
<div class="para"><p>Notez que les mêmes problèmes de perte d'information (parfois
souhaitée, parfois non) se produisent avec le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Network%20Address%20Translation" title="Consultez l'article &quot;Network Address Translation&quot; de l'encyclopédie libre Wikipedia">NAT</a></b> : voir le <a href="6269.html" class="rfc" title="Consultez l'analyse du RFC 6269">RFC 6269</a>.</p></div>
<div class="para"><p>L'ancien système
non normalisé faisait en général appel à trois en-têtes, <code>X-Forwarded-For:</code>, <code>X-Forwarded-By:</code>, et
<code>X-Forwarded-Proto:</code>. Un des gros inconvénients de
ce système (et qui explique la décision de n'avoir plus qu'un
en-tête, avec plusieurs types d'information) était qu'on ne pouvait
pas savoir quels en-têtes étaient liés : rien n'indiquait si un
<code>X-Forwarded-For:</code> et un
<code>X-Forwarded-By:</code> avaient été mis par le même relais.</p></div>
<div class="para"><p>La section 4 donne la syntaxe complète de cet en-tête
<code>Forwarded:</code>. Il est bien sûr facultatif et doit
être débrayé par défaut (en raison des problèmes de protection de la
vie privée qu'il pose). Il
comporte une liste de couples {paramètre, valeur} qui permettent
d'indiquer les changements (par exemple d'adresse IP) au passage du
relais. Si plusieurs relais ont été
successivement utilisés, certains paramètres peuvent être répétés. Premier exemple, où seule l'adresse IP du « vrai » client est
indiquée :
</p><pre>
Forwarded: For="[2001:db8:cafe::17]"
</pre><p>
Autre exemple, où on met l'adresse IP et le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/port" title="Consultez l'article &quot;port&quot; de l'encyclopédie libre Wikipedia">port</a></b> originels :
</p><pre>
Forwarded: For="[2001:db8:cafe::17]:4711"
</pre><p>
Bien plus bavard, un en-tête qui indique l'adresse IP du client mais
aussi celle du relais, ainsi que le protocole original (un relais peut
transformer du HTTP en <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/HyperText%20Transfer%20Protocol%20Secure" title="Consultez l'article &quot;HyperText Transfer Protocol Secure&quot; de l'encyclopédie libre Wikipedia">HTTPS</a></b> et
réciproquement, par exemple si un relais termine les sessions
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Transport%20Layer%20Security" title="Consultez l'article &quot;Transport Layer Security&quot; de l'encyclopédie libre Wikipedia">TLS</a></b> avant de passer au vrai serveur) :
</p><pre>
Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43
</pre><p>
(Je vous laisse chercher pourquoi seules les adresses
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b> sont entre
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Guillemet" title="Consultez l'article &quot;Guillemet&quot; de l'encyclopédie libre Wikipedia">guillemets</a></b>. C'est expliqué plus loin.)
Et enfin un exemple où deux relais ont été successivement traversés, ils sont alors séparés par des virgules :
</p><pre>
Forwarded: for=192.0.2.43, for="[2001:db8:cafe::17]"
</pre></div>
<div class="para"><p>Ces paramètres (dans les exemples ci-dessus,
<code>for</code>, <code>by</code> et
<code>proto</code>) sont spécifiés en détail en section
5. <code>by</code> identifie le relais (utile, si on en a
plusieurs, ou simplement si un relais écoute sur plusieurs adresses IP
et veut indiquer laquelle a reçu la requête originale). Ce n'est pas
forcément une adresse IP. <code>for</code> identifie le client
original. Là encore, ce n'est pas forcément une adresse IP, cela peut
être un identificateur arbitraire.</p></div>
<div class="para"><p>Si ce n'est pas une adresse IP, qu'est-ce que c'est ? La section 6
décrit le concept d'identificateur, utilisé par les paramètres
<code>for</code> et <code>by</code>. Pour des raisons
de sécurité, mais aussi parce qu'ils peuvent être plus pratiques, un
relais peut toujours utiliser des identificateurs à lui pour désigner
le client (l'identificateur spécial <code>unknown</code>
indique que le relais ne sait pas). On peut donc avoir :
</p><pre>
Forwarded: for=unknown;by=203.0.113.43
</pre><p>
où le relais s'identifie mais ne veut pas ou ne peut pas dire qui est
son client (il pourrait aussi ne pas mettre <code>for</code>
du tout mais le <code>unknown</code> indique que c'est une décision
délibérée, pas un oubli).</p></div>
<div class="para"><p>Autre possibilité, utiliser des identificateurs attribués
localement (précédés par un <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Tiret%20bas" title="Consultez l'article &quot;Tiret bas&quot; de l'encyclopédie libre Wikipedia">trait bas</a></b>), qui ont un sens pour le relais mais pas forcément pour le
serveur. Cela permet la traçabilité, sans trop révéler à
l'extérieur. Exemple :
</p><pre>
Forwarded: by=_eth1
</pre><p>
ou bien :
</p><pre>
Forwarded: for=_97470ea54d581fc676f6b781b811296e
</pre><p>
Des nouveaux paramètres pourront être ajoutés dans le futur et seront
stockés dans le nouveau <a href="http://www.iana.org/assignments/http-parameters/http-parameters.xml#forwarded">registre des paramètres</a>.
</p></div>
<div class="para"><p>Enfin, les identificateurs peuvent être des adresses IP, comme dans
les précédents exemples. Dans ce cas, les adresses
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/IPv6" title="Consultez l'article &quot;IPv6&quot; de l'encyclopédie libre Wikipedia">IPv6</a></b> doivent être entre guillemets, car le
<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/deux-points" title="Consultez l'article &quot;deux-points&quot; de l'encyclopédie libre Wikipedia">deux-points</a></b> a une signification particulière
dans les en-têtes HTTP.</p></div>
<div class="para"><p>Petit point à garder en tête, l'en-tête <code>Via:</code>,
normalisé dans la section 5.7.1 du <a href="7230.html" class="rfc" title="Consultez l'analyse du RFC 7230">RFC 7230</a> ne donne, lui, d'informations que sur le
relais, pas sur le client originel. En général, on ne peut pas espérer
retrouver toute l'information en combinant <code>Via:</code>
et <code>Forwarded:</code> car certains relais mettront
uniquement un <code>Via:</code>, certains uniquement un
<code>Forwarded:</code> et d'autres les deux.</p></div>
<div class="para"><p>La section 8 couvre toutes les questions de sécurité liées à
l'en-tête <code>Forwarded:</code>. D'abord, il faut se
rappeler qu'il n'est absolument pas authentifié. Un client plaisantin
a pu en mettre un bidon au départ. Si la requête n'est pas en HTTPS,
quelqu'un sur le trajet a pu ajouter, retirer ou modifier cet en-tête
n'importe comment. Il faut donc traiter cette information avec
prudence, sauf si on est sûr que le précédent relais était une machine
de confiance.</p></div>
<div class="para"><p>Mais les plus gros problèmes de sécurité posés par ce mécanisme
concernent évidemment la fuite d'information. L'en-tête
<code>Forwarded:</code> peut révéler la structure interne d'un
réseau privé (<code>Forwarded: for=192.168.33.165</code> et on
sait quelle plage du <a href="1918.html" class="rfc" title="Consultez l'analyse du RFC 1918">RFC 1918</a> est utilisée en
interne...). Plus drôle, si un serveur renvoie cet en-tête dans la
<b class="emphasis">réponse</b> (ce que le RFC interdit), il révèle au
client les relais éventuellement non connus de ce dernier (notez qu'il
existe des <a href="tests-clients-http.html" title="Consultez ce blog à propos de &quot;tests-clients-http&quot;">sites Web pour cela</a>).</p></div>
<div class="para"><p>Mais le risque principal de cette fuite d'information est
évidemment celui de compromission de la <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/vie%20priv%C3%A9e" title="Consultez l'article &quot;vie privée&quot; de l'encyclopédie libre Wikipedia">vie privée</a></b> : l'en-tête <code>Forwarded:</code>
transmet au serveur des informations que le client peut considérer
comme privées, notamment une donnée <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Donn%C3%A9es%20personnelles" title="Consultez l'article &quot;Données personnelles&quot; de l'encyclopédie libre Wikipedia">nominative</a></b>,
l'<b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/adresse%20IP" title="Consultez l'article &quot;adresse IP&quot; de l'encyclopédie libre Wikipedia">adresse IP</a></b>. D'où le rappel qu'un relais qui
vise l'anonymisation des requêtes ne doit évidemment pas utiliser cet
en-tête.</p></div>
<div class="para"><p>Le RFC demande donc que, par défaut, les identificateurs utilisés
dans les paramètres <code>for</code> et
<code>by</code> soient opaques, et générés plus ou moins
aléatoirement, <b class="emphasis">pour chaque requête</b>. (Mon avis
personnel est que, dans ce cas, autant ne pas mettre de
<code>Forwarded:</code> du tout...) </p></div>
<div class="para"><p>Le RFC rappelle aussi que le problème de l'anonymat sur le Web est
bien plus vaste que cela : si on n'utilise pas de relais anonymisant,
on divulgue déjà son adresse IP, et il existe un million d'autres
moyens pour un serveur de suivre à la trace un client, comme le montre
le <a href="https://panopticlick.eff.org/">Panopticlick</a>. Les gens qui se plaignent de la
menace que <code>Forwarded:</code> (ou ses prédécesseurs comme
<code>X-Forwarded-For:</code>) font courir à leur vie privée
ne sont pas toujours cohérents avec eux-mêmes (par exemple, il est
rare qu'ils débrayent les
<i class="foreign" xml:lang="en"><b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Cookie%20(informatique)" title="Consultez l'article &quot;Cookie (informatique)&quot; de l'encyclopédie libre Wikipedia">cookies</a></b></i>, bien plus efficaces
pour le suivi des visiteurs).</p></div>
<div class="para"><p>Question mises en œuvre, plusieurs logiciels HTTP géraient déjà les
en-têtes non officiels (par exemple, <b><a class="wikipedia" hreflang="fr" href="http://fr.wikipedia.org/wiki/Squid" title="Consultez l'article &quot;Squid&quot; de l'encyclopédie libre Wikipedia">Squid</a></b>
<a href="http://www.squid-cache.org/Doc/config/forwarded_for/">documente
comment le configurer</a>, même chose avec
<b><a class="wikipedia" hreflang="en" href="http://en.wikipedia.org/wiki/Varnish%20(software)" title="Consultez l'article &quot;Varnish (software)&quot; de l'encyclopédie libre Wikipedia (en anglais)">Varnish</a></b> dans <a href="https://www.varnish-cache.org/docs/2.1/faq/http.html">sa
FAQ</a>). Pour le <code>Forwarded:</code>, il va falloir
attendre un peu.</p></div>
<hr/><p class="get-rfc"><a class="rfc" href="http://www.rfc-editor.org/rfc/rfc7239.txt">Téléchargez le RFC 7239</a></p>
<br />
<a href="7239.html">
L'article seul
</a>

<hr class="ultrawide" />

<p>Articles des différentes années&nbsp;:
<a href="2014_index.html">2014</a>&nbsp;
<a href="2013_index.html">2013</a>&nbsp;
<a href="2012_index.html">2012</a>&nbsp;
<a href="2011_index.html">2011</a>&nbsp;
<a href="2010_index.html">2010</a>&nbsp;
<a href="2009_index.html">2009</a>&nbsp;
<a href="2008_index.html">2008</a>&nbsp;
<a href="allyears.html">Précédentes années</a>
</p>

<p>Syndication : <a href="feed.atom" rel="nofollow">Flux Atom avec seulement les
résumés</a> et <a href="feed-full.atom" rel="nofollow">Flux Atom avec tout le
contenu</a> </p>


</div>
</div><!-- End of middle-column -->
</div><!-- End of source-order-container -->
</div><!-- End of inner-column-container -->
</div><!-- End of outer-column-container -->
<div class="clear-columns"><!-- do not delete --></div>
<div id="footer">
<div class="inside">
<hr class="hide" />
<p>Si vous aimez, vous pouvez payer avec <a href="/flattr.html">Flattr</a> <a href="https://flattr.com/submit/auto?user_id=bortzmeyer&url=http%3A%2F%2Fwww.bortzmeyer.org%2Findex.html" target="_blank"><img src="/images/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0"></a> ou avec <a href="/bitcoin-blog.html">Bitcoin</a> : adresse <code>1HtNJ6ZFUc9yu9u2qAwB4tGdGwPQasQGax</code> (ou voyez le <a href="/images/bitcoin-qrcode.png">code QR</a>). Pour toute remarque sur ce blog, s'adresser à
Stéphane Bortzmeyer <code>&lt;stephane+blog@bortzmeyer.org&gt;</code>. Je suis <a href="http://sl4.org/crocker.html">les règles de Crocker</a> donc pas besoin de faire des excès de diplomatie. Ce blog est strictement personnel et les opinions exprimées ici n'engagent donc que moi, et notamment pas mon employeur présent ou mes employeurs passés.</p>
<a href="http://prefetch.validatorsearch.verisignlabs.com"></a><!-- See http://validatorsearch.verisignlabs.com/ -->
</div>
</div><!-- End of footer -->
</div><!-- End of page-container -->
</body>
</html>


