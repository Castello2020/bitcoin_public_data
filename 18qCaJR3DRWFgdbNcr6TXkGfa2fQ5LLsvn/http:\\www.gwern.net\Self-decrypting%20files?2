http://www.gwern.net/Self-decrypting%20files?2
HTTP/1.1 200 OK
Server: cloudflare-nginx
Date: Wed, 23 Jul 2014 03:32:32 GMT
Content-Type: text/html; charset=utf-8
Connection: close
Set-Cookie: __cfduid=db3f93a59a8106659e2235257aaa00b751406086352199; expires=Mon, 23-Dec-2019 23:50:00 GMT; path=/; domain=.gwern.net; HttpOnly
x-amz-id-2: HETIIeLTEgQpf+SKQ7ao7cjfMeX9y/uZVdADNIOP7rMMH9y/ncOqF3eV2t7Ct8hrKdKEywbxb4Y=
x-amz-request-id: 90F2A202BEB4F1B6
x-amz-meta-s3cmd-attrs: uid:1000/gname:gwern/uname:gwern/gid:1000/mode:33152/mtime:1405188944/atime:1405188943/ctime:1405188944
Cache-Control: max-age=604800, public
Last-Modified: Sat, 12 Jul 2014 18:35:33 GMT
CF-RAY: 14e4cfb5348a02b8-IAD
Content-Encoding: gzip

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="generator" content="hakyll"/>
<meta name="google-site-verification" content="BOhOQI1uMfsqu_DopVApovk1mJD5ZBLfan0s9go3phk"/>
<meta name="author" content="gwern"/>
<meta name="description" content="How do you encrypt a file such that it can be broken after a date but not before?"/>
<meta name="dc.date.issued" content="24 May 2011"/>
<meta name="dcterms.modified" content="05 Jun 2014"/>
<title>Time-lock encryption</title>
<link rel="stylesheet" type="text/css" href="./static/css/default.css"/>
<link href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed"/>
<link rel="shortcut icon" type="image/x-icon" href="./static/img/favicon.ico"/>
</head>
<body>
 
<div class="indent_class1"></div>
<div id="main">
<div id="sidebar">
<div id="logo"><img alt="Logo: a Gothic/Fraktur blackletter capital G/ùï≤" height="36" src="./images/logo.png" width="32"/></div>
<div id="sidebar-links">
<p>
<a href="./index" title="index: categorized list of articles">Home</a>
<a href="./About" title="Site ideals, source, content, traffic, examples, license">Site</a>
<a href="./Links" title="Who am I online, what have I done, what am I like? Contact information; sites I use; things I've worked on">Me</a>
</p>
<hr/>
<div id="sidebar-news">
<p>
<a href="./Changelog" title="What's new or updated">New:</a>
<a href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
<a href="http://eepurl.com/Kc155" title="Monthly mailing list: signup form">MAIL</a>
</p>
<hr/>
</div>
<div id="cse-sitesearch">
<script>
            (function() {
            var cx = '009114923999563836576:dv0a4ndtmly';
            var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
            gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
            })();
          </script>
<div style="width:0px;overflow:hidden;height:0px;">
<gcse:search></gcse:search>
</div>
<form id="searchbox_009114923999563836576:dv0a4ndtmly">
<input value="009114923999563836576:dv0a4ndtmly" name="cx" type="hidden"/>
<input value="FORID:11" name="cof" type="hidden"/>
<input id="q" style name="q" size="5" type="text" placeholder="search"/>
</form>
</div>
</div>
<hr/>
<div id="metadata">
<div id="abstract"><em>How do you encrypt a file such that it can be broken after a date but not before?</em></div>
<br/>
<div id="tags"><i><a href="./tags/computer%20science">computer science</a>, <a href="./tags/cryptography">cryptography</a>, <a href="./tags/Bitcoin">Bitcoin</a></i></div>
<br/>
<div id="page-created">created:
<br/>
<i>24 May 2011</i></div>
<div id="last-modified">modified:
<br/>
<i>05 Jun 2014</i></div>
<br/>
<div id="version">status:
<br/>
<i>finished</i></div>
<br/>
<div id="epistemological-status"><a href="./About#belief-tags" title="Explanation of 'belief' metadata">belief:</a>
<br/>
<i>highly likely</i>
</div>
<hr/>
</div>
<div id="donations">
<div id="bitcoin-donation-address">
<a href="http://en.wikipedia.org/wiki/Bitcoin">‡∏ø</a>: 18qCaJR3DRWFgdbNcr6TXkGfa2fQ5LLsvn
</div>
<div id="paypal">
<form style="display: inline" action="https://www.paypal.com/cgi-bin/webscr" method="post" onClick="_gaq.push(['_trackEvent', 'Click', 'PayPalClicked', '']);">
<div class="form-type">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="8GSLCWGCC6AF8"/>
<input type="image" src="http://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" name="submit" alt="Help support my writings!"/>
</div>
</form>
</div>
<div id="Gittip">
<script data-gittip-username="gwern" data-gittip-widget="button" src="//gttp.co/v1.js"></script>
</div>
</div>
</div>
 
<div id="adsense">
<a href="http://41j.com/ads/ad.html"><img alt="Advertisement for 'HTerm, The Graphical Terminal'" src="http://41j.com/ads/ad.png" height="90" width="728"></a>
</div>
<div id="header">
<h1>Time-lock encryption</h1>
</div>
<div id="content">
<div id="TOC"><ul>
<li><a href="#uses">Uses</a></li>
<li><a href="#no-trusted-third-parties">No trusted third-parties</a></li>
<li><a href="#weak-keys">Weak keys</a></li>
<li><a href="#hashing">Hashing</a><ul>
<li><a href="#vulnerability-of-one-way-functions">Vulnerability of one-way functions</a></li>
</ul></li>
<li><a href="#successive-squaring">Successive squaring</a><ul>
<li><a href="#constant-factors">Constant factors</a></li>
</ul></li>
<li><a href="#memory-bound-hashes">Memory-bound hashes</a></li>
<li><a href="#external-links">External links</a></li>
</ul></div>
<p>Julian Assange/Wikileaks made some <a href="http://www.wired.com/threatlevel/2010/07/wikileaks-insurance-file/">headlines</a> in 2010 when they released an ‚Äúinsurance file‚Äù, an 1.4GB <a href="http://en.wikipedia.org/wiki/AES-256" title="Wikipedia: AES-256">AES-256</a>-encrypted file available through BitTorrent. It‚Äôs generally assumed that copies of the encryption key have been left with Wikileaks supporters who will, in the appropriate contingency like Assange being assassinated, leak the key online to the thousands of downloaders of the insurance file, who will then read and publicize whatever contents as in it (speculated to be additional US documents Manning gave Wikileaks); this way, if the worst happens and Wikileaks cannot afford to keep digesting the files to eventually release them at its leisure in the way it calculates will have the most impact, the files will still be released and someone will be very unhappy.</p>
<p>Of course, this is an all-or-nothing strategy. Wikileaks has no guarantees that the file will not be released prematurely, nor guarantees that it will eventually be released. Any one of those Wikileaks supporters could become disaffected and leak the key at any time - or if there‚Äôs only 1 supporter, they might lose the key to a glitch or become disaffected in the opposite direction and refuse to transmit the key to anyone. (Hope Wikileaks kept backups of the key!) If one trusts the person with the key <em>absolutely</em>, that‚Äôs fine. But wouldn‚Äôt it be nice if one didn‚Äôt have to trust another person like that? Cryptography does really well at eliminating the need to trust others, so maybe there‚Äôre better schemes.</p>
<p>Now, it‚Äôs hard to imagine how some abstract math could observe an assassination and decrypt embarrassing files. Perhaps a different question could be answered - can you design an encryption scheme which requires no trusted parties but can only be broken after a certain date?</p>
<section id="uses" class="level1">
<h1>Uses</h1>
<p>This sort of cryptography would be useful for many things; from <a href="http://people.seas.harvard.edu/~salil/research/timelock.pdf">‚ÄúTime-Lock Puzzles in the Random Oracle Model‚Äù</a> (Mahmoody et al 2011):</p>
<blockquote>
<p>In addition to the basic use of ‚Äòsending messages to the future‚Äô, there are many other potential uses of timed-release crypto. Rivest, Shamir and Wagner 1996 suggest, among other uses, delayed <a href="http://en.wikipedia.org/wiki/digital%20cash" title="Wikipedia: digital cash">digital cash</a> payments, <a href="http://crypto.stackexchange.com/questions/2507/can-i-encrypt-user-input-in-a-way-i-cant-decrypt-it-for-a-certain-period-of-tim">sealed-bid auctions</a> and <a href="http://en.wikipedia.org/wiki/key%20escrow" title="Wikipedia: key escrow">key escrow</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.108.7127&amp;rep=rep1&amp;type=pdf" title="Timed Commitments">Boneh &amp; Naor 2000</a> define timed commitments and timed signatures and show that they can be used for fair contract signing, honesty-preserving auctions and more.</p>
</blockquote>
<p><a href="http://www.cs.odu.edu/~mln/pubs/ms/haq-ms-2008.pdf" title="'Using timed-release cryptography to mitigate preservation risk of embargo periods', Haq 2008">Document embargoes</a> (eg. legal or classified documents or confessions or <a href="http://www2.warwick.ac.uk/fac/soc/law/elj/jilt/2001_3/miller/" title="'Creating A Subpoena-Proof Diary: A Technological Solution to A Legal Problem', Miller &amp; Gao 2001">coercible diaries</a>) and <a href="./docs/2002-magkos.pdf" title="'Software-based Receipt-freeness in On-line Elections', Magkos et al 2002">Receipt-free voting</a> are other applications; a cute albeit completely useless application is <a href="http://www.cn.uni-duesseldorf.de/publications/library/Jerschow2010a.pdf">‚ÄúOffline Submission with RSA Time-Lock Puzzles‚Äù</a>, Jerschow &amp; Mauve 2010:</p>
<blockquote>
<p>Our main contribution is an offline submission protocol which enables an author being currently offline to commit to his document before the deadline by continuously solving an RSA puzzle based on that document. When regaining Internet connectivity, he submits his document along with the puzzle solution which is a proof for the timely completion of the document.</p>
</blockquote>
<p>When Ross Ulbricht/Dread Pirate Roberts of <a href="Silk%20Road" title="Go to wiki page: Silk%20Road">Silk Road</a> was arrested in October 2013 and his computer with his Bitcoin hoard seized, I thought of another use: conditional transfers of wealth. Ulbricht could create a time-locked copy of his bitcoins and give it to a friend. Because bitcoins can be transferred, he can at any time use his own unlocked copy to render the copy useless and doesn‚Äôt have to worry about the friend stealing all the bitcoins from him, but if he is, say, ‚Äúshot resisting arrest‚Äù, his friend can still - eventually - recover the coins. This specific Bitcoin scenario may be <a href="https://en.bitcoin.it/wiki/Contracts">possible with the Bitcoin protocol</a>, in which case one has a nice offline digital cash system, as <a href="https://news.ycombinator.com/item?id=6509826">betterunix</a> suggests:</p>
<blockquote>
<p>Here is one possible use case: imagine an offline digital cash system, so i.e.¬†the bank will not accept the same token twice. To protect against an unscrupulous seller, the buyer pays by giving the seller a time-lock puzzle with the tokens; if the goods are not delivered by some deadline, the buyer will deposit the tokens at the bank, thus preventing the seller from doing so. Otherwise the seller solves the puzzle and makes the deposit. This is basically an anonymity-preserving escrow service, though in practice there are probably simpler approaches.</p>
</blockquote>
<p>One not-so-cute use is in defeating <a href="http://en.wikipedia.org/wiki/antivirus%20software" title="Wikipedia: antivirus software">antivirus software</a>. <a href="http://tuts4you.com/download.php?view.2348">‚ÄúAnti-Emulation Through Time-Lock Puzzles‚Äù</a>, Ebringer 2008 outlines it: one starts a program with a small time-lock puzzle which must be solved before the program does anything evil, in the hopes that the antivirus scanner will give up or stop watching before the puzzle has been solved and the program decrypts the evil payload; the puzzle‚Äôs math backing means no antivirus software can analyze or solve the puzzle first. The basic functionality cannot be blacklisted as it is used by legitimate cryptography software such as <a href="http://en.wikipedia.org/wiki/OpenSSL" title="Wikipedia: OpenSSL">OpenSSL</a> which would be expensive collateral damage.</p>
</section>
<section id="no-trusted-third-parties" class="level1">
<h1>No trusted third-parties</h1>
<p>Note that this bars a lot of the <a href="http://www.halfbakery.com/idea/Do_20not_20decrypt_20until_20_2e_2e_2e">usual suggestions</a> for cryptography schemes. For example the general approach of <a href="http://en.wikipedia.org/wiki/key%20escrow" title="Wikipedia: key escrow">key escrow</a> (eg. <a href="http://groups.csail.mit.edu/cis/pubs/shafi/1997-ccs.pdf">Bellare &amp; Goldwasser</a> 1996) if you trust some people, you can just adopt a <a href="http://en.wikipedia.org/wiki/secret%20sharing" title="Wikipedia: secret sharing">secret sharing</a> protocol where they XOR together their keys to get the master key for the publicly distributed encrypted file. Or if you only trust some of those people (but are unsure which will try to betray you and either release early or late), you can adopt where <em>k</em> of the <em>n</em> people suffice to reconstruct the master key like <a href="ftp://ftp.deas.harvard.edu/techreports/tr-22-06.pdf">Rabin &amp; Thorpe</a> 2006. (And you can connect multiple groups, so each decrypts some necessary keys for the next group; but this gives each group a consecutive veto on release‚Ä¶) Or perhaps something could be devised based on <a href="http://en.wikipedia.org/wiki/trusted%20timestamping" title="Wikipedia: trusted timestamping">trusted timestamping</a> like <a href="http://www.cs.ucla.edu/~rafail/PUBLIC/42.pdf">Crescenzo et al</a> 1999 or <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.3030&amp;rep=rep1&amp;type=ps">Blake &amp; Chan</a> 2004; but then don‚Äôt you need the <a href="http://en.wikipedia.org/wiki/trusted%20third%20party" title="Wikipedia: trusted third party">trusted third party</a> to survive on the network? Or <a href="http://en.wikipedia.org/wiki/secure%20multi-party%20computation" title="Wikipedia: secure multi-party computation">secure multi-party computation</a> (but don‚Äôt <em>you</em> need to be on the network, or risk all the parties saying ‚Äòscrew it, we‚Äôre too impatient, let‚Äôs just pool our secrets and decrypt the file <em>now</em>‚Äô?) or you could exploit physics and use the speed of light to communicate with <a href="http://www.reddit.com/r/crypto/comments/r4q2q/reliable_timelock_crypto_step_one_obtain_a/" title="Reliable time-lock crypto. Step one: obtain a deep-space probe...">a remote computer on a spacecraft</a> (except now we‚Äôre trusting the spacecraft as our third party, hoping no one stole its onboard private key &amp; is able to decrypt our transmissions instantaneously)‚Ä¶</p>
<p>One approach is to focus on creating problems which can be solved with a large but precise amount of work, reasoning that if the problem can‚Äôt be solved in less than a month, then you can use that as a way to guarantee the file can‚Äôt be decrypted <em>within</em> a month‚Äôs time. (This would be a <a href="http://en.wikipedia.org/wiki/proof-of-work%20system" title="Wikipedia: proof-of-work system">proof-of-work system</a>.) This has its own problems<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, but it at least delivers what it promises</p>
</section>
<section id="weak-keys" class="level1">
<h1>Weak keys</h1>
<p>One could encrypt the file against information that will be known in the future, like stock prices - except wait, how can you find out what stock prices will be a year from now? You can‚Äôt use anything that is public knowledge <em>now</em> because that‚Äôd let the file be decrypted immediately, and by definition you don‚Äôt have access to information currently unknown but which will be known in the future, and if you generate the information yourself planning to release it, now you have problems - you can‚Äôt even trust yourself (what if you are abruptly assassinated like <a href="http://en.wikipedia.org/wiki/Gerald%20Bull" title="Wikipedia: Gerald Bull">Gerald Bull</a>?) much less your confederates.</p>
<p>The first approach that jumps to mind is to encrypt the file, but with a relatively short or weak key, one which will take years to bruteforce. Instead of a symmetrical key at 256 bits, perhaps one of 50 bits or 70 bits?</p>
<p>This fails because we realize that we can guarantee on average how much work it will take to bruteforce the key, but we cannot guarantee how much time it will take. It may take a CPU years to bruteforce a chosen key-length, but take a cluster of CPUs just months. Or worse than that, without invoking clusters or supercomputers - devices can differ dramatically now even in the same computers; to take the example of <a href="http://en.wikipedia.org/wiki/Bitcoin" title="Wikipedia: Bitcoin">Bitcoin</a> mining, my laptop‚Äôs 2GHz CPU can search for hashes at 4k/sec, or its single outdated GPU can search at 54<em>m</em>/second<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. This 1200x speedup is not because the GPU‚Äôs clockspeed is 2400GHz or anything like that, it is because the GPU has hundreds of small specialized processors which are able to compute hashes, and the particular application does not require the processors to coordinate or anything like that which might slow them down. Incidentally, this imbalance between CPUs and highly-parallel specialized chips has had the negative effect of centralizing Bitcoin mining power, reducing the security of the network.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Many <a href="http://en.wikipedia.org/wiki/GPGPU%23Applications" title="Wikipedia: GPGPU#Applications">scientific applications</a> have moved to clusters of GPUs because they offer such great speedups; as have a number of cryptographic applications such as generating<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> <a href="http://en.wikipedia.org/wiki/rainbow%20tables" title="Wikipedia: rainbow tables">rainbow tables</a>. Someone who tries to time-lock a file using a parallelizable form of work renders themselves vulnerable to any attackers like the NSA or botnets with large numbers of computers, but may also render themselves vulnerable to an ordinary computer-gamer with 2 new GPUs: it would not be very useful to have a time-lock which guarantees the file will be locked between a year and a millennium, depending on how many &amp; what kind of people bother to attack it and whether Moore‚Äôs law continues to increase the parallel-processing power available.</p>
<p>So anything which is parallel, like using short keys, is probably useless. We need an approach which is inherently <em>serial</em>.</p>
</section>
<section id="hashing" class="level1">
<h1>Hashing</h1>
<p>For example, one could take a <a href="http://en.wikipedia.org/wiki/Cryptographic%20hash%20function" title="Wikipedia: Cryptographic hash function">hash</a> like <a href="http://en.wikipedia.org/wiki/bcrypt" title="Wikipedia: bcrypt">bcrypt</a>, give it a random input, and hash it for a month. Each hash depends on the previous hash, and there‚Äôs no way to skip from the first hash to the trillionth hash. After a month, you use the final hash as the encryption key, and then release the encrypted file and the random input to all the world. The first person who wants to decrypt the file has no choice but to redo the trillion hashes in serial order to reach the same encryption key you used.</p>
<p>Nor can the general public (or the NSA) exploit the parallelism they have available, because each hash depends sensitively on the hash before it - the <a href="http://en.wikipedia.org/wiki/avalanche%20effect" title="Wikipedia: avalanche effect">avalanche effect</a> is a key property to cryptographic hashes.</p>
<p>On the other hand, there seems to be a way that the original person running this algorithm <em>can</em> run it in parallel: one generates <em>n</em> random inputs (for <em>n</em> CPUs, presumably), and sets them hashing as before for say a month. Then, one sets up a chain between the <em>n</em> results - the final hash of seed 1 is used to encrypt seed 2, the final hash of which was the encryption for seed 3, and so on. Then one releases the encrypted file, first seed, and the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></math> <em>encrypted</em> seeds. Now the public has to hash the first seed for a month, and only then can it decrypt the second seed, and start hashing <em>that</em> for a month, and so on. Karl Gluck suggests that like repeated squaring, it‚Äôs even possible to add error-detection to the procedure<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. (A somewhat similar scheme, <a href="http://www.cs.pitt.edu/~mehmud/docs/abliz09tourpuzzle.pdf" title="Abliz &amp; Znati 2009">‚ÄúA Guided Tour Puzzle for Denial of Service Prevention‚Äù</a>, uses network latency rather than hash outputs as the chained data - clients bounce from resources to resource - but this obviously requires an online server and is unsuitable for our purposes, among <a href="http://www.reddit.com/r/compsci/comments/1nx0n5/timelock_encryption/ccne7bk">other problems</a>.)</p>
<p>This is pretty clever. If one has a thousand CPUs handy, one can store up 3 years‚Äô of computation-resistance in just a day. This satisfies a number of needs. (Maybe; please do not try to use this for a real application before getting a proof from a cryptographer that chained hashing is secure.) But what about people who only have a normal computer? Fundamentally, this repeated hashing requires you to put in as much computation as you want your public to expend reproducing the computation, which is not enough. We want to force the public to expend more computation - potentially much more - than we put in. How can we do this?</p>
<p>It‚Äôs hard to see. At least, I haven‚Äôt thought of anything clever. <a href="http://en.wikipedia.org/wiki/Homomorphic%20encryption" title="Wikipedia: Homomorphic encryption">Homomorphic encryption</a> promises to let us encode arbitrary computations into an encrypted file, so one could imagine implementing the above hash chains <em>inside</em> the homomorphic computation, or perhaps just encoding a loop counting up to a large number. There are two problems with trying to apply homomorphic encryption:</p>
<ol type="1">
<li><p>I don‚Äôt know how one would let the public decrypt the result of the homomorphic encryption without also letting them tamper with the loop.</p>
Suppose one specifies that the final output is encrypted to a weak key, so one simply has to run the homomorphic system to completion and then put in a little effort to break the homomorphic encryption to get the key which unlocks a file; what stops someone from breaking the homomorphic encryption at the very start, manually examining the running program, and shortcutting to the end result? Of course, one could postulate that what was under the homomorphic encryption was something like a hash-chain where predicting the result is impossible - but then why bother with the homomorphic encryption? Just use that instead!</li>
<li><p>and in any case, homomorphic encryption as of 2013 is a net computational loss: it takes as much or more time to create such a program as it would take to run the program, and is no good.</p></li>
</ol>
<section id="vulnerability-of-one-way-functions" class="level2">
<h2>Vulnerability of one-way functions</h2>
<p>As it turns out, <a href="http://people.seas.harvard.edu/~salil/research/timelock.pdf">‚ÄúTime-Lock Puzzles in the Random Oracle Model‚Äù</a> (Mahmoody, Moran, and Vadhan 2011; <a href="http://www.iacr.org/conferences/crypto2011/slides/01-3-Mahmoody.pdf">slides</a>) directly &amp; formally analyzes the general power of one-way functions used for time-lock puzzles assuming a <a href="http://en.wikipedia.org/wiki/random%20oracle" title="Wikipedia: random oracle">random oracle</a>. Unfortunately, they find an opponent can exploit the oracle to gain speedups. Fortunately, the cruder scheme where one ‚Äòstores up‚Äô computation (repeatedly asking the oracle at inputs based on its previous output) still works under their assumptions:</p>
<blockquote>
<p><em>A time-lock puzzle with a linear gap in parallel time.</em> Although our negative results rule out ‚Äòstrong‚Äô time-lock puzzles, they still leave open the possibility for a weaker version: one that can be generated with <em>n</em> parallel queries to the oracle but requires <em>n</em> rounds of adaptive queries to solve. In a positive result, we show that such a puzzle can indeed be constructed‚Ä¶Although this work rules out black-box constructions (with a super-constant gap) from one-way permutations and collision-resistant hash functions, we have no reason to believe that time-lock puzzles based on other concrete problems (e.g., lattice-based problems) do not exist. Extending our approach to other general assumptions (e.g., trapdoor permutations) is also an interesting open problem.</p>
</blockquote>
<p>That is, the puzzle constructor can construct the puzzle in parallel, and the solver has to solve it serially.</p>
</section>
</section>
<section id="successive-squaring" class="level1">
<h1>Successive squaring</h1>
<p>At this point, let‚Äôs see what the crypto experts have to say. Googling to see what the existing literature was (after I‚Äôd thought of the above schemes), I found that the relevant term is ‚Äútime-lock puzzles‚Äù (from analogy with the bank vault <a href="http://en.wikipedia.org/wiki/time%20lock" title="Wikipedia: time lock">time lock</a>). In particular, <a href="http://en.wikipedia.org/wiki/Ron%20Rivest" title="Wikipedia: Ron Rivest">Rivest</a>/<a href="http://en.wikipedia.org/wiki/Adi%20Shamir" title="Wikipedia: Adi Shamir">Shamir</a>/<a href="http://en.wikipedia.org/wiki/David%20A.%20Wagner" title="Wikipedia: David A. Wagner">Wagner</a> have published a 1996 paper on the topic, <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.5709">‚ÄúTime-lock puzzles and timed-release crypto‚Äù</a>. Apparently the question was first raised by <a href="http://en.wikipedia.org/wiki/Timothy%20C.%20May" title="Wikipedia: Timothy C. May">Timothy C. May</a> on the <a href="http://en.wikipedia.org/wiki/Cypherpunks%20mailing%20list" title="Wikipedia: Cypherpunks mailing list">Cypherpunks mailing list</a> in an <a href="http://cypherpunks.venona.com/date/1993/02/msg00129.html" title="Timed-Release Crypto">email from 10 February 1993</a>. May also discusses the topic briefly in his <em><a href="http://en.wikipedia.org/wiki/Cyphernomicon" title="Wikipedia: Cyphernomicon">Cyphernomicon</a></em>, <a href="http://www.cypherpunks.to/faq/cyphernomicron/chapter14.html">ch14.5</a>; unfortunately, May‚Äôs solution (14.5.1) is essentially to punt to the legal system and rely on legal privilege and economic incentives to keep keys private.  </p>
<p>Rivest et al agree with us that</p>
<blockquote>
<p>There are 2 natural approaches to implementing timed-release crypto:</p>
<ul>
<li>Use ‚Äòtime-lock puzzles‚Äô - computational problems that can not be solved without running a computer continuously for at least a certain amount of time.</li>
<li>Use trusted agents who promise not to reveal certain information until a specified date.</li>
</ul>
</blockquote>
<p>And that for time-lock puzzles:</p>
<blockquote>
<p>Our goal is thus to design time-lock puzzles that, to the great extent possible, are ‚Äòintrinsically sequential‚Äô in nature, and can not be solved substantially faster with large investments in hardware. In particular, we want our puzzles to have the property that putting computers to work together in parallel doesn‚Äôt speed up finding the solution. (Solving the puzzle should be like having a baby: two women can‚Äôt have a baby in 4.5 months.)</p>
</blockquote>
<p>Rivest et al then points out that the most obvious approach - encrypt the file to a random short key, short enough that brute-forcing takes only a few months/years as opposed to eons - is flawed because brute-forcing a key is very <a href="http://en.wikipedia.org/wiki/EFF%20DES%20cracker" title="Wikipedia: EFF DES cracker">parallelizable</a> and amenable to <a href="http://en.wikipedia.org/wiki/Custom%20hardware%20attack" title="Wikipedia: Custom hardware attack">special hardware</a><a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. (And as well, the randomness of searching a key space means that the key might be found very early or very late; any estimate of how long it will take to brute force is just a guess.) One cute application of the same brute-forcing idea is <a href="http://en.wikipedia.org/wiki/Merkle%27s%20Puzzles" title="Wikipedia: Merkle‚Äôs Puzzles">Merkle‚Äôs Puzzles</a> where the time-lock puzzle is used to hide a key for a second-party to communicate with the first-party creator, but it has the same drawback: it has the creator make many time-lock puzzles (any of which could be used by the second-party) and raises the cost to the attacker (who might have to crack each puzzle), but can be defeated by a feasibly wealthy attacker, and offers only probabilistic guarantees (what if the attacker cracks the same puzzle the second-party happens to choose?).</p>
<p>Rivest et al propose a scheme in which one encrypts the file with a very strong key as usual, but then one encrypts the key in such a way that one must calculate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mtext mathvariant="normal">encryptedKey</mtext><msup><mn>2</mn><mi>t</mi></msup></msup><mtext mathvariant="normal">mod</mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> where <em>t</em> is the adjustable difficulty factor. With the original numbers, one can easily avoid doing the <a href="http://mathworld.wolfram.com/SuccessiveSquareMethod.html">successive squarings</a>. This has the nice property that the puzzle constructor invests only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math> computing power, but the solver has to spend <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></math> computing power. (This scheme works in the random oracle model, but <a href="http://www.cs.princeton.edu/~boaz/Papers/merkle.pdf">Barak &amp; Mahmoody-Ghidary</a> 2009 proves that is the best you can do.)</p>
<p>Rivest <a href="http://people.csail.mit.edu/rivest/lcs35-puzzle-description.txt">has actually used</a> this scheme for a time capsule commemorating the <a href="http://en.wikipedia.org/wiki/MIT%20Computer%20Science%20and%20Artificial%20Intelligence%20Laboratory" title="Wikipedia: MIT Computer Science and Artificial Intelligence Laboratory">MIT Computer Science and Artificial Intelligence Laboratory</a>; he expects his puzzle to take ~35 years. As of 14 years later, <a href="http://crypto.stackexchange.com/questions/5831/what-is-the-progress-on-the-mit-lcs35-time-capsule-crypto-puzzle" title="What is the progress on the MIT LCS35 Time Capsule Crypto-Puzzle?">minimal progress</a> seems to have been made; if anything, the breakdown of CPU clockspeeds seems to imply that it will take far more than 35 years<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> Rivest offers some advice for anyone attempting to unlock this time-lock puzzle (may or may not be related to Mao‚Äôs 2000 paper <a href="./docs/2000-mao.pdf">‚ÄúTime-Lock Puzzle with Examinable Evidence of Unlocking Time‚Äù</a>):</p>
<blockquote>
<p>An interesting question is how to protect such a computation from errors. If you have an error in year 3 that goes undetected, you may waste the next 32 years of computing. Adi Shamir has proposed a slick means of checking your computation as you go, as follows. Pick a small (50-bit) prime <em>c</em>, and perform the computation modulo <em>cn</em> rather than just modulo <em>n</em>. You can check the result modulo <em>c</em> whenever you like; this should be a extremely effective check on the computation modulo <em>n</em> as well.</p>
</blockquote>
<section id="constant-factors" class="level2">
<h2>Constant factors</h2>
<p>How well does this work? The complexity seems correct, but I worry about the constant factors. Back in 1996, computers were fairly homogeneous, and Rivest et al could reasonably write</p>
<blockquote>
<p>We know of no obvious way to parallelize it to any large degree. (A small amount of parallelization may be possible <em>within</em> each squaring.) The degree of variation in how long it might take to solve the puzzle depends on the variation in the speed of single computers and not on one‚Äôs total budget. Since the speed of hardware available to individual consumers is within a small constant factor of what is available to large intelligence organizations, the difference in time to solution is reasonably controllable.</p>
</blockquote>
<p>But I wonder how true this is. Successive squaring does not seem to be a very complex algorithm to implement in hardware. There are more exotic technologies than GPUs we might worry about, like <a href="http://en.wikipedia.org/wiki/field-programmable%20gate%20array" title="Wikipedia: field-programmable gate array">field-programmable gate array</a>s which may be specialized for successive squaring; if problems like the <a href="http://en.wikipedia.org/wiki/n-body%20problem" title="Wikipedia: n-body problem">n-body problem</a> can be <a href="http://en.wikipedia.org/wiki/Gravity%20Pipe" title="Wikipedia: Gravity Pipe">handled with custom chips</a>, why not multiplication? Or, since squaring seems simple, is it relevant to forecasts of serial speed that there are <a href="http://en.wikipedia.org/wiki/graphene" title="Wikipedia: graphene">graphene</a> transistor prototypes going as high as <a href="http://www.pnas.org/content/109/29/11588.full" title="'High-frequency self-aligned graphene transistors with transferred gate stacks', Cheng et al 2012">100GHz</a>? Offhand, I don‚Äôt know of any compelling argument to the effect that there are no large constant-factor speedups possible for multiplication/successive-squaring. Indeed, the general approach of exponentiation and factoring has to worry about the fact that the complexity of factoring has never been proven (and could still be very fast) and that there are speedups with quantum techniques like <a href="http://en.wikipedia.org/wiki/Shor%27s%20algorithm" title="Wikipedia: Shor‚Äôs algorithm">Shor‚Äôs algorithm</a>.</p>
</section>
</section>
<section id="memory-bound-hashes" class="level1">
<h1>Memory-bound hashes</h1>
<p>Of course, one could ask the same question of my original proposal - what makes you think that hashing can‚Äôt be sped up? You already supplied an example where cryptographic hashes were sped up astonishingly by a GPU, Bitcoin mining.</p>
<p>The difference is that hashing can be made to stress the weakest part of any modern computer system, the <a href="http://en.wikipedia.org/wiki/memory%20hierarchy" title="Wikipedia: memory hierarchy">memory hierarchy</a>‚Äôs terrible bandwidth and latency<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>; the hash can blow the fast die-level caches (the <a href="http://en.wikipedia.org/wiki/Processor%20register" title="Wikipedia: Processor register">CPU</a> &amp; its <a href="http://en.wikipedia.org/wiki/CPU%20cache" title="Wikipedia: CPU cache">cache</a>) and force constant fetches from the main RAM. They were devised for anti-spam proof-of-work systems that wouldn‚Äôt unfairly penalize cellphones &amp; PDAs while still being costly on desktops &amp; workstations (which rules out the usual functions like <a href="http://en.wikipedia.org/wiki/Hashcash" title="Wikipedia: Hashcash">Hashcash</a> that stress the CPU). For example, the 2003 <a href="http://research.microsoft.com/pubs/65154/crypto03.pdf">‚ÄúOn Memory-Bound Functions for Fighting Spam‚Äù</a>; from the abstract:</p>
<blockquote>
<p>Burrows suggested that, since memory access speeds vary across machines much less than do CPU speeds, memory-bound functions may behave more equitably than CPU-bound functions; this approach was first explored by Abadi, Burrows, Manasse, and Wobber [8]. We further investigate this intriguing proposal. Specifically, we‚Ä¶</p>
<p>2. Provide an abstract function and prove an asymptotically tight amortized lower bound on the number of memory accesses required to compute an acceptable proof of effort; specifically, we prove that, on average, the sender of a message must perform many unrelated accesses to memory, while the receiver, in order to verify the work, has to perform significantly fewer accesses; 3. Propose a concrete instantiation of our abstract function, inspired by the RC4 stream cipher; 4. Describe techniques to permit the receiver to verify the computation with no memory accesses; 5. Give experimental results showing that our concrete memory-bound function is only about four times slower on a 233 MHz settop box than on a 3.06 GHz workstation, and that speedup of the function is limited even if an adversary knows the access sequence and uses optimal off-line cache replacement.</p>
</blockquote>
<p>Abadi 2005, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.6879&amp;rep=rep1&amp;type=pdf">‚ÄúModerately hard, memory-bound functions‚Äù</a> develop more memory-bound functions and benchmark them (partially replicated by <a href="http://www.cs.jhu.edu/~rdas/finalreport.pdf">Das &amp; Doshi</a> 2004):</p>
<blockquote>
<p>‚Ä¶we give experimental results for five modern machines that were bought within a two-year period in 2000-2002, and which cover a range of performance characteristics. All of these machines are sometimes used to send e-mail-even the settop box,which is employed as a quiet machine in a home‚Ä¶None of the machines have huge caches-the largest was on the server machine, which has a 512KB cache. Although the clock speeds of the machines vary by a factor of 12, the memory read times vary by a factor of only 4.2. This measurement confirms our premise that memory read latencies vary much less than CPU speeds.</p>
<p>‚Ä¶At the high end, the server has lower performance than one might expect, because of a complex pipeline that penalizes branching code. In general, higher clock speeds correlate with higher performance, but the correlation is far from perfect‚Ä¶Second, the desktop machine is the most cost-effective one for both CPU-bound and memory-bound computations; in both cases, attackers are best served by buying the same type of machines as ordinary users. Finally, the memory-bound functions succeed in maintaining a performance ratio between the slowest and fastest machines that is not much greater than the ratio of memory read times.</p>
</blockquote>
<p>Colin Percival continues the general trend in the context of finding passwords schemes which are resistant to cheap brute-forcing, inventing <a href="http://www.tarsnap.com/scrypt.html"><code>scrypt</code></a> in the 2009 paper <a href="http://www.tarsnap.com/scrypt/scrypt.pdf">‚ÄúStronger Key Derivation via Sequential Memory-Hard Functions‚Äù</a>. Percival notes that designing a really good memory-bound function requires not overly relying on <em>latency</em> since his proofs do not incorporate latency, although in practice this might not be so bad:</p>
<blockquote>
<p>Existing widely used hash functions produce outputs of up to 512 bits (64 bytes), closely matching the cache line sizes of modern CPUs (typically 32-128 bytes), and the computing time required to hash even a very small amount of data (typically 200-2000 clock cycles on modern CPUs, depending on the hash used) is sufficient that the memory latency cost (typically 100-500 clock cycles) does not dominate the running time of ROMix.</p>
<p>However, as semiconductor technology advances, it is likely that neither of these facts will remain true. Memory latencies, measured in comparison to CPU performance or memory bandwidth, have been steadily increasing for decades, and there is no reason to expect that this will cease ‚Äî to the contrary, switching delays impose a lower bound of Œ©(log N ) on the latency of accessing a word in an N-byte RAM, while the speed of light imposes a lower bound of Œ©( ‚àöN ) for 2-dimensional circuits. Furthermore, since most applications exhibit significant locality of reference, it is reasonable to expect cache designers to continue to increase cache line sizes in an attempt to trade memory bandwidth for (avoided) memory latency.</p>
<p>In order to avoid having ROMix become latency-limited in the future, it is necessary to apply it to larger hash functions. While we have only proved that ROMix is sequential memory-hard under the Random Oracle model, by considering the structure of the proof we note that the full strength of this model does not appear to be necessary.</p>
</blockquote>
<p>Percival constructs a password algorithm on his new hash function and then calculates costs using 2002 circuit prices</p>
<blockquote>
<p>When used for interactive logins, it is 35 times more expensive than bcrypt and 260 times more expensive than PBKDF2; and when used for file encryption ‚Äî where, unlike bcrypt and PBKDF2, scrypt uses not only more CPU time but also increases the die area required ‚Äî scrypt increases its lead to a factor of 4000 over bcrypt and 20000 over PBKDF2.</p>
</blockquote>
<p>That is quite a difference between the hashes, especially considered that bcrypt and PBKDF2 were already engineered to have adjustable difficulty for similar reasons to our time-lock crypto puzzles.</p>
</section>
<section id="external-links" class="level1">
<h1>External links</h1>
<ul>
<li><a href="http://crypto.stackexchange.com/questions/606/time-capsule-cryptography">‚ÄúTime capsule cryptography?‚Äù</a> -(Cryptography <a href="http://en.wikipedia.org/wiki/StackExchange" title="Wikipedia: StackExchange">StackExchange</a>)</li>
<li><a href="https://news.ycombinator.com/item?id=6508179">Hacker News discussion</a></li>
<li><a href="http://www.reddit.com/r/compsci/comments/1nx0n5/timelock_encryption/">Reddit discussion</a></li>
</ul>
 
</section>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><p>Ebringer 2008, applying time-lock puzzles to enhancing the ability of computer viruses &amp; trojans to defeat anti-virus scanners, describes Rivest‚Äôs original successive-squaring solution somewhat sarcastically:</p>
<blockquote>
<p>Even in the original paper, the authors struggled to find a plausible use for it. To actually use the construction as a ‚Äútime-lock‚Äù requires predicting the speed of CPUs in the future, resulting, at best, in a fuzzy release-date. This assumes that someone cares enough to want what is allegedly wrapped up in the puzzle to bother to compute the puzzle in the first place. It is not obvious that in the majority of situations, this would have a clear advantage over, say, leaving the information with a legal firm with instructions to release it on a particular date. Although this paper proposes a practical use for time-lock puzzles, the original authors would probably be dismayed that there is still not a widespread usage that appears to be of net benefit to humanity.</p>
</blockquote>
<p>On the other hand, a similar criticism could and has been made about <a href="Bitcoin%20is%20Worse%20is%20Better">Bitcoin</a> (supporters/users must expend massive computing power constantly just to keep it working, with no computational advantage over attackers), and that system has worked well in practice.<a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>Actual numbers; the difference <a href="https://en.bitcoin.it/wiki/Why_a_GPU_mines_faster_than_a_CPU">really is</a> that <a href="https://en.bitcoin.it/wiki/Mining_hardware_comparison">large</a>.<a href="#fnref2">‚Ü©</a></p></li>
<li id="fn3"><p>While there are <a href="https://en.bitcoin.it/wiki/Bitcoin_Map">tens or hundreds of thousands of nodes</a> in the Bitcoin P2P network, only a few of them are actual miners because CPU mining has become useless - the big miners, who have large server farms of GPUs or ASICs, collectively control much of the hash power. This has not yet been a problem, but may. Using a (partially) memory-bound hash function is one of the selling points of a competing Bitcoin currency, <a href="https://github.com/litecoin-project/litecoin/wiki/Comparison-between-Bitcoin-and-Litecoin">Litecoin</a>.<a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p>eg. the 2008 Graves thesis, <a href="https://www.iac.iastate.edu/mediawiki/images/b/b3/Cryptohaze.pdf">‚ÄúHigh performance password cracking by implementing rainbow tables on nVidia graphics cards (IseCrack)‚Äù</a> claims a 100x speedup over CPU generation of rainbow tables, or the actively developed utility, <a href="http://www.project-rainbowcrack.com/">RainbowCrack</a> (which you can even <a href="http://www.project-rainbowcrack.com/buy.php">buy</a> the generated rainbow tables from).<a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p>On <a href="https://news.ycombinator.com/item?id=6509688">Hacker News</a></p>
<blockquote>
<p>To add checkpoints, one could release both the original seed of the chain A, and a number of pairs of hashes (x0,y0) (x1,y1) ‚Ä¶ Let‚Äôs say you wanted to do 1-month chains. Hash the seed A for a week, then take the current value x0 such that H(B)=x0. You know the value of B, since you‚Äôve been computing the chain. Pick another random value y0, and continue the chain with H(B^y0). Write (x0,y0) in the output, and hash for another week. Do the same for (x1,y1) (x2,y2) and (x3,y3). Each chain then has a seed value and 4 pairs of ‚Äòcheckpoints‚Äô. When unlocking the crypto puzzle, these checkpoints can‚Äôt be used to jump ahead in the computation, but they can tell you that you‚Äôre on the right track. I think that you could even use a secondary hash chain for the y_n values, so y_n+1=H(y_n). If you also derived y0 from A (e.g.¬†y0=H(A^const) ), you would just need to publish the seed value A and each checkpoint hash x_n in order to have a fully checkpointed crypto puzzle.</p>
</blockquote>
<a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><p>Colin Percival‚Äôs <a href="http://www.daemonology.net/blog/2011-06-03-insecurity-in-the-jungle.html">‚ÄúInsecurity in the Jungle (disk)‚Äù</a> presents a table giving times for brute-forcing <a href="http://en.wikipedia.org/wiki/MD5" title="Wikipedia: MD5">MD5</a> hashes given various hardware; most dramatically, &lt;$1m of custom <a href="http://en.wikipedia.org/wiki/Application-specific%20integrated%20circuit" title="Wikipedia: Application-specific integrated circuit">ASIC</a> hardware could bruteforce a random 10 character string in 2 hours. (Hardware reaps extreme performance gains <a href="http://www.yosefk.com/blog/its-done-in-hardware-so-its-cheap.html" title="`It's done in hardware so it's cheap`">mostly when</a> when few memory accesses are required, and a few fast operations applied to small amounts of data; this is because flexibility imposes overhead, and when the overhead is incurred just to run fast instructions, the overhead dominates the entire operation. For example, graphics chips do just a relative handful of math to a frame, again and again, and so they gain orders of magnitude speedups by being specialized chips - as does any other program which is like that, which includes cryptographic hashes designed for speed like the ones Bitcoin uses.)</p>
<p><a href="http://en.wikipedia.org/wiki/Key%20stretching%23Strength%20and%20time" title="Wikipedia: Key stretching#Strength and time">Wikipedia</a> gives an older example using <a href="http://en.wikipedia.org/wiki/Field-programmable%20gate%20array" title="Wikipedia: Field-programmable gate array">FPGAs</a> (also <a href="https://bitcointalk.org/index.php?topic=9047.0">being</a> <a href="http://www.reddit.com/r/Bitcoin/comments/hhd4l/fpga_mining/">used</a> for Bitcoin hashing):</p>
<blockquote>
<p>An important consideration to be made is that CPU-bound hash functions are still vulnerable to hardware implementations. For example, the literature provides efficient hardware implementations of SHA-1 in as low as 5000 gates, and able to produce a result in less than 400 clock cycles<sup><a href="http://rfidsec2013.iaik.tugraz.at/RFIDSec08/Papers/Publication/04%20-%20ONeill%20-%20Low%20Cost%20SHA-1%20-%20Paper.pdf" title="'Low-Cost SHA-1 Hash Function Architecture for RFID Tags', O'Neill">2</a></sup>. Since multi-million gate FPGAs can be purchased at less than $100 price points<sup><a href="http://www.xilinx.com/prs_rls/silicon_spart/0333spartan3.htm">3</a></sup>, it follows that an attacker can build a fully unrolled hardware cracker for about $5000. Such a design, if clocked at 100MHz can try about 300,000 keys/second for the algorithm proposed above.</p>
</blockquote>
<a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><p>As of 2013, the highest-frequency consumer CPU available, the AMD FX-9000, tops out at 5GHz with few prospects for substantial increases in frequency; Rivest projected 10GHz and increasing:</p>
<blockquote>
<p>Based on the SEMATECH National Technology Roadmap for Semiconductors (1997 edition), we can expect internal chip speeds to increase by a factor of approximately 13 overall up to 2012, when the clock rates reach about 10GHz. After that improvements seem more difficult, but we estimate that another factor of five might be achievable by 2034. Thus, the overall rate of computation should go through approximately six doublings by 2034.</p>
</blockquote>
<p>Moore‚Äôs law, in the original formulation of transistors per dollar, may have continued post-1997, but the gains increasingly came by parallelism, which is not useful for repeated squaring.<a href="#fnref7">‚Ü©</a></p></li>
<li id="fn8"><p>From Abadi 2005:</p>
<blockquote>
<p>Fast CPUs run much faster than slow CPUs - consider a 2.5GHz PC versus a 33MHz Palm PDA. Moreover, in addition to high clock rates, higher-end computer systems also have sophisticated pipelines and other advantageous features. If a computation takes a few seconds on a new PC, it may take a minute on an old PC, and several minutes on a PDA. That seems unfortunate for users of old PCs, and probably unacceptable for users of PDAs‚Ä¶we are concerned with finding moderately hard functions that most computer systems will evaluate at about the same speed. We envision that high-end systems might evaluate these functions somewhat faster than low-end systems, perhaps even 2-10 times faster (but not 10-100 faster, as CPU disparities might imply). Moreover, the best achievable price-performance should not be significantly better than that of a typical legitimate client‚Ä¶A memory-bound function is one whose computation time is dominated by the time spent accessing memory. The ratios of memory latencies of machines built in the last five years is typically no greater than two, and almost always less than four. (Memory throughput tends to be less uniform, so we focus on latency.) A memory-bound function should access locations in a large region of memory in an unpredictable way, in such a way that caches are ineffectual‚Ä¶Other possible applications include establishing shared secrets over insecure channels and the timed release of information, using memory-bound variants of Merkle puzzles [Merkle 1978] and of time-lock puzzles [May 1993; Rivest et al. 1996], respectively. We discuss these also in section 4.</p>
</blockquote>
<p>And here I thought I was being original in suggesting memory-bound functions for time-lock puzzles! Truly, ‚Äúthere is nothing new under the sun‚Äù.<a href="#fnref8">‚Ü©</a></p></li>
</ol>
</section>
</div>
</div>
<div id="footer">
<p>Still bored? Then try my <a href="https://plus.google.com/103530621949492999968/posts" title="Google+ posts">Google+ news feed</a>.</p>
<a href="https://docs.google.com/spreadsheet/viewform?formkey=dE5GLWpfX3RhX1c2Q1phcEo3U3VDVEE6MQ">Send anonymous feedback</a>
<br/>
<div id="license">
<p xmlns:dct="http://purl.org/dc/terms/" xmlns:vcard="http://www.w3.org/2001/vcard-rdf/3.0#">
<a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">
<img src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0" height="31" width="88"/>
</a>
</p>
</div>
</div>
 
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
 
<script type="text/javascript" src="./static/js/footnotes.js"></script>
 
<script type="text/javascript" src="./static/js/abalytics.js"></script>
<script type="text/javascript">
      window.onload = function() {
      ABalytics.applyHtml();
      };
    </script>
 
<script id="googleAnalytics" type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-18912926-1']);

      ABalytics.init({
      indent: [
      {
      name: "none",
      "indent_class1": "<style>p + p { text-indent: 0.0em; margin-top: 0 }</style>"
      },
      {
      name: "indent0.1",
      "indent_class1": "<style>p + p { text-indent: 0.1em; margin-top: 0 }</style>"
      },
      {
      name: "indent0.5",
      "indent_class1": "<style>p + p { text-indent: 0.5em; margin-top: 0 }</style>"
      },
      {
      name: "indent1.0",
      "indent_class1": "<style>p + p { text-indent: 1.0em; margin-top: 0 }</style>"
      },
      {
      name: "indent1.5",
      "indent_class1": "<style>p + p { text-indent: 1.5em; margin-top: 0 }</style>"
      },
      {
      name: "indent2.0",
      "indent_class1": "<style>p + p { text-indent: 2.0em; margin-top: 0 }</style>"
      }
      ],
      }, _gaq);

      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
 
<script id="outboundLinkTracking" type="text/javascript">
      $(function() {
      $("a").on('click',function(e){
      var url = $(this).attr("href");
      if (e.currentTarget.host != window.location.host) {
      _gat._getTrackerByName()._trackEvent("Outbound Links", e.currentTarget.host.replace(':80',''), url, 0);
      if (e.metaKey || e.ctrlKey || (e.button == 1)) {
      var newtab = true;
      }
      if (!newtab) {
      e.preventDefault();
      setTimeout('document.location = "' + url + '"', 100);
      }
      }
      });
      });
    </script>
 
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script type="text/javascript" src="./static/js/footnotes.js"></script>
 
<script type="text/javascript" src="./static/js/tablesorter.js"></script>
<script type="text/javascript" id="tablesorter">
      $(document).ready(function() {
      $("table").tablesorter();
      }); </script>
 
<div id="disqus_thread"></div>
<script type="text/javascript">
      if (document.title != 'Essays') { <!-- avoid Disqus comments on front page -->
      (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://disqus.com/forums/gwern/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
      var disqus_shortname = 'gwern';
      (function () {
      var s = document.createElement('script'); s.async = true;
      s.src = 'http://disqus.com/forums/gwern/count.js';
      (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
      }());
      }</script>
<noscript><p>Enable JavaScript for Disqus comments</p></noscript>
</body>
</html>

