http://juanjoalvarez.net/es/detail/2007/apr/25/el-lenguaje-de-programacion-d/
HTTP/1.1 200 OK
Server: nginx/1.1.19
Date: Tue, 22 Jul 2014 15:25:15 GMT
Content-Type: text/html; charset=utf-8
Connection: close
Vary: Accept-Encoding
Content-Language: es
Expires: Tue, 22 Jul 2014 16:25:15 GMT
Vary: Cookie
Last-Modified: Tue, 22 Jul 2014 15:25:15 GMT
Cache-Control: max-age=3600

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">



<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" lang="es">
  <head>

  <link rel="openid.server" href="http://openid.blogs.es/index.php/serve" />
  <link rel="openid.delegate" href="http://openid.blogs.es/juanjux" />
  <link href='http://fonts.googleapis.com/css?family=Waiting+for+the+Sunrise|Noticia+Text:700' rel='stylesheet' type='text/css'>


  <title>
El lenguaje de programación D
</title>
    
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="verify-v1" content="FVa0s3bcl9AEnUwlzw9CtxBqVGJiIHJlfNLmEOOcWyk=" />
    <link rel="alternate" type="application/rss+xml" title="JuanjoAlvarez.net RSS" href="http://feeds.feedburner.com/JuanjoalvareznetPosts" />
    <meta http-equiv="Content-Language" content="es"/>
    <meta name='description' content='Juanjo Alvarez web' />
    
       <meta name='keywords' content='Juanjo Álvarez, Juanjo Alvarez, Juanjo, Alvarez, Álvarez, Linux, Android, iPhone, Free Software, Recetas' />
    

    <link rel="stylesheet" href="/site_media/blueprint/screen.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="/site_media/blueprint/print.css" type="text/css" media="print">    
    <link rel="stylesheet" href="/site_media/blueprint/plugins/fancy-type/screen.css" type="text/css" media="screen, projection" /> 
    <style type="text/css" media="all">@import "/site_media/style.css";</style>
  </head>

  <body>
  <div class="greybackground">
 </div> <!-- Greybackground -->
    <div class="container">
      <!-- Header, Logo, etc ===================================================================== -->
      <div id="header" class="prepend-0 span-24 prepend-top last">
        <span class="logojam prepend-1">
            <!--<a href="/" title="JUANJO ALVAREZ .NET">JUANJO &Aacute;LVAREZ .NET</a>-->
            <a href="/" title="JUANJO ALVAREZ .NET">Juanjo &Aacute;lvarez .net</a>
        </span>

        <br/>

        <div class="prepend-1 small temas">
            Technology, Programming, Linux, Gadgets, Books, Games, Cooking...
        </div>

        <div id="categories">
            <ul class="links primary-links">
            <li><a href="/">Inicio</a></li>
            <li><a href="/es/category/articles">Artículos</a></li>
            <li><a href="/es/category/blog">Blog</a></li>
            <li><a href="/es/static/programs/">Programas</a></li>
            <li><a href="/es/links">Enlaces</a></li>
            <!--<li><a href="/es/contact">Contactar</a></li>-->
            </ul>    
        </div>


        <hr>


      </div> <!-- /header -->


      <hr class="space"/>

      <!-- Center Main Content ========================================================================= -->
      <div id="center" class="prepend-1 span-17 colborder">

      <!-- System Messages -->
      
        
      


      

<div class="node">

<h1 class="nodetitle">El lenguaje de programación D</h1>
          <span class="submitted">
             Última actualización:  abril 25 2007
         </span>

      <div class="content">
        
                
                    
                        En este artículo se hará una introducción al lenguaje de programación D para lo cual se explicarán las principales diferencias con respecto a C y C++; por ello sería aconsejable que el lector de este pequeño artículo conozca las características dichos lenguajes (u otros similares, como Java o C#) y algunos conceptos como la programación orientada a objetos o el control de errores mediante excepciones aunque no es necesario que sea un experto en dichos temas. 

Este artículo no es un manual ni un tutorial y por lo tanto no es la mejor referencia para aprender el lenguaje, aunque alguien que conozca C++ o de Java podrá tener una idea muy completa de D tras leerlo.

En mi opinión, D es un lenguaje con un potencial increible, capaz de proporcionar al desarrollador la productividad y la elegancia de Python o Ruby pero con la eficiencia de C. <p>

Este documento no está terminado y se irá ampliando con el tiempo; puede verse una lista de las cuestiones pendientes al final del mismo. La versión actual es la: 0.3 actualizada el 18 de septiembre de 2008. El documento es básicamente un resumen de la documentación de D, traducido, y por lo tanto la mayoría de los ejemplos están tomados de la misma. Aconsejo al lector interesado en el lenguaje que tras leer el artículo y haberse hecho una idea general, lea la referencia completa en <a href="http://digitalmars.com/d">digitalmars.com/d</a>.
 </p><p>
<!--break-->
Cambios al artículo:</p><p>
<ul>
<li> 18 de septiembre: ampliada la sección de cadenas, creada sección de propiedades (diatriba incluida), creada sección de guardas de ámbito. Arreglado "bug" en el ejemplo de los delegados (gracias Miguel.)
    </li></ul>
<!--
</p><h2>Introducción básica, lenguajes de programación, desde lo general hasta D (sáltatela si sabes de que hablo)</h2>

<p>
En informática existen cientos, o puede que miles, lenguajes de programación que permiten a los programadores expresar una idea o un diseño en un programa real que funcione en un ordenador. Pero si miramos en que lenguajes están programadas las aplicaciones veremos que en la práctica la mayoría de ellas están escritas en un conjunto muy reducido de lenguajes, los más importantes de los cuales probablemente son (en ningún orden concreto): C, C++, Java, Visual Basic, Fortran, Cobol (sí, Cobol), PHP, Perl, Python Ruby y C#. 
</p><p>

Existen muchas formas de clasificar a los lenguajes de programación. Una de ellas es clasificarlos según el modo en el que los programas generados se ejecutarán, y tendríamos según esta clasificación: 

</p><p>
</p><ul>
<li>Lenguajes compilados a código nativo: Una vez escrito el código fuente este pasaría por un programa llamado compilador que traduciría el código del programador en instrucciones del microprocesador de la máquina en la que se está ejecutando el compilador. Estos lenguajes tienen como ventaja un rendimiento excelente (habitualmente entre 5 y 100 veces la velocidad de los lenguajes interpretados o semi-compilados) y la desventaja de que el fichero generado (el &quot;ejecutable&quot;) sólo va a funcionar para una arquitectura de CPU y sistema operativo (un ejecutable de Linux en PC no vale para Windows en el mismo PC, y un ejecutable de FreeBSD en un PC no va a valer para FreeBSD en un Mac salvo que recompilemos el código fuente y generemos un ejecutable específico para esa arquitectura.) Los lenguajes de esta categoría son los elegidos habitualmente para programas de bajo nivel (sistemas operativos, controladores de dispositivos) o aplicaciones que tienen que tener una respuesta rápida (programas interactivos y gráficos de escritorio, servidores de Internet, aplicaciones de tiempo real, bases de datos, juegos, etc.) Dentro de esta categoría (de los lenguajes enumerados anteriormente) estarían C, C++, Fortran, Visual Basic y Cobol. </li>

<li>Lenguajes interpretados: En cualquier ordenador en el que se quiera ejecutar el programa escrito en uno de estos lenguajes debe existir un programa llamado el &quot;intérprete&quot;. Este se va a encargar de leer, cada vez que se va a ejecutar el programa, los ficheros de código fuente del mismo y traducirlos &quot;al vuelo&quot; a instrucciones del microprocesador. Esta forma de ejecución tiene la ventaja de que permite al lenguaje un dinamismo que es difícil de alcanzar en lenguajes compilados (que suele traducirse en una productividad muy elevada para el programador) y que suelen tener una excelente portabilidad entre arquitecturas de CPU y sistemas operativos. Entre las desventajas están que son los que peor rendimiento tienen (pues tiene que cargarse el intérprete en memoria y luego este tiene que traducir las instrucciones) y que requieren que la máquina en la que se va a ejecutar el programa tenga instalado el intérprete adecuado. De los lenguajes anteriormente nombrados estarían en esta categoría PHP, Perl, Python y Ruby. Estos lenguajes suelen utilizarse en aplicaciones web creando sitios dinámicos (especialmente en el caso de PHP) y herramientas de administración de sistemas. También suelen ser los lenguajes preferidos para aplicaciones gráficas sencillas. Un uso muy curioso que se le da en ocasiones a estos lenguajes es el &quot;prototipado de aplicaciones&quot;. Esto consiste generalmente en empezar a implementar un proyecto en uno de ellos (Python suele ser el más popular en este campo) aprovechando la enorme productividad de estos lenguajes para después, una vez se ha conseguido un diseño satisfactorio y funcional, traducir el código a un lenguaje compilado para obtener un rendimiento adecuado. </li>

<li>Lenguajes compilados a código no-nativo: Estos lenguajes son una especie de punto medio entre los lenguajes compilados a código nativo y los interpretados pues el código fuente se compila, pero en lugar de hacerlo directamente a instrucciones del microprocesador real lo hacen a un conjunto de instrucciones de bajo nivel pero &quot;genéricas&quot; para una arquitectura de microprocesador virtual. Después, cuando se carga el programa para ejecutarlo, un programa en memoria ejecutaría esas instrucciones traduciéndolas a las instrucciones reales del microprocesador donde se ejecute el programa. Esta aproximación intenta obtener algunas de las ventajas tanto de los lenguajes compilados a código nativo como de los interpretados (sin obtener por supuesto todas las ventajas de ambos.) El primer resultado es que el rendimiento suele ser mucho mayor que el de los lenguajes interpretados pero sin llegar al de los compilados a código nativo (que normalmente siguen siendo entre 3 y 10 veces más rápidos según el programa y el entorno de ejecución) siendo sin embargo la portabilidad equivalente a la de los lenguajes interpretados (sin tener sin embargo su dinamismo.) Estos lenguajes tiene muchos campos de aplicación pudiendo destacarse las herramientas de gestión empresarial, las aplicaciones web de alto rendimiento, y el software gráfico de usuario, sobre todo en aplicaciones de red. De los lenguajes enumerados caerían bajo esta categoría el Java y el C#. </li>
</ul>

<p>

Otra clasificación posible se haría atendiendo a la forma de representar las abstracciones en el código y hoy en día la más común es la &quot;programación orientada a objetos&quot; en la cual los sistemas se construyen como interacciones entre &quot;objetos&quot; que pertenecen a distintas &quot;clases&quot; y que constan tanto de un estado (variables internas) como de unas operaciones que cada objeto podría realizar. De los lenguajes enumerados todos menos C, Cobol y Fortran serían orientados a objetos aunque C++, Visual Basic, Perl, PHP, Python y Fortran no obligan al programador a abstraer toda la lógica del programa en clases y objetos permitiéndole implementar las partes que desee de la misma con una aproximación estructural (permiten la existencia de &quot;funciones libres&quot; no englobadas en ninguna clase ni objeto.) 
</p><p>

Finalmente cada uno de esos lenguajes tiene una sintaxis particular entendiendo como sintaxis la forma de escribir en el código fuente las abstracciones (funciones, variables y clases). Por ejemplo la representación de una clase &quot;Numero&quot; que al construirse aceptase un número y que tuviera un método para sumar otros números a su valor, podría ser en Python: 

</p><p>

</p><pre>class Numero:
    def __init__(numero):
        self.valor = numero
    def sumar(cuanto):
        self.valor += cuanto
</pre>

<p>

Mientras que en Java podría ser (simplificando):
</p><p>
</p><pre>class Numero {
    int valor;
    numero(int numero) {
        valor = numero;
    }
    
    void sumar(int cuanto) {

        valor += cuanto;
    }
}
</pre>

<p>
Como vemos ambos fragmentos de código son parecidos pero no iguales; en Java se pone un punto y coma al final de cada instrucción y los conjuntos se agrupan con llaves. Además en Java es necesario declarar las variables mientras que en Python la declaración es automática con la asignación (una muestra del dinamismo típico de los lenguajes compilados.) Finalmente el constructor, que será la función que se llame automáticamente cuando se cree un objeto de la clase Numero en Python se llama __this__ mientras que en Java toma el mismo nombre que la clase. 
</p><p>

Es raro que un lenguaje nuevo invente una sintaxis completamente nueva pues ello haría que los programadores de otros lenguajes existentes no pudieran aprovechar su experiencia, por ello habitualmente cuando se crea un lenguaje nuevo este suele partir de una sintaxis conocida o familiar que le añade modificaciones. Uno de los &quot;estilos&quot; de sintaxis más populares es la llamada &quot;sintaxis tipo C&quot;. C ha sido durante más de 30 años uno de los lenguajes de programación principales de la industria por lo que casi a casi cualquier programador su sintaxis le resulta muy familiar. Es por esto por lo que muchos lenguajes la toman como punto de partida. En el caso de los lenguajes que se están comentando los que usan la sintaxis de tipo C son C (obviamente), C++, Java y C#, es decir, los lenguajes compilados más populares (tanto a código nativo como a código no-nativo.) D también tiene una sintaxis tipo C. 

</p><p>
!-->
</p><h2>¿Qué tipo de lenguaje es D?</h2>
La clasificación del lenguaje de programación D sería: lenguaje compilado a código nativo (con compilación opcional a .NET como C#), orientado a objetos pero permitiendo programar con funciones libres y clases ligeras (structs), con plantillas y mixins (que permiten la programación genérica) y con posibilidad de acceso a bajo nivel.
<p>
</p><h2>¿Qué diferencias tiene con respecto a C++?</h2>

Esta clasificación parece exactamente la misma que la de C++ y no es casual, pues C++ es el lenguaje al que D aspira a sustituir. D es un lenguaje evolucionario, no revolucionario y en un principio puede parecer que no aporta demasiado sobre C++. Pero no son las características generales sino los detalles de las mismas los que marcan la diferencia. En primer lugar D conserva todas las características de expresividad de C++ (cosa que ni C# ni mucho menos Java consiguen en su afán por hacerse lenguajes más accesibles), pero con una sintaxis y unas construcciones mucho más sencillas y lógicas. Además, otro de los puntos fuertes de C++, su rendimiento, también se ve reflejado en D (en algunas ocasiones incluso superado.) 
<p>

Por otro lado D cuenta con muchas otra características de las que C++ no dispone, de las cuales vamos a hacer un pequeño repaso a continuación. Quisiera recordar al lector que, al contrario de lo que pasa con Java o C#, estas características no suponen una perdida apreciable de rendimiento para D en comparación con C++: 
</p><p>
</p>
<h2>Gestión automática de memoria (recolección de basura)</h2>

En C++ cuando creamos objetos que queremos que transciendan el ámbito de la función, método o bloque de código que los ha creado los creamos con utilizando el operador &quot;new&quot;. Este operador se encargará de asignar automáticamente la memoria que sea necesaria para el objeto y llamará a su constructor, devolviéndonos una referencia al objeto ya inicializado que podremos almacenar en una variable del tipo del objeto. 

<p>

Cuando ya no vamos a necesitar el objeto procedemos a borrarlo con el operador &quot;delete&quot; lo que liberará la memoria asignada por el objeto. Â¿Parece sencillo verdad? Bien, debería serlo, pero en la práctica es raro el programa en C++ que no tiene o ha tenido una fuga de memoria porque el flujo de ejecución de una parte del mismo termina antes de llegar al delete (y por lo tanto la memoria queda asignada para siempre sin posibilidad de recuperarla) o que ha fallado porque erróneamente se ha hecho un delete del mismo objeto dos veces o se ha intentado acceder (también erróneamente) a un miembro de un objeto previamente borrado. Obviamente estos errores son evitables pero errar es humano y cuantas más tareas delegue en el programador el lenguaje de programación más posibilidad hay de que haya errores (si no fuera así, todos seguiríamos haciendo ensamblador.) </p><p>
</p><p>
La gestión automática de memoria quiere decir que el programador seguirá creando los nuevos objetos con &quot;new&quot; pero ya no tendrá que preocuparse de borrarlos con &quot;delete&quot; porque existirá un &quot;recolector de basura&quot; que se encargará de eliminar automáticamente los objetos para los que ya no exista ninguna referencia. Es decir, si tenemos la siguiente función: 

</p><p>
</p><pre>void pierdeaceite() {
    Obj *o = new Obj();
}
</pre>
<p>
En C++ esto produciría una fuga de memoria cada vez que la llamáramos porque al terminar la función ya no habría ninguna referencia a &quot;o&quot; (y por lo tanto no podríamos usarlo) y sin embargo al no haber hecho delete seguiría existiendo en la memoria. El código equivalente en D: 
</p><p>
</p><pre>void nopierdeaceite() {
    Obj o = new Obj();
}
</pre>
<p>

No produciría ninguna perdida de memoria porque el recolector de basura detectaría que como &quot;o&quot; fue declarado dentro de &quot;nopierdeaceite&quot; y su alcance termina al terminar la función, la memoria puede ser liberada. 

</p><p>

Esta característica (con la que cuentan también C# y Java) puede desactivarse si por cuestiones de rendimiento o de cualquier otro tipo no queremos que se ejecute el recolector de basura llamando a gc.disable() y luego reactivarse llamando a gc.enable(). Lo más espectacular es que mientras el recolector de basura sigue desactivado las referencias a los objetos que hagamos con &quot;new&quot; se seguirán contabilizando por lo que una vez que re-activemos la recolección de basura esos objetos serán igualmente gestionados (no necesitaremos llamar a delete sobre los mismos.) Esto no es así en C# ni en Java,por ejemplo. 

</p><p>

Finalmente también podemos borrar, como en C++, nosotros mismos los objetos llamando a &quot;delete&quot; sin que ello cause ningún tipo de conflicto con el recolector de basura. 

</p><p>
<h2>Gestión de errores mediante manejo de excepciones</h2>

C++ permite gestionar los errores mediante el mecanismo de manejo de excepciones, aunque por herencia de C en demasiadas ocasiones se sigue utilizando el sistema de "valores mágicos devueltos por la función". </p><p>

En D el sistema de manejo de excepciones es superior al de C++ al incorporar algunas características de lenguajes más recientes. Cuando una excepción producida en código D no se captura, se muestra un mensaje de error con información de la excepción. La sintáxis es parecida a la de otros lenguajes con manejo de excepciones:
</p><p>
<pre>
try {

  throw new Exception("mensaje de error");
} 
catch(Exception e) { 
  printf("capturada la excepción, mensaje: %.*s\n", e.msg);
} finally {
  printf("este mensaje se mostrará siempre");
}
</pre>
</p><p>

El código que se ejecuta dentro del Try en caso de lanzar una excepción se ejecutará el código que esté en el bloque del "catch" si la excepción especificada entre paréntesis coincide con la lanzada o es padre de la misma en la jerarquía de la excepción (las excepciones son clases con su propia jerarquía.) El padre de la jerarquía es la clase "Exception" así que en ejemplo el catch capturaría cualquier excepción. En el caso del constructor de la excepción en la instrucción que lo lanza (el "throw") hemos especificado una cadena como parámetro pues en la clase Exception el argumento del constructor es un mensaje que queda almacenado en el miembro "msg", que generalmente se va a usar para amplíar la información del error, y ese miembro es el que imprimimos precisamente en el printf del catch.
</p><p>

El bloque con la instrucción "finally" se ejecutará siempre, se produzca una excepción o no y en caso de que se produzca incluso aunque se capture en un catch. Por lo tanto la salida de este programa sería:
</p><p>
<pre>
capturada la excepción, mensaje: mensaje de error
este mensaje se mostrará siempre
</pre>
<h2>Guardas de ámbito para asegurar la ejecución de código a la salida de un ámbito</h2>

Aunque D tenga recolección automática de memoria hay otro tipo de recursos que se siguen teniendo que liberar manualmente. Ejemplos de estos recursos son los ficheros, los cerrojos y mutex; pero hay otros. Normalmente un código como éste (robado de la página de D)</p><p>
<pre>
    void mifuncion() {
        Mutex cerrojo = new Mutex();
        lock(cerrojo); //Adquirimos
        funcionpeligrosa(); // Puede lanzar excepciones
        unlock(cerrojo); // Liberamos
    }
    </pre>
    
En este ejemplo puede verse fácilmente el problema: si "funcionpeligrosa" lanza una excepción, no se llama al "unlock(cerrojo)" y por lo tanto el mutex queda bloqueado "para siempre". Una posible solución es usar una construcción de tipo try... finally y poner el unlock dentro del finally, relanzando de nuevo la excepción recibida, pero D nos ofrece una solución más escueta y elegante llamada "Scope Guards" ("Guardas de Ámbito".) Los scope guards se implementan llamando a la palabra clave <code>scope</code> poniendo entre paréntesis el ámbito y después una linea o más (con llaves en el segundo caso.) Lo que hace es sencillo: cuando se llegue alcance el ámbito especificado, se ejecutará el código que hubiéramos asociado con el scope. Lo veremos más fácilmente con el ejemplo:</p><p>
<pre>
    void mifuncion() {
        Mutex cerrojo = new Mutex();
        lock(cerrojo);
        scope(exit) unlock(cerrojo); 
        funcionpeligrosa();
    }
    </pre>
        
Con este código estamos indicando que cuando <strong>salgamos</strong> ("exit") del ámbito ("scope") actual, se ejecutará unlock(). Usando exit garantizamos que el unlock se ejecutará en cualquier caso al salir, sea esta salida de forma normal o por una excepción (sin interrumpir el flujo de esta, por lo que no hace falta relanzarla.) Existen varios especificadores de ámbito para scope, que son:</p><p>
<ul>
<li><b>sucess</b>: Se ejecutará cuando se salga con éxito (sin excepción.)
    </li><li><b>failure</b>: Se ejecutará cuando se salga con error (con una excepción.)
    </li><li><b>exit</b>: Se ejecutará cuando se salga del ámbito en cualquier caso (éxito o error.)
    </li></ul>
    
Realmente, usando las guardas de ámbito, la instrucción <code>finally</code> nunca es necesaria aunque se sigue manteniendo en el lenguaje. Por comparación, la "antigua" forma de hacer esto sería:
    <pre>
    void mifuncion() {
        try {
            Mutex cerrojo = new Mutex();
            lock(cerrojo);
            funcionpeligrosa();
        } finally {
            unlock(cerrojo);
            throw(o);
        }
    </pre>
    
Las guardas de inclusión no sustituyen a la instrucción except; para capturar excepciones y realizar operaciones en la captura debemos seguir usándola.</p><p>
             
Para los Pythoneros, la guarda de ámbito de éxito (sucess) sería equivalente a el "else" de las excepciones en Python.</p><p>
<h2>Estructuración del código en módulos y paquetes</h2>

En C/C++ la estructuración del código se hace creando "ficheros de cabecera" con extensión .h o .hpp que contienen las declaraciones de los símbolos que cada subparte explorta, y luego esos ficheros de cabecera se importan usando la directiva del preprocesador #include. Esta importación lo único que hace es incluir el código del .h importado allí donde se encuentra la directiva import. Esto lleva a problemas cuando varios ficheros de cabecera definen un mismo símbolo, con soluciones poco elegantes.

C++ añade además el concepto de namespaces que permite agrupar los símbolos de distintos ficheros en un único espacio de nombres lógico.</p><p>

En D, como en casi todos los lenguajes modernos, la estructuración del código y las bibliotecas se hace usando módulos y paquetes. Un módulo no es más que un fichero fuente de código D (generalmente con extensión .d).</p><p>
<h3>Importar símbolos de un módulo con import</h3>

Para que un módulo pueda acceder a los símbolos de otro módulo se usa la sentencia <i>import</i>:
</p><p>
<pre>

---- inicio modulo1.d ----
module modulo1;

int simbolomodulo1 = 10;
---- fin modulo1.d ----

---- inicio modulo2.d ----
module modulo2;

import modulo1;

writefln( simbolomodulo1 ); // correcto
---- fin modulo2.d ----
</pre>
</p><p>

Como puede verse, al contrario de lo que sucede en otros lenguajes, cuando importamos los símbolos de un módulo no hace falta anteponer el nombre del módulo con un punto antes de llamar a un símbolo; en modulo2 podemos ver que hemos usado simbolomodulo1 en lugar de modulo1.simbolomodulo1 como se haría en otros lenguajes. A pesar de ello la notación de modulo.simbolo se permite también en D, y es necesaria útil cuando se importan dos módulos que definen símbolos homónimos para indicar el módulo del cual queremos usar el símbolo; no hacerlo así en ese caso es un error de compilación.

Además, también se puede ver que al principio de cada modulo se usa la palabra clave <i>module</i> seguida del nombre del módulo. Esta sentencia es opcional y para módulos no pertenecientes a paquetes no suele ser necesario pues por defecto se toma como nombre del módulo el nombre del fichero sin la extensión. Si existe, debe ser la primera sentencia (comentarios aparte) del fichero fuente.

<h3>static import</h3>

Si quieremos que los símbolos importados sean accedidos siempre mediante la notación modulo.símbolo usaremos un <i>static import</i>:
</p><p>
<pre>
---- inicio modulo2.d ---
static import modulo1;

// writefln( simbolomodulo1 ); // error
writefln( modulo1.simbolomodulo1 ); // correcto
</pre>
</p><p>
<h3>import public y private</h3>

Las palabras clave <i>public</i> y <i>private</i> antepuestas a un import significan:</p><p>
<dl>
<dt>public
  <dd>Los símbolos que se incluyen a través del import serán a su vez exportados a los módulos que importen el módulo donde está el import.
</dd></dt><dt>private
  <dd>Los símbolos que se incluyen a través del import no estarán accesibles en los módulos que importen a su vez el módulo donde está el import. Este es el comportamiento por defecto por lo que no es necesario escribir esta palabra clave.
</dd></dt></dl>
</p><p>

Ejemplo: </p><p>
<pre>
---- inicio modulo2.d ----
import modulo1; // private import por defecto

int simbolomodulo2 = 20;

writefln( simbolomodulo1 );
---- fin modulo2.d ----

---- inicio modulo3 ----
import modulo2;

writefln( simbolomodulo2 ); // correcto, simbolomodulo2 esta definido en modulo 2
writefln( simbolomodulo1 ); // error, simbolomodulo1 está definido en módulo1, 
                            // y como modulo3 no importa a modulo1 no puede 
                //acceder al módulo1 aunque modulo2 lo importe 
                            //y modulo3 importe modulo2
</pre>

Para que no diera error:

<pre>
---- inicio modulo2.d ----
public import modulo1; // ahora exportamos todos los símbolos de modulo1
                       // como si fueran de modulo2

int simbolomodulo2 = 20;

---- fin modulo2.d ----

---- inicio modulo3 ----
import modulo2;

// correcto, simbolomodulo2 esta definido en modulo 2:
writefln( simbolomodulo2 ); 
// correcto porque modulo1 esta importado públicamente en modulo2:
writefln( simbolomodulo1 ); 
</pre>
</p><p>
<h3>Renombrado de módulos</h3>

Los módulos pueden renombrarse cuando se importan usando el signo igual con el nuevo nombre a la izquierda y el nombre del módulo renombrado a la derecha: </p><p>
<pre>
import corto = mipaquete.directorio.nombreDeModuloMuyLargo
</pre>
</p><p>
<h3>import selectivo de símbolos</h3>

En lugar de importar todos los símbolos de un módulo, existe la posiblidad de importar sólo algunos símbolos específicos. Esto es útil cuando sólo vamos a usar uno o dos símbolos de un módulo concreto. La sintáxis para ello es poner el signo dos puntos con el nombre del módulo a la izquierda y la lista de símbolos que se importan del mismo a la derecha, separados por comas.
</p><p>
<pre>
// Sólo importamos writef y writefln de std.stdio
import std.stdio: writef, writefln
</pre>
</p><p>

También podemos importar símbolos selectivamente al tiempo que los renombramos:</p><p>
<pre>
// Sólo importamos writef y writefln renombrando el último a escribelinea
import std.stdio: writef, escribelinea = writefln
</pre>
</p><p>
<h3>Acceso a símbolos ocultados por símbolos locales</h3>

En ocasiones queremos poder acceder a un símbolo del propio módulo en el que está el código que lo usa, pero este puede haberse visto ocultado por un símbolo en el alcance local. En ese caso tan sólo tenemos que usar la notación "punto símbolo" (.símbolo) que seria equivalente a hacer nombredemodulo.símbolo desde otro módulo que importara el actual:</p><p>
<pre>
int simbolo;

void funcionconlocal(int simbolo) {
    writefln( simbolo ); // escribe el parámetro simbolo
    writefln( .simbolo ); // escribe el símbolo del módulo
</pre>
</p><p>
<h3>Paquetes</h3>

En ocasiones el código se necesita una estructuración que vaya más allá de los módulos. En ese caso se puede hacer una jerarquía de módulos bajo un concepto mayor llamado "paquete". Para declarar que un módulo está en un paquete debemos incluir la ruta que debe tener el módulo dentro de la jerarquía del paquete, separando los distintos niveles de la misma y el nombre del módulo (al final) mediante puntos. Generalmente la jerarquía de los paquetes suele corresponderse con una organización de directorios y subdirectorios equivalente, aunque esto no es estrictamente necesario.</p><p>
<pre>
---- fichero conexiones.d, que está en el directorio mibiblioteca/red
module mibiblioteca.red.conexiones

//etc
---- fichero  que está en el directorio mibiblioteca/red/servidores
module mibiblioteca.red.servidores.http

//etc
</pre>
</p><p>
<h3>Donde se buscan los módulos y paquetes</h3>

Cuando escribimos "<i>import nombremodulo</i>" el compilador primero buscará "nombremodulo.d" en el directorio actual. De no encontrarlo, si hemos proporcionado uno o más parámetros -Idirectorio al compilador "nombremodulo.d" se buscará en dichos directorios. Finalmente si tampoco se encuentra en ellos se buscará en el -Idirectorio que esté especificado en el fichero dmd.conf.

Cuando se trata de paquetes, si el paquete está organizado por directorios sólo es necesario especificar el nombre raíz donde se encuentra el paquete, no los subdirectorio. Por ejemplo si escribimos <i>import mibib.red.conexion</i> y el raíz del paquete mibib está en /usr/include/dmd/mibib (en el caso de un sistema Unix/Linux/Mac) basta con especificar como parámetro al compilador o en el dmd.conf -I/usr/include/dmd/mibib y el compilador buscará sólo el subdirectorio "red" y dentro del mismo el fichero "conexion.d".


<h2>Compatiblidad de llamada con C</h2>

Debido a la difusión del lenguaje, la mayoría de las APIs de sistemas operativos y librerías de sistemas están escritas en C u ofrecen una interfaz para el mismo. D puede acceder a bibliotecas de C. Para ello, además de enlazar con el fichero binario de la biblioteca mediante parámetros al compilador, debemos incluir en nuestro código D una declaración de los símbolos y funciones de C a los que queramos acceder. Como los tipos de datos de D suelen tener una correspondencia muy directa con los de C este proceso suele ser bastante sencillo; sin embargo para conversiones de ficheros de cabecera .h más complicados se dispone de la herramienta <b>htod</b> que realiza la conversión de tipos y sintáxis de forma automática, tomando como entrada un fichero .h de C y generando un fichero .d que podemos incluir en nuestros proyectos.</p><p>


Para las declaraciones de símbolos y funciones de C, debemos poner la instrucción "extern(C):". Tomando un ejemplo de la descripción del htod, si en un fichero de cabecera .h tuviéramos el siguiente código C:</p><p>
<pre>
unsigned u;
#define MYINT int
void bar(int x, long y, long long z);
</pre>
</p><p>

La conversión del mismo en D sería:</p><p>
<pre>
extern(C):
uint u;
alias int MYINT;
void bar(int x, int y, long z);
</pre>
</p><p>

Es importante destacar que dentro de un fichero fuente D no podemos incluir código C (al contrario de lo que sucede en C++.)</p><p>

En la versión actúal de D no existe la posibilidad de enlazar contra bibliotecas C++.

</p><h2>Delegados, funciones anidadas y funciones literales</h2>

En D existe un tipo de dato llamado &quot;delegado&quot; que puede usarse para pasar referencias a un método de una clase como parámetros para otras funciones y métodos. Son, en concepto, similares a los punteros a método de C++ pero con una sintaxis tanto de declaración como de creación y uso mucho más sencilla: 
<p>
</p><pre>class Foo {
    [...]
    bool esPar(int N) { return (n % 2 == 0); }
    bool esImpar(int N) { return !(n % 2 == 0); }
    [...]
}

bool validadora( bool delegate(int) dlg, int valor ) {
    return dlg(valor);
}

void main() {
    Foo f = new Foo();
    bool delegate(int) dlgespar;
    bool delegate(int) dlgesimpar;
    
    dlgespar   = f.esPar;
    dlgesimpar = f.esImpar
    
    bool unoespar   = validadora(dlgespar,   1);
    bool unoesimpar = validadora(dlgesimpar, 1);
</pre>
<p>

Como puede verse en el ejemplo anterior la declaración de una variable que apunte a un delegado es similar a la de una función pero poniendo &quot;delegate&quot; en lugar del nombre y el nombre de la variable apuntadora al final. 

</p><p>

Hablando de funciones y métodos, D permite tener funciones anidadas y funciones anónimas. Las primeras son funciones que están definidas dentro de otra función. Son muy útiles para estructurar nuestro código de una forma más jerárquica. 

</p><p>

Las funciones anónimas son funciones (normalmente sencillas) sin nombre que suelen utilizarse como argumento para una función que espera recibir una función como argumento. 

</p><p>
<h2>Declaración anticipada de funciones innecesaria</h2>

En C y C++ para que una función pueda llamar a otra esta debe haber sido declarada con anterioridad a la misma. Para ello puede estar el cuerpo completo de la función, o sólo un "prototipo" que indica los tipos aceptados y el valor devuelto, por ejemplo esto no funcionaría:
</p><p>
<pre>
void llamaotra(int prueba) {
    funcionprimera( prueba ); // error, funcionprimera no está definida
}

void funcionprimera(int param) { return param; }
</pre>

Por lo que tendríamos que declarar funcionprimera antes de implementarla, o directamente implementar "más arriba" de llamaotra.

El compilador de D es algo más inteligente y hace que esto sea innecesario; cualquier función puede llamar a cualquier otra que esté definida en el programa, independiéntemente de su posición en el código.

<h2>Compilación condicional y versionado sin necesidad de un preprocesador</h2>

En C++, como en C, se utiliza un <a href="http://gcc.gnu.org/onlinedocs/cpp/">preprocesador</a> que analiza el código realizando modificaciones e inclusiones sobre el mismo antes de que se inicie la compilación. El preprocesador de C/C++ es antiguo, y además algunos programadores parecen disfrutar escribiendo código enrevesado usando las instrucciones que el mismo proporciona, lo cual lleva a código bastante ilegible y dificil de seguir y depurar.
</p><p>

D elimina completamente el preprocesador y en lugar de esos añade una serie de directivas para el compilador pero incluidas en el lenguaje que nos permiten darle indicaciones sobre que código compilar según unos parámetros determinables en tiempo de compilación.
</p><p>

Estas directivas son:</p><p>
<h3>module</h3>
Con esta intrucción indicamos el uso desde nuestro programa de otros módulos en C (ver más adelante el apartado sobre módulos y paquetes para ver una descripción más completa) y por lo tanto sustituiría al #include de C/C++. Al contrario de lo que sucede con el #include no hay ningún problema en que varios módulos incluyan a un mismo símbolo a través de importaciones, por lo que el chapucero código siguiente, tan necesario en C/C++ para proyectos complicados que involucran muchas inclusiones, es innecesario en D:
</p><p>
<pre>
#ifndef _TENEMOS_MODULO_

//código del módulo

#define _TENEMOS_MODULO_

#endif
//Nada
</pre>
</p><p>
<h3>version</h3>
Otro uso muy común del preprocesador de C/C++ es la supresión o no de determinados bloques de código según parámetros pasados al compilador o incluidos en el entorno del mismo. Por ejemplo en C/C++ cuando queremos que un código se compile en Windows o Linux hacemos:
</p><p>
<pre>
#ifdef linux
printf("estoy en linux!");

#ifdef windows
printf("estoy en windows!");

</pre>

En este caso la definición "linux" o "windows" lo proporciona el compilador, pero igualmente se pueden suminitrar al mismo definiciones adicionales usando la linea de comandos del mismo.</p><p>

En D para hacer esto mismo, pero con más elegancia, se usa la instrucción <i>version</i>:</p><p>
<pre>
version(linux){
  printf("Estoy en linux!");
}

version(windows){
  printf("Estoy en windows!");
}
</pre>
</p><p>
Podemos definir los símbolos comprobables mediante la intrucción version usando parámetros al compilador (-version=shareware) o podemos generar nuevos símbolos dentro del código, siempre usando bloques evaluables en tiempo de compilación, como el incluido dentro de otro bloque version, usando asignaciones:
</p><p>
<pre>
version(shareware) {
  version = puedeleer; 
}

version(comercial) {
  version = puedeleer;
  version = puedeescribir;
  version = puedeimprimir;
}


version(puedeleer) {
  //Implementación de la funcionalidad de lectura
}

version(puedeescribir) {
  //Impplementación de la funcionalidad de escritura
}

version(puedeimprimir) {
  //Implementacion de la funcionalidad de impresión
}
</pre>
</p><p>En el ejemplo anterior, al compilar especificaremos como parámetro al compilador "version=shareware" o "version=comercial" según la versión del programa que queramos que se genere.

<h3>debug</h3>
La instrucción <i>debug</i> es muy similar a <i>version</i> pero en lugar de usarse para especificar características del entorno o funcionalidades se usa para incluir dentro del bloque código de depuración que nos ayude a detectar y corregir errores en versiones en desarrollo. Sustituye a otro uso tradicional del preprocesador en C/C++:

</p><p>
<pre>
#define DEBUG

//codigo normal

#ifdef DEBUG
//codigo de depuracion
#endif
</pre>
</p><p>

En D el código equivalente sería:
</p><p>
<pre>
debug = si

//código normal
debug(si) {
  //código de depuración
}
</pre>
</p><p>

La intrucción debug además de aceptar como parámetro un posible identificador, acepta valores enteros. En ese caso se compilarán todos los bloques debug cuyo parámetro sea igual o menor al valor entero. Por ejemplo:
</p><p>
<pre>
debug = 2

// código normal

debug(1) {
  // código de depuración de nivel 1
}

debug(2) {
  // código de depuración de nivel 2
}

debug(3) {
  // código de depuración de nivel 3
}
</pre>
</p><p>

En el ejemplo anterior, como debug vale 2, se ejecutarán los dos primeros bloques de depuración (los que tienen como parámetro 1 y 2), pero no se ejecutará el tercero. Esto es útil para incrementar escalar la salida de diagnóstico de nuestro programa en varios niveles, siendo las mayores las que más salida mostrarán.
</p><p>
<h3>static if</h3>

El static if se usa para comprobar el valor de símbolos evaluables en tiempo de compilación, como constantes o alias. Es similar a version, pero permite una mayor flexibilidad al poder usarse en instanciaciones de templates.
</p><p>
<pre>
const int bitsint = 16;

static if (bitsint == 16) 
  alias short INT;

else static if (bitsint == 32)
  alias int INT;
</pre>
</p><p>
<h3>static assert</h3>

El static assert funciona igual que el assert pero comprobado sólo valores evaluables en tiempo de compilación. En caso de que la condición evalue a un valor falso, el programa no se compilará.
</p><p>
</p><h2>Arrays mucho más manejables y foreach</h2>

Los arrays (o matrices, o vectores, como se quieran traducir) en C++ son exactamente los mismos que en C, es decir, un poco de azúcar sintáctico para un puntero a una memoria asignada. El azúcar sintáctico sin embargo no es mucho, y para realizar algunas operaciones básicas (como añadir o quitar elementos a un array o cambiar su tamaño) debemos hacer engorrosas llamadas para asignar e inicializar nueva memoria. La cosa empeora si pensamos que además las &quot;cadenas&quot; en C están implementadas como un array de caracteres sin ninguna propiedad especial. 
<p>

C++ soluciona parte de estas limitaciones a través de su librería estándar de plantillas (STL) que proporciona plantillas de clase genéricas para diversas estructuras de datos con múltiples operaciones, además varias clases avanzadas para cadenas. 

</p><p>

En D, además de existir una biblioteca de plantillas de clase avanzadas (la DTL, actualmente en desarrollo) los arrays cuentan con una serie de características que los hacen mucho más prácticos y manejables que los de C/C++: 

</p><p>
</p><ul>
<li>Cuentan con comprobación de límites. 

</li><li>Pueden redimensionarse dinámicamente cambiando su propiedad &quot;length&quot; o añadiendo al final con el operador &quot;~=&quot;. 

</li><li>Pueden concatenarse fácilmente dos o más arrays en uno sólo con el operador &quot;~&quot;. 

</li><li>Permiten la especificación de subrangos dentro de un array. Por ejemplo si quisiéramos los elementos 3, 4 y 5 de un array en un subarray podríamos hacer: subarray = miarray[3..5]. Esto además permite copiar de forma sencilla los arrays por valor con la siguiente notación: int array2[] = array1[]; Los rangos también permiten asignaciones automáticas a varios elementos de un array simultaneamente: array[2..6] = 0; 

</li><li>Además de la propiedad length, ya comentada, cuentan con otras propiedades útiles (como size para el tamaño, dup para crear un duplicado, reverse para invertir el orden de los elementos y sort para ordenarlos.) 

</li><li> Los arrays estáticos (en los que en la declaración indicamos el tamaño de cada dimensión como en <code>int[3][4] matriz;</code> se implementan como las matrices de fortran en lugar de como punteros a punteros; esto hace que sean mucho más eficientes a la hora de calcularlos. Los arrays dinámicos (<code>int[][] matriz;</code>) sin embargo sí que se implementan como en C, como punteros a punteros. Por lo tanto si necesitamos hacer cálculos de matrices extremadamente rápidos es aconsejable usar los arrays estáticos.

</li></ul>
<p>

En general todas estas características hacen que los arrays en D se manejen de la forma más intuitiva y no haya que estar recordando constantemente que su implementación es poco más que un puntero con longitud (que lo es.) 

</p><h3>Cadenas</h3>

Una consecuencia directa de estos arrays mejorados es que las cadenas nativas, a pesar de seguir siendo arrays de caracteres, son ahora infinítamente más manejables. Lo único que tenemos que tener en consideración es que los literales de cadena (caracteres entre comillas) son arrays inmutables, esto es, que no pueden ser modificadas y como D no deja asignar entre objetos mutables e inmutables sin hacer conversiones, no podemos asignar los literales de cadena a arrays de char si no los declaramos mutables. Esto que suena tan lioso lo vamos a ver enseguida con un par de ejemplos:
    
    <pre>
    char[] cadenaMutable; // Cadena es un array de caracteres mutable;
    char[] otraCadenaMutable;
    cadenaMutable = "hoygan!"; // ERROR: "hoygan!" como literal de cadena es inmutable y no podemos asignarlo a un mutable
    otraCadenaMutable = "hoygan!".dup // Correcto, dup crea una copia mutable del literal
    </pre>
    
Para asignar literales de cadena sin llamar a .dup podríamos declarar a los arrays de caracteres como invariantes:<p>
<pre>
    invariant(char)[] cadenaInmutable = "hoygan!"; // Correcto, asignamos un inmutable a otro
    invariant(char)[] otraCadenaInmutable = cadenaMutable; // ERROR, asignando mutable a inmutable
    invariant(char)[] ultimaCadenaInmutable = cadenaMutable.idup; // Correcto, idup crea una copia inmutable
    </pre>
    
Como esta síntaxis es un poco fea para manejar cadenas y D es un lenguaje orientado principalmente a la practicidad, se ha creado un alias a <code>invariant(char)[]</code> llamado <b>string</b>, de modo que el ejemplo anterior quedaría como:</p><p>
<pre>
    string cadenaInmutable = "hoygan!"; // Correcto, asignamos un inmutable a otro
    string otraCadenaInmutable = cadenaMutable; // ERROR, asignando mutable a inmutable
    string ultimaCadenaInmutable = cadenaMutable.idup; // Correcto, idup crea una copia inmutable
    </pre>
    
Como he comentado al principio de este punto, las cadenas al no ser más que arrays de char en D pueden tienen las mismas operaciones que éstos (y el mismo rendimiento), por lo tanto podemos olvidarnos del infierno de las cadenas en C:</p><p>
<pre>
    // Asignación    
    cadena1 = cadena2;
    
    // Copia
    string cadena1 = cadena2.dup; // 
    
    
    // Copia de subcadenas
    string cadena1 = "Hoygan amijos!";
    string cadena2 = cadena1[0..5]; // cadena2 = "Hoygan"
    
    // Concatenación
    string cadena3 = cadena1 ~ cadena2;
    
    
    // Añadir al final
    string cadena4 = "Hoygan! ";
    cadena4 ~= "amijos!";
     
     // Comparación
     if (cadena1 &gt; cadena2) ...
     </pre>
     
Casi casi igual que en el infierno de punteros y news de C o la verborrea infame de Java o las STL ¿verdad?        
    

</p><p>
</p><h3>Arrays asociativos</h3>

D también cuenta con un tipo de dato derivado del array llamado array asociativo que consiste en una estructura de datos (nativa) que asocia una clave con un valor, de forma que después conociendo la clave podamos recuperar el valor. Tanto la clave como el valor pueden ser de cualquier tipo y la forma general de declarar un array asociativo es muy sencilla:
<p>
</p><pre>tipoValor[tipoClave];</pre>
<p>

Por ejemplo para declarar un array asociativo en el que las claves fueran enteros y los valores objetos de tipo &quot;MiClase&quot;: </p><p>
</p><pre>MiClave[int];</pre>
<p>

O uno con claves de tipo entero y valores de tipo cadena:</p><p>
</p><pre>int[ string ];</pre>
<p>

Quien tenga algo de experiencia programando seguramente reconocerá la utilidad de este tipo de estructuras de datos, probablemente una de las más utilizadas en programación (con permiso de las listas/vectores), por ello casi todos los lenguajes de programación ofrecen al programador la posibilidad de usar este tipo. Java, C# y C++ no son una excepción, pero a diferencia de D en estos lenguajes el tipo de array asociativo (y sus variantes) están implementados como clases en la biblioteca estándar por lo que por un lado el rendimiento nunca va a ser el mismo que el de un tipo nativo (optimizable hasta la muerte por el compilador, que sabe manejarlo mejor que una clase) ni por otro lado será igual de cómodo, aunque esto sea menos importante (en el caso de estos lenguajes tendremos que declarar un objeto, construirlo con new y después utilizar métodos para acceder a sus elementos. C++ usando sobrecarga de operadores permitirá usar las instancias con notación de array, pero la declaración y construcción deberán seguir realizándose como objetos de clase; objetos de clase de plantilla, para ser exactos.)

</p><p>

Los arrays asociativos de D además de algunas de las propiedades de los arrays normales, cuentan con algunas adicionales:</p><p>
<ul>
<li>Podemos llamar a su miembro <code>remove(clave)</code> para eliminar una clave del array.
    </li><li>Podemos usar el operador <code>in</code> para comprobar si una clave está en un array (<code>if("polompos" in miArray)...</code>)
    </li><li>La propiedad .keys devolverá un array normal que contendrá todas las claves.
    </li><li>La propiedad .values devolverá un array normal que contendrá todos los valores.
</li></ul>


Aparte de estos tipos nativos (arrays y arrays asociativos) D también contará con una librería de estructuras de datos genéricas que proporcionará estructuras de datos más avanzadas llamada la &quot;D template library&quot; en intenso desarrollo en el momento de escribir este artículo.</p><p>
</p><h3>foreach y foreach_reverse</h3>
Una de las operaciones más comunes con arrays es recorrerlos mediante un bucle for como en el siguiente ejemplo: <p>
</p><pre>for (int i = 0;i &lt; 10; ++i) {
    printf(&quot;Array[%d]: %d&quot;, i, miarray[i]);
}
</pre>
<p>
D añade una palabra clave (heredada de otros lenguajes) que nos permite recorrer los arrays u otros contenedores obteniendo en cada iteración el siguiente elemento en lugar de un índice que luego tendríamos que usar para direccionar cada elemento dentro del bucle. Esto elimina, en la mayor parte de los casos, la necesidad de tener que usar incómodos iteradores, compárese por ejemplo: </p><p>
</p>
<pre>TipoContenedor::iterator sl;
for( sl = instanciaCont-&gt;begin(); sl != instanciaCont-&gt;end(); ++sl)
{
    (*sl)-&gt;imprimirValor();
}
</pre>
o... <p>
<pre>
TipoContenedorIterator it(*instaciaCont);
TipoDato *p;
while( (p = it.current()) != 0)
{
    ++it;
    p-&gt;imprimirValor();
}
</pre>
Con la construcción equivalente en D usando foreach: </p><p>
<pre>
foreach(TipoDato t; instanciaCont) 
{
    t.imprimirValor();
}
</pre>
</p><p>

En D, por supuesto, también pueden usarse iteradores para formas menos comunes de recorrer los bucles permitiendo toda la potencia de los iteradores &quot;tradicionales&quot; pero rara vez son necesarios porque habitualmente las propias implementaciones de los contenedores permiten recorrerlos de distintas formas: 
</p><p>
</p>
<pre>// Recorrer invertido:
foreach(TipoDato t; instanciaCont.reverse())
{
    t.imprimirValor();
}

// Recorrer invertido los valores dobles y pares:
foreach(TipoDato t; instanciacont.filter(pares).transform(doblar).reverse())
{
    t.imprimirValor();
}
</pre>
<p>
En el último ejemplo hemos utilizado dos métodos de las instancias de el tipo de dato que estábamos utilizando que aceptan un argumento función o delegado (método) para realizar, en el primer caso una selección de los elementos pares únicamente y el segundo dobla los elementos que queden después de la primera transformación. Como puede verse esto no hace nada que no pueda hacerse con iteradores, pero la sintaxis es mucho más clara y concisa (de nuevo, si realmente necesitamos de iteradores también dispondremos de ellos en D.) </p><p>

Los métodos mostrados en los últimos ejemplos están implementados en las estructuras de datos de la librería DTL que probablemente formará parte en el futuro, como librería de estructuras de datos, de la librería estándar de D.</p><p>

También contamos con foreach_reverse que recorre un contenedor del final al inicio por lo que la llamada a reverse() del ejemplo anterior no sería realmente necesaria si usáramemos foreach_reverse en lugar de foreach.

<h2>RTTI (identificación de tipos en tiempo de ejecución)</h2>

De cuenta con un sencillo mecanismo de RTTI; los objetos disponen de una propiedad "classinfo" la cual contiene algunas propiedades de la clase que se pueden ver completamente en el código del fichero object.d (en general es aconsejable ver ese fichero fuente para ver las capacidades por defecto del objeto raíz de D.) Estas propiedades son:</p><p>
<ul>
<li>init: Inicializador estático de clase.
</li><li>name: Nombre de la clase
</li><li>vtbl: Array de punteros a las funciones virtuales
</li><li>base: Objeto classinfo de la clase padre
</li><li>destructor: Puntero al destructor
</li><li>deallocator: Punto al desasignador de memoria.
</li><li>defaultContructor: Puntero al constructor por defecto
</li><li>find (método): ¿Para buscar en la jerarquía de la clase?
</li></ul>
</p><p>

La versión actual de D no soporta reflexión dentro del lenguaje, aunque algunas librerías de terceros lo están implementando fuera del mismo, por ejemplo <a href="http://flectioned.kuehne.cn/">Flectioned</a>.</p><p>
</p><p>
<h2>Posibilidad de ejecución de código como si fuera un lenguaje interpretado</h2>

Los lenguajes interpretados cuentan con la ventaja de que es muy fácil escribir unas líneas de código en un editor y ejecutar el intérprete sobre el mismo, o inclúir en los sistemas Unix/Linux/Mac como primeras líneas el nombre del intérprete para permitir su ejecución como si de un ejecutable se tratase.</p><p>

Esta segunda posibilidad está incorporada en D mediante el parámetro al compilador "-run" que compila, enlaza y ejecuta el código que se le pase, sin generar ningún ejecutable en el disco. Ello nos permite crear scripts rápidos que se ejecuten como si de un lenguaje interpretado se tratase simplemente teniendo como primeras líneas:</p><p>
<pre>
#!/usr/bin/dmd -run
[Resto de código D]
</pre>
</p><p>

El compilador de D de Digital Mars es además sorprendentemente rápido, por lo que incluso ejecutándose de esta forma el resultado en ocasiones puede ser más rápido que usando un lenguaje de script real (como Python o Perl.)
</p><p>
<h2> Propiedades </h2>

Con este tema voy a expandirme un poco más de que sería necesario para explicar las propiedades en D, en mi intento de intentar educar a algunos programadores recalcitrantes.</p><p>

Muchos programadores inteligentes estarán hasta las narices de leer y escribir "getters" y "setters", que son miembros de clases cuya utilidad es "obtener" (get) o "establecer" (set) el valor de un miembro de una clase. De esto se abusa terriblemente, sobre todo programadores provenientes de los mundos Java y C++, dándose en la realidad casos absurdos como:</p><p>
<pre>
    // C++, para no mancillar el D con este ejemplo:
    // Persona.h:
    
    class Persona {
        public:
            void Persona(string nombre, string apellidos);
        
            string getNombre();
            void setNombre(string nombre);
        
            string getApellidos();
            void setApellido(string apellidos);
        private:
            string m_nombre;
            string m_apellidos;
    }
    
    // Persona.cpp:
    
    void Persona::Persona(string nombre, string apellidos) {
        m_nombre = nombre;
        m_apellidos = apellidos;
    }
    
    string getNombre() {
        return m_nombre;
    }
    
    void setNombre(string nombre) {
        m_nombre = nombre;
    }
    
    string getApellidos() {
        return m_apellidos;
    }
    
    string setApellidos(string apellidos) {
        m_apellidos = apellidos;
    }
    
    // main:
    Persona* juan = new Persona("Juan", "Alvarez Martinez");
    juan->setName("Juanjo");
    juan->setApellidos("Alvarez Martinez");
    cout << "Nombre de la persona: " << juan->getName();
    cout << "Apellidos: " << juan->getApellidos();
</pre>

En realidad, si sabemos que nunca vamos a realizar operaciones sobre el nombre o los apellidos antes de asignarlos y, sobre todo, antes de devolverlos ¿porque escribimos un par de métodos para usar esos miembros? Si lo pensamos bien, en la mayoría de las clases que hemos escrito o visto de esta forma, el 95% de los getters/setters que en origen tienen esta forma jamás harán ninguna operación aparte de asignar el valor o devolverlo directamente. Es decir, esta clase podría haberse escrito directamente así:
    
    <pre>
    // En D, al ser un ejemplo más digno, además así no hay que escribir dos ficheros:
    
    class Persona {
        public:
            this(string nombrearg, string apellidosarg) {
                nombre = nombrearg;
                apellidos = apellidosarg;
            }
            
            string nombre;
            string apellidos;
    }
    
    // Usaremos esto como:
    Persona juan = new Persona("Juan", "Alvarez Martinez");
    juan.nombre = "Juanjo";
    juan.apellidos = "Alvarez Martinez Torres Jimenez";
    writefln("Nombre: ", juan.nombre);
    writefln("Apellidos: ", juan.apellidos);
    </pre>

Imagino que muchos programadores de Java y C++ estarán tras ver este ejemplo respirando en una bolsa de plástico, sin embargo, aparte de que estas construcciones son muy frecuentes en lenguajes más modernos como Python, si lo pensamos detenidamente  no tiene ningún sentido escribir funciones alrededor de variables cuyo valor nunca se va a modificar dentro de dichas funciones. Ninguno en absoluto. Se que alguno estará arañándose la cara y gritando mientras mira al cielo <i>"¡La encapsulación, la encapsulación!"</i> como si la encapsulación fuera el Dios de una religión que hay que seguir por una cuestión de fe, pero es que resulta que no estamos rompiendo ninguna encapsulación porque este (adorado por algunos) término no significa más que <i>encapsular</i> un miembro de la clase y, asignar directamente un valor y devolverlo sin hacerle nada no encapsula nada en absoluto. Y hace que el código sea más lento, por cierto.</p><p>

Hay sin embargo un argumento bastante bueno castigar al usuario de nuestra clase haciéndole escribir getters y setters infinitos: aunque en la versión actual de la clase no realizemos ninguna operación al obtener o devolver el valor miembro, es posible que en el futuro sí queramos hacerlo. Por ejemplo podemos querer asegurarnos de que la primera letra del nombre y los apellidos sea mayúscula, o que al devolver el nombre añadamos el "Don" o "Doña". En realidad aunque muchos se agarren a este argumento la inmensa mayoría de getters y setters que empiezan vacíos pasa el resto de sus días vacíos. Pero ante la duda, incluso programadores más racionales y menos dogmáticos, usan los getters del demonio para evitar el riesgo de romper la interfaz de la clase en el futuro.</p><p>

Propiedades al rescate. Las propiedades en D y otros lenguajes son unas construcciones que nos permiten ofrecer al usuario de la clase una interfaz sencilla (<code>juan.nombre = "Juanjo"; writefln(juan.nombre);</code>) pero al mismo tiempo nos permiten tener la posibilidad de realizar operaciones además de la asignación o devolución del valor, si así lo estimamos oportuno. Y lo mejor de todo es que nos permiten <b>no</b> escribir función alguna, usando un miembro público, mientras no se realicen esas operaciones adicionales, y todo ello sin romper nunca la interfaz de nuestra clase. Si repasamos el ejemplo anterior, podríamos pensar que si en la versión 2.0 de Persona queremos que al asignarse Persona.nombre se ponga siempre la primera letra en mayúscula no podemos hacerlo sin meter los gesetters del infierno. Pero usando propiedades sí podemos:
        
    <pre>
    // En D, al ser un ejemplo más digno, además así no hay que escribir dos ficheros:
    import std.string;
    
    class Persona {
        public:
            this(string nombrearg, string apellidosarg) {
                nombre = nombrearg;
                apellidos = apellidosarg;
            }
            
        string nombre() { return m_nombre; } // "Getter"
        void nombre(string nombrearg) {             
            m_nombre = capitalize(nombrearg);
        }
        
        private:
            
            string m_nombre;
            string m_apellidos;
    }
    
    // Y el usuario lo sigue usando, EXACTAMENTE IGUAL, pero 
    // nótese como pone la primera letra mayúscula
    
    Persona juan = new Persona("Juan", "Alvarez Martinez");
    juan.nombre = "juanjo";
    juan.apellidos = "Alvarez Martinez Torres Jimenez";
    writefln("Nombre: ", juan.nombre); // Imprime "Juanjo", no "juanjo"
    writefln("Apellidos: ", juan.apellidos);
    </pre>        
        
Sinceramente, el que no vea la belleza y elegancia de esto y siga prefiriendo los gesetters al estilo tradicional, mejor que se dedique a una profesión donde no haya que evolucionar tanto como en la programación.</p><p>
<i>Nota: este artículo se irá ampliando con secciones sobre:</i></p><p>
</p><pre>Sobrecarga de operadores
El pseudotipo "auto"
Nueva sintaxis para genérica
Programación por contratos (unittest, in{}, out{} y demás)
Signals y slots
Modulos strings
Ampliar cadenas => writefln, readln, secuencias de escape, etc
Comentarios (de documentación y anidados)
http://www.dsource.org/projects/tutorials/wiki/TutorialFundamentals
más recursos: dsource, digitalmars.com/d, prowiki.org, 
  http://www.prowiki.org/wiki4d/wiki.cgi?D__Tutorial, h2d, dui, descent, dwt, 
Phobos
DTL
Hilos (sincronizacion)
Tipo de herencia, métodos virtuales y mixins
Referencia contenido: http://en.wikibooks.org/wiki/A_Beginner%27s_Guide_to_D

Artículo: "A D In Programming": <br />http://www.stickyminds.com/sitewide.asp?Function=edetail&ObjectType;=ART&ObjectId;=13542
</pre>

                    
                

      </div>

     <div class="clear-block clear">
              
        <!-- Tags -->
            <div class="terms small">
                tags: [
                
                    <span class="first taxonomy_term_30">
                        <a href="/category/articles">articles</a>
                         · 
                    </span>
                
                    <span class="first taxonomy_term_30">
                        <a href="/category/programacion">programacion</a>
                        
                    </span>
                
                ]
            </div>

      <!-- Next and Previous links -->
      


      </div> <!-- clear-block-clear -->
     <!-- Comment count -->
     
      
        
            <h2>Comentarios (2):</h2>
      


        <!-- Add comment link -->
        <div class="links">
                    
                      <strong>
                        <h3><a href="/addcomment/16/" title="Add a new comment to this page." class="comment_add">[Añadir comentario]</a></h3>
                      </strong>
                    
        </div>

        
          
                <div class="comment odd">
                  <div class="clear-block">
                     <span class="submitted">
                        <strong>Comentario #1 por Epíleg</strong> <br/>
                        <span class="small">jue 6 enero 2011, 21:33:05</span>
                     </span>
                    <br/>
                     <div class="content">
                        <p>Muy interesante y muy didáctico. Gracias!</p>
<p>No habrá más?</p>
                     </div>
                  </div>
                </div>

          
        
          
                <div class="comment odd">
                  <div class="clear-block">
                     <span class="submitted">
                        <strong>Comentario #2 por Gobi</strong> <br/>
                        <span class="small">jue 2 junio 2011, 07:14:03</span>
                     </span>
                    <br/>
                     <div class="content">
                        <p>¡Me has convencido, D es genial! :)</p>
                     </div>
                  </div>
                </div>

          
        
</div> <!-- Node -->



      </div>

      <!-- Right Boxes ============================================================================ -->
      <div id="sidebar-right" class="sidebar span-4 append-1 last">

      
      

      
        <div>
            


    
        <a href="/en/detail/2007/apr/25/el-lenguaje-de-programacion-d/"><img src="/imagenes/EN.gif"/></a>
    

    
        <img src="/imagenes/ES.gif"/>
    




        </div>

        <hr class="space" />

        <div>
            



<form action="http://www.google.com/cse" id="cse-search-box">
  <div>
    <input type="hidden" name="cx" value="partner-pub-2150094102675065:xbp4r0nlnb0" />
    <input type="hidden" name="ie" value="ISO-8859-1" />
    <input type="text" name="q" size="15" />
    <br/>
    <input type="submit" name="sa" value="Buscar" />
  </div>
</form>

<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=es"></script>





        </div>

        <!-- Donate -->
        <hr class="space" />
        <div>
            

<h2 class="boxtitle">&iexcl;C&oacute;mprame una cerveza!</a></h2>

<div class="content">
    <div class="tweet_text">
    &iquest;Te ha salvado la vida un art&iacute;culo? &iquest;Quieres agradec&eacute;rmelo?
    Mi <a href="http://bitcoin.org" target="_blank">Bitcoin</a> monedero:

    <br/><br/>
    <span style="word-wrap:break-word"><strong>1JZKNyYg5hYcvyGib2Z3TA1Pe7LGxkffZr</strong></span>
    </div>
</div>


        </div>

        <hr class="space" />
        <!--Latest Articles -->
        <div>
            

<h2 class="boxtitle"><a href="/es/all_article_titles/">Últimos Artículos</a></h2>



   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2013/mar/19/tutorial-de-overclocking-en-cpus-ivy-bridge-sandy-/">Tutorial de Overclocking en CPUs Ivy Bridge / Sandy Bridge</a></span><br/>
     <span class="tweet_date">20 mar 2013</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2013/mar/6/si-tienes-problemas-de-velocidad-de-red-desactiva-/">Si tienes problemas de velocidad de red, desactiva el Asus iNetwork Control</a></span><br/>
     <span class="tweet_date">07 mar 2013</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2013/jan/9/como-tener-whasap-en-un-tablet-android-sin-3g/">Como tener Whatsapp en un tablet Android sin 3G</a></span><br/>
     <span class="tweet_date">10 ene 2013</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/nov/1/perks-de-black-ops-ii-y-consejos-tacticos/">Perks de Black Ops II y consejos tácticos</a></span><br/>
     <span class="tweet_date">02 nov 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/oct/11/mi-canal-de-youtube-de-videos-y-comentarios-sobre-/">Mi canal de Youtube de vídeos y comentarios sobre videojuegos</a></span><br/>
     <span class="tweet_date">12 oct 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/jul/17/spelling-vim/">Spelling in Vim</a></span><br/>
     <span class="tweet_date">18 jul 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/jul/17/correccion-ortografica-en-vim/">Corrección ortográfica en Vim</a></span><br/>
     <span class="tweet_date">18 jul 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/jul/8/algunos-plugins-formidables-de-vim/">Algunos Plugins Formidables de Vim</a></span><br/>
     <span class="tweet_date">11 jul 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2012/jul/9/some-awesome-vim-plugins/">Some Awesome Vim Plugins</a></span><br/>
     <span class="tweet_date">11 jul 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2013/jan/8/analisisreview-de-varios-headsets-para-jugar-y-sol/">Análisis/review de varios headsets para jugar y solución con kit artesanal (ACTUALIZADO ENERO 2013)</a></span><br/>
     <span class="tweet_date">24 jun 2012</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2011/sep/27/battlefield-3-beta-ps3-quick-impressions/">Battlefield 3 beta for PS3 quick impressions</a></span><br/>
     <span class="tweet_date">28 sep 2011</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2011/jun/14/hint-android-smartphone-makers/">A hint for Android smartphone makers</a></span><br/>
     <span class="tweet_date">15 jun 2011</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2011/jun/9/como-no-ser-un-imbecil/">Cómo no ser un imbécil</a></span><br/>
     <span class="tweet_date">10 jun 2011</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2011/mar/14/spamvendo-piezas-de-mazda-rx-8/">[Spam]Vendo piezas de Mazda RX-8</a></span><br/>
     <span class="tweet_date">15 mar 2011</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2011/jan/23/consejos-para-usuarios-del-mazda-rx-8/">Consejos para usuarios del Mazda RX-8</a></span><br/>
     <span class="tweet_date">24 ene 2011</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2010/nov/24/gran-turismo-5/">Gran Turismo 5</a></span><br/>
     <span class="tweet_date">25 nov 2010</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2010/oct/4/mi-vimrc-octubre-de-2010/">Mi vimrc a octubre de 2010</a></span><br/>
     <span class="tweet_date">06 oct 2010</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2006/aug/19/introsubversion/">Introducción a Subversion</a></span><br/>
     <span class="tweet_date">20 ago 2010</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2010/jul/26/ubuntu-linux-1004-64bits-sony-vaio-vpc-eb-2x5e-vpc/">Ubuntu Linux 10.04 (64bits) on a Sony Vaio VPCEB2X5E</a></span><br/>
     <span class="tweet_date">27 jul 2010</span>
   </div>
   <!--</div>-->

   <!--<div class="tweet_content">-->
   <div class="article_list_item">
     <span class="tweet_text"><a href="/es/detail/2010/jun/6/rails-y-django/">Rails y Django</a></span><br/>
     <span class="tweet_date">06 jun 2010</span>
   </div>
   <!--</div>-->

<br/>
<a href="/es/all_article_titles/">[Ver Todos]</a>
<hr/>

        </div>
        <hr class="space" />

         <!-- Latest tweets -->
         <div>
            


<h2 class="boxtitle"><a href="http://twitter.com/#/juanjux">Tweets</a></h2>

<div class="content">
    
    
    <a href="http://twitter.com/juanjux/status/255955664113909760" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">@DavidVonderhaar are you planning to do something against people using the XIM3 KB+M controller in league play on consoles?</span><br/>
           <span class="tweet_date">10 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/255695745963945984" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">Los españoles no nos acostamos más tarde porque nos vaya la juerga (que también): http://t.co/14w7ceZo</span><br/>
           <span class="tweet_date">09 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/255678762421735424" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">IU vota en Madrid en contra de eliminar prebendas. Veo que los comunistas siguien siendo igual, los de &quot;¡la moto no se toca, que es mía!&quot;.</span><br/>
           <span class="tweet_date">09 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/255280751518560256" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">La justicia es lenta pero esperemos que poco a poco los responsables del desaguisado vayan pagando: http://t.co/X7lKmQpV</span><br/>
           <span class="tweet_date">08 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/255274653789061120" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">@perezreverte por eso perdí la fe en la democracia en este país. Hace falta una dictadura de la Educación, después ya sí, democracia.</span><br/>
           <span class="tweet_date">08 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/255273960818749440" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">Cuando a @perezreverte le da por ironizar un domingo, te das cuenta de la cantidad de idiotas que hay por el mundo que le toman literalmente</span><br/>
           <span class="tweet_date">08 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/254282729959616512" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">@candyslexia ah ok, I tought you were removing the rotation, thanks</span><br/>
           <span class="tweet_date">05 oct 2012</span>
        </div>
    </a>
    
    <a href="http://twitter.com/juanjux/status/254171642949931008" target="_blank">
        <div class="tweet_content">
           <span class="tweet_text">@DavidVonderhaar interesting, easy to implement change so move some of the killwhores out of objective games: http://t.co/ux1Ycmu6</span><br/>
           <span class="tweet_date">05 oct 2012</span>
        </div>
    </a>
    
</div>


         </div>
        <hr class="space" />

        <div class="span-5 last">
            

<h3>Mi...</h3>

<div class="content">
<strong>
<a href="http://flickr.com/amyja">Flickr</a> <br>
<a href="http://www.linkedin.com/pub/1/154/999">LinkedIn</a> <br>
<a href="http://twitter.com/juanjux">Twitter</a><br>
</strong>
</div>


        </div>
        <hr class="space" />

      

      
      

      </div>
      <hr class="space"/>

    <!-- Footer ==================================================================================== -->

    <div id="footer" class="prepend-1 span-23 last quiet small">
            
                <p><strong>JuanjoAlvarez.net</strong> es &copy; 2004-2012
                Juanjo Alvarez |
                Todos los derechos reservados salvo que se indique lo
                contrario
                </p>
            
    </div> 
   </div> <!-- Container -->
<!-- /layout -->
<!-- Google analytics -->

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>

<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-115245-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
<!-- Fin Google Analytics -->

  </body>
</html>





















