http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
P3P: CP="ALL ADM DEV PSAi COM OUR OTRo STP IND ONL"
X-Tumblr-User: viraptor
X-Tumblr-Pixel-0: http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoidXJsIiwidXJsIjoiaHR0cDpcL1wvYmxvZy52aXJhcHRvci5pbmZvXC9wb3N0XC80NDQyNDE0MDIzN1wvcGVlay1hbmQtcG9rZS1pbi10aGUtYWdlLW9mLWxpbnV4IiwicmVxdHlwZSI6MCwicm91dGUiOiJcL3Bvc3RcLzppZFwvOnN1bW1hcnkifQ==&U=DKGLPEBHDO&K=ae5102bfbde8e83354ae13a985c135a2e6ac433b2a7b81f87c254a4b6ed8b713--http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoicG9zdCIsInVybCI6Imh0dHA6XC9cL2Jsb2cudmlyYXB0b3IuaW5mb1wvcG9zdFwvNDQ0MjQxNDAyMzdcL3BlZWstYW5kLXBva2UtaW4tdGhl
X-Tumblr-Pixel-1: LWFnZS1vZi1saW51eCIsInJlcXR5cGUiOjAsInJvdXRlIjoiXC9wb3N0XC86aWRcLzpzdW1tYXJ5IiwicG9zdHMiOlt7InBvc3RpZCI6IjQ0NDI0MTQwMjM3IiwiYmxvZ2lkIjoiOTM3MTkyNjQiLCJzb3VyY2UiOjMzfV19&U=BMCCINFAHG&K=4ccd86311225720df80846af2062cd0b076f7da91edf77bd661c7cccc8edc762
X-Tumblr-Pixel: 2
Link: <http://tmblr.co/ZSPR0tfNufND>; rel=shorturl
Link: <http://assets.tumblr.com/images/default_avatar_128.png>; rel=icon
X-UA-Compatible: IE=Edge,chrome=1
Content-Encoding: gzip
X-UA-Device: desktop
Vary: X-UA-Device
Content-Length: 12853
Accept-Ranges: bytes
Date: Wed, 23 Jul 2014 15:33:12 GMT
Connection: close

<!DOCTYPE html>
<script>var __pbpa = true;</script><script>var translated_warning_string = 'Warning: Never enter your Tumblr password unless \u201chttps://www.tumblr.com/login\u201d\x0ais the address in your web browser.\x0a\x0aYou should also see a green \u201cTumblr, Inc.\u201d identification in the address bar.\x0a\x0aSpammers and other bad guys use fake forms to steal passwords.\x0a\x0aTumblr will never ask you to log in from a user\u2019s blog.\x0a\x0aAre you absolutely sure you want to continue?';</script><script type="text/javascript" language="javascript" src="http://assets.tumblr.com/assets/scripts/pre_tumblelog.js?_v=c65abde67782d19ef9d6ba2e8362ef98"></script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# blog: http://ogp.me/ns/blog#">
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<meta name="text:Google Analytics ID" content=""/>
		
		<meta name="text:Twitter Name" content=""/>
		<meta name="text:Facebook Profile URL" content=""/>
		<meta name="color:Color1" content="#1DCAC0"/>
		<meta name="color:Color2" content="#C10000"/>

<!-- For Syntax Highlighting -->
<script src="http://code.jquery.com/jquery-latest.min.js"></script>
<link rel="stylesheet" type="text/css" href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css"></link>  
<script src="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.js"></script>  
<script>
    function styleCode() {
        if (typeof disableStyleCode != 'undefined') { return; }
        var a = false;
        $('code').each(function() {
            if (!$(this).hasClass('prettyprint')) {
                $(this).addClass('prettyprint');
                a = true;
            }
        });
        if (a) { prettyPrint(); } 
    }
    $(function() {styleCode();});
</script>

		<title>Wild code | Peek and poke in the age of Linux</title>
		
		<link rel="stylesheet" type="text/css" href="http://static.tumblr.com/ts2nqrf/ozylq3ufg/screen.css" />
		<link rel="stylesheet" type="text/css" href="http://static.tumblr.com/ts2nqrf/qe1lq3uho/bebas.css" />
		
		<link rel="shortcut icon" href="http://assets.tumblr.com/images/default_avatar_128.png" />
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
		
		<style type="text/css">
			#footer { background-color: #2951d5; }
 			#header { background-color: #2951d5; }
 			#post a { color: #C10000;}
 			#description a { color: #C10000;}
 			.name { color: #C10000;}
 			.answertags { color: #C10000;}
 			.post-color { background-color: #C10000; }
 			blockquote { border-color: #C10000; }
 			.tagshowing { color: #C10000;}
 			h3 a:hover {color: #C10000;}
			code {
  display: block;
  border-left: .25em solid #777;
  padding-left: 1em;
  margin-bottom: 2em;
}
.post-content p {
  text-align: justify;
}
		</style>
		
	<link rel="alternate" href="android-app://com.tumblr/tumblr/x-callback-url/blog?blogName=viraptor&postID=44424140237" />
<script src="http://assets.tumblr.com/assets/scripts/tumblelog.js?_v=7edb3c3b36e8b351a1249cf33411a3a7"></script>
<link rel="stylesheet" type="text/css" href="http://assets.tumblr.com/fonts/gibson/stylesheet.css?v=3">
<meta http-equiv="x-dns-prefetch-control" content="off"/>
<meta name="keywords" content="linux,ptrace,poke,peek,coding" />

<!-- BEGIN TUMBLR FACEBOOK OPENGRAPH TAGS --><!-- If you'd like to specify your own Open Graph tags, define the og:url and og:title tags in your theme's HTML. --><!-- Read more: http://ogp.me/ --><meta property="fb:app_id" content="48119224995" /><meta property="og:site_name" content="" /><meta property="og:title" content="Peek and poke in the age of Linux" /><meta property="og:url" content="http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux" /><meta property="og:description" content="Some time ago I ran into a production issue where the init process (upstart) stopped behaving properly. Specifically, instead of spawning new processes, it deadlocked in a transitional state. To be..." /><meta property="og:determiner" content="a" /><meta property="og:type" content="tumblr-feed:entry" /><meta property="og:image" content="http://assets.tumblr.com/images/og/text_200.png" /><meta property="al:ios:url" content="tumblr://x-callback-url/blog?blogName=viraptor&amp;postID=44424140237" /><meta property="al:ios:app_name" content="Tumblr" /><meta property="al:ios:app_store_id" content="305343404" /><meta property="al:android:url" content="tumblr://x-callback-url/blog?blogName=viraptor&amp;postID=44424140237" /><meta property="al:android:app_name" content="Tumblr" /><meta property="al:android:package" content="com.tumblr" /><!-- END TUMBLR FACEBOOK OPENGRAPH TAGS -->


<!-- TWITTER TAGS --><meta charset="utf-8"><meta name="twitter:card" content="summary" /><meta name="twitter:description" content="Some time ago I ran into a production issue where the init process (upstart) stopped behaving properly. Specifically, instead of spawning new processes, it deadlocked in a transitional state. To be precise, the init process itself was responsive, but the critical services were stuck in one of the pre- or post- states, never actually restarting. What&amp;#8217;s worse, upstart doesn&amp;#8217;t allow forcing a state transition and trying to manually create and send DBus events didn&amp;#8217;t help either. That meant the sane options we were left with were:
 restart the host (not desirable at all in that scenario)
 start the process manually and hope auto-respawn will not be needed.
 Of course there are also some insane options. Why not cheat like in the old times and just PEEK and POKE the process in the right places? The solution used at the time involved a very ugly script driving gdb which probably summoned satan in some edge cases. But edge cases were not hit and majority of hosts recovered without issues. (if you overwrite memory of your init process, you should expect at least a small percent of segfaults) After some time however I wanted to recreate the experiment in a cleaner way and see what interfaces are available if I had a legitimate use for doing something similar again.
 The goal is the same - given an upstart job name, change its goal and status fields to arbitrary values, without killing the init process. First some context however:
Why is peek/poke harder these days?
 In good old times when software size was measured in kilobytes and each byte was quite expensive dynamic allocation was very rare. Whatever could be static, was static. Whatever couldn&amp;#8217;t be, was most likely pooled in a specific region and there was a preset number of &amp;#8220;things&amp;#8221; the program could handle. That means your lives counter or some other important value was most likely always at the exact same address every time. That&amp;#8217;s not the case anymore unfortunately. Almost everything needs to handle an arbitrary number of &amp;#8220;things&amp;#8221; these days and that means dynamic allocation.
 It&amp;#8217;s also trivial to allocate new memory regions and OS takes care of things like making sure the memory looks like a one continuous space to your app, while it reality it can be all over the place. The practical implication is that anything we&amp;#8217;ll need to search for in the upstart process will be malloc&amp;#8217;d somewhere in the heap area. We also need to know where the heap happens to be at the specific time.
Ways of direct access to a process.
 On Linux there are a couple of ways to access memory of a foreign process. The easiest two are reading directly from /proc/(pid)/mem and using the ptrace library. The ptrace request ids are actually called PTRACE_PEEKDATA and PTRACE_POKEDATA which should make their purpose quite clear. There&amp;#8217;s a lot of information about them in man pages if you want more details, but let&amp;#8217;s move on to some real action.
 Where to read from is another interesting question. Apart from dynamic allocation we&amp;#8217;ve got virtual memory these days and additional memory-shifting concepts like ASLR. The up-to-date, valid information about where to look for data will exist under /proc/(pid)/maps for each running application. For the init process (PID 1), it looks something like this:
...... 7fae2b2b7000-7fae2b2b9000 rw-p 00023000 fd:01 2860&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /lib/x86_64-linux-gnu/ld-2.15.so 7fae2b2b9000-7fae2b2df000 r-xp 00000000 fd:01 4259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sbin/init (deleted) 7fae2b4de000-7fae2b4e0000 r--p 00025000 fd:01 4259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sbin/init (deleted) 7fae2b4e0000-7fae2b4e1000 rw-p 00027000 fd:01 4259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /sbin/init (deleted) 7fae2cf09000-7fae2cfd0000 rw-p 00000000 00:00 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [heap] 7fffc146b000-7fffc148c000 rw-p 00000000 00:00 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [stack] 7fffc1599000-7fffc159a000 r-xp 00000000 00:00 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0&nbsp; [vsyscall]
 As previously noted, all of the interesting / long-lived data will be found in the heap which is annotated with a fake path &amp;#8220;[heap]&amp;#8221;. All of the ranges listed in the maps file are available. Others will give an error on access. Process memory acts like a stricter version of a sparse file in this case.
Nice ways of direct access
 Both ptrace and memory-file interfaces are quite low-level, so instead of writing lots of C code, I&amp;#8217;m going to use some Python instead. Fortunately there&amp;#8217;s an existing ptrace wrapper on pypi and even though it looks abandoned, it still works very well. The interface allows easy &amp;#8220;stop and attach&amp;#8221; operation as well as exposes some interesting functions for address range reading and writing. Allow me to do some blog-literate programming here. The ptrace interface allows for easy attaching to a chosen PID (1 in this case):
def get_init_process(): &nbsp;&nbsp;&nbsp; d = ptrace.debugger.PtraceDebugger() &nbsp;&nbsp;&nbsp; proc = d.addProcess(1, False) &nbsp;&nbsp;&nbsp; return proc
 Now down to the details&amp;#8230; After a quick glance at init/job.h from upstart source code, it looks like we&amp;#8217;re interested in two values from struct Job - goal and state. Both have a range of values described at the top of the file. Counting from the beginning of the struct, they&amp;#8217;re at offset 5*(native pointer length), because NihList consists of two pointers only.
PTR_SIZE=ptrace.cpu_info.CPU_WORD_SIZE JOB_CLASS_NAME_OFFSET = PTR_SIZE*2 JOB_CLASS_PATH_OFFSET = PTR_SIZE*3 JOB_NAME_OFFSET = PTR_SIZE*2 JOB_JOB_CLASS_OFFSET = PTR_SIZE*3 JOB_PATH_OFFSET = PTR_SIZE*4 JOB_GOAL_OFFSET = PTR_SIZE*5
 But struct Job is not something we can find easily. Let&amp;#8217;s say the upstart job to fix is called &amp;#8220;rsyslog&amp;#8221;. This string is in the heap, but not pointed to from the Job structure. That part initially consisted of some guesswork and upstream code browsing which I&amp;#8217;m not going to reproduce here, but the result is that the bytes &amp;#8220;rsyslog&quot; (or &quot;rsyslog\0&quot; to be precise) exists in structure JobClass in init/job_class.h. Actually&amp;#8230; there and in 18 other places. That means on the current system I can find 19 places which contain that name terminated by a zero byte and the next steps are going to be figuring out how to figure out which of those occurrences can be traced back to the job itself.
def get_heap(proc): &nbsp;&nbsp;&nbsp; return [m for m in proc.readMappings() if m.pathname == &#039;[heap]&#039;][0] def find_refs_to(mem, bytestr) &nbsp; &nbsp; return [addr for addr in heap.search(bytestr)]
 With such a low number of hits we can just check each of them and see how viable each one is.
Tracking references
 So how to find out if each of the guesses is correct? By checking if the surrounding values and pointers makes sense. In this case the JobClass has a path field which according to comments is a string containing the DBus path for the job. As noted previously, those fields have a known offset from the start of the structure. Let&amp;#8217;s write something generic then that will browse through given addresses and check if the memory referencing them looks like it could be a known object:
def flatten(stream): &nbsp;&nbsp;&nbsp; result = [] &nbsp;&nbsp;&nbsp; for collection in stream: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.extend(collection) &nbsp;&nbsp;&nbsp; return result def places_referring_to(mem, search_value): &nbsp;&nbsp;&nbsp; needle = ptrace.ctypes_tools.word2bytes(search_value) &nbsp;&nbsp;&nbsp; return find_refs_to(mem, needle) def find_object_references(proc, heap, values, offset, verifier): &nbsp;&nbsp;&nbsp; refs = flatten(places_referring_to(heap, value) for value in values) &nbsp;&nbsp;&nbsp; return [ref-offset for ref in refs if verifier(proc, ref-offset)]
 Now some functions that can actually judge whether some location looks like a Job or a JobClass by extracting expected strings:
def deref_string(proc, addr): &nbsp;&nbsp;&nbsp; s_addr = proc.readWord(addr) &nbsp;&nbsp;&nbsp; try: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return proc.readCString(s_addr, 100)[0] &nbsp;&nbsp;&nbsp; except ptrace.debugger.process_error.ProcessError: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None def looks_like_job_class(proc, addr): &nbsp;&nbsp;&nbsp; s = deref_string(proc, addr+JOB_CLASS_PATH_OFFSET) &nbsp;&nbsp;&nbsp; return s is not None and s.startswith(&#039;/com/ubuntu/Upstart/jobs/&#039;) def looks_like_job(proc, addr): &nbsp;&nbsp;&nbsp; s = deref_string(proc, addr+JOB_PATH_OFFSET) &nbsp;&nbsp;&nbsp; return s is not None and s.startswith(&#039;/com/ubuntu/Upstart/jobs/&#039;)
 And that&amp;#8217;s it. There could be a lot more sanity checking going on, but after a quick check it appears to be unnecessary. A quick run results in only one pointer which actually does show a valid Job structure.
 The reference chain we&amp;#8217;re looking for is: string (name of the process) -&amp;gt; that is used in a JobClass -&amp;gt; that is used in a Job. To wrap it all up into an actual script:
proc = get_init_process() heap = get_heap(proc) process_strings = find_refs_to(heap, process_to_fix) job_classes = find_object_references(proc, heap, process_strings, &nbsp;&nbsp;&nbsp; JOB_CLASS_NAME_OFFSET, looks_like_job_class) jobs = find_object_references(proc, heap, job_classes, &nbsp;&nbsp;&nbsp; JOB_JOB_CLASS_OFFSET, looks_like_job) for job in jobs: &nbsp;&nbsp;&nbsp; print &quot;job found at 0x%016x&quot; % job &nbsp;&nbsp;&nbsp; goal, state = proc.readStruct(job+JOB_GOAL_OFFSET, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctypes.c_int32*2)[:] &nbsp;&nbsp;&nbsp; print &quot;goal&quot;, job_goals[goal] &nbsp;&nbsp;&nbsp; print &quot;state&quot;, job_states[state]
Does it all work?
 Yes, of course it does! And pretty reliably actually:
sudo ./search_init.py rsyslog job found at 0x00007fae2cf95ca0 goal JOB_START state JOB_RUNNING
 After finding the right address it&amp;#8217;s only a matter of proc.writeBytes() to force the change of the goal and state.
 Unfortunately there&amp;#8217;s nothing stopping the system from being in a state where this change really shouldn&amp;#8217;t happen. For example right before the value is read, or while it&amp;#8217;s being copied and some code path still holds the old reference, or&amp;#8230; Basically changing memory which you don&amp;#8217;t have complete control over is not safe. Ever. Around 1% of machines had problems with init going crazy afterwards, but those could be just rebooted then. But as a hack that allows you to fix a critical issue, it&amp;#8217;s worth remembering that it&amp;#8217;s not rocket science.
 And finally: thanks to Victor Stinner for writing some really useful Python tools." /><meta name="twitter:title" content="Peek and poke in the age of Linux" /><meta name="twitter:url" content="http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux" /><meta name="twitter:site" content="tumblr" /><meta name="twitter:app:name:iphone" content="Tumblr" /><meta name="twitter:app:name:ipad" content="Tumblr" /><meta name="twitter:app:name:googleplay" content="Tumblr" /><meta name="twitter:app:id:iphone" content="305343404" /><meta name="twitter:app:id:ipad" content="305343404" /><meta name="twitter:app:id:googleplay" content="com.tumblr" /><meta name="twitter:app:url:iphone" content="tumblr://x-callback-url/blog?blogName=viraptor&amp;postID=44424140237&amp;referrer=twitter-cards" /><meta name="twitter:app:url:ipad" content="tumblr://x-callback-url/blog?blogName=viraptor&amp;postID=44424140237&amp;referrer=twitter-cards" /><meta name="twitter:app:url:googleplay" content="tumblr://x-callback-url/blog?blogName=viraptor&amp;postID=44424140237&amp;referrer=twitter-cards" />

</head>
	<body>
	
	<div id="wrapper">
        <div id="header">
        <div id="header-pat">
           <div id="header-top">
           		<div id="header-icons">
           			<div class="btn-rss"><a href="http://blog.viraptor.info/rss">RSS</a></div>
           			<div class="btn-archive"><a href="/archive">ARCHIVE</a></div>
           			
           			
           			
			        <div class="btn-twitter"><a href="http://twitter.com/viraptor" target="_blank">Twitter</a></div>
           		</div>
           		<h1 class="bebas" title="Wild code"><a href="/">Wild code</a></h1>
           </div>
           
           <div id="header-end">
           		<div id="header-bot"></div>
           		<div id="header-cap"></div>
           </div>
           
           <div class="clear"></div>
        </div>
        </div>
        
        <div id="container" class="clear">
        
         
        
        

        
        
        
        
        
        <div id="post">
        	<div class="post-header">
        		<div class="post-color">
        			<div class="title-texture">
        				<h2 class="bebas"><a href="http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux">Peek and poke in the age of Linux</a></h2>
        				
        				
        				
        				
        				
        				
        				
        			</div>
        			
        			
					
					
        			
        			
        			
        			<div class="cap-post"><a href="http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux">Text</a></div>
        			
        			
        			
        			<div class="clear"></div>
        		</div>
        		<div class="post-spacer"></div>
        	</div>
        	<div class="clear"></div>
        	<div class="post-info bebas">
        		<div class="parts">1 year ago&nbsp;&nbsp;&nbsp;
        			|&nbsp;&nbsp;&nbsp;Tags:
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/Python">Python</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/coding">coding</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/hacks">hacks</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/peek">peek</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/poke">poke</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/linux">linux</a></span>
	        			
	        				<span class="tags"><a href="http://blog.viraptor.info/tagged/ptrace">ptrace</a></span>
	        			
	        			&nbsp;
        			
        		
        		|&nbsp;&nbsp;&nbsp;Notes: <a href="http://blog.viraptor.info/post/44424140237/peek-and-poke-in-the-age-of-linux#notes">8</a></div>
        		<div class="clear"></div>
        	</div>
        	<div class="post-content">
        		
        		
				

				
				
				<p>
					
					
					
					<p>Some time ago I ran into a production issue where the <strong>init</strong> process (<strong>upstart</strong>) stopped behaving properly. Specifically, instead of spawning new processes, it deadlocked in a transitional state. To be precise, the init process itself was responsive, but the critical services were stuck in one of the pre- or post- states, never actually restarting. What&#8217;s worse, upstart doesn&#8217;t allow forcing a state transition and trying to manually create and send <strong>DBus</strong> events didn&#8217;t help either. That meant the sane options we were left with were:</p>
<ul><li>restart the host (not desirable at all in that scenario)</li>
<li>start the process manually and hope auto-respawn will not be needed.</li>
</ul><p>Of course there are also some insane options. Why not cheat like in the old times and just <strong>PEEK</strong> and <strong>POKE</strong> the process in the right places? The solution used at the time involved a very ugly script driving gdb which probably summoned satan in some edge cases. But edge cases were not hit and majority of hosts recovered without issues. (if you overwrite memory of your init process, you should expect at least a small percent of segfaults) After some time however I wanted to recreate the experiment in a cleaner way and see what interfaces are available if I had a legitimate use for doing something similar again.</p>
<p>The goal is the same - given an upstart job name, change its <strong>goal</strong> and <strong>status</strong> fields to arbitrary values, without killing the <strong>init</strong> process. First some context however:</p>
<h3>Why is peek/poke harder these days?</h3>
<p>In good old times when software size was measured in kilobytes and each byte was quite expensive dynamic allocation was very rare. Whatever could be static, was static. Whatever couldn&#8217;t be, was most likely pooled in a specific region and there was a preset number of &#8220;things&#8221; the program could handle. That means your lives counter or some other important value was most likely always at the exact same address every time. That&#8217;s not the case anymore unfortunately. Almost everything needs to handle an arbitrary number of &#8220;things&#8221; these days and that means dynamic allocation.</p>
<p>It&#8217;s also trivial to allocate new memory regions and OS takes care of things like making sure the memory looks like a one continuous space to your app, while it reality it can be all over the place. The practical implication is that anything we&#8217;ll need to search for in the upstart process will be malloc&#8217;d somewhere in the <strong>heap</strong> area. We also need to know where the heap happens to be at the specific time.</p>
<h3>Ways of direct access to a process.</h3>
<p>On Linux there are a couple of ways to access memory of a foreign process. The easiest two are reading directly from /proc/(pid)/mem and using the <strong>ptrace</strong> library. The ptrace request ids are actually called <strong>PTRACE_PEEKDATA</strong> and <strong>PTRACE_POKEDATA</strong> which should make their purpose quite clear. There&#8217;s a lot of information about them in man pages if you want more details, but let&#8217;s move on to some real action.</p>
<p>Where to read from is another interesting question. Apart from dynamic allocation we&#8217;ve got virtual memory these days and additional memory-shifting concepts like <strong>ASLR</strong>. The up-to-date, valid information about where to look for data will exist under /proc/(pid)/maps for each running application. For the init process (PID 1), it looks something like this:</p>
<pre><code>......<br/>7fae2b2b7000-7fae2b2b9000 rw-p 00023000 fd:01 2860       /lib/x86_64-linux-gnu/ld-2.15.so<br/>7fae2b2b9000-7fae2b2df000 r-xp 00000000 fd:01 4259       /sbin/init (deleted)<br/>7fae2b4de000-7fae2b4e0000 r--p 00025000 fd:01 4259       /sbin/init (deleted)<br/>7fae2b4e0000-7fae2b4e1000 rw-p 00027000 fd:01 4259       /sbin/init (deleted)<br/>7fae2cf09000-7fae2cfd0000 rw-p 00000000 00:00 0          [heap]<br/>7fffc146b000-7fffc148c000 rw-p 00000000 00:00 0          [stack]<br/>7fffc1599000-7fffc159a000 r-xp 00000000 00:00 0          [vdso]<br/>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]</code></pre>
<p>As previously noted, all of the interesting / long-lived data will be found in the heap which is annotated with a fake path &#8220;<strong>[heap]</strong>&#8221;. All of the ranges listed in the maps file are available. Others will give an error on access. Process memory acts like a stricter version of a sparse file in this case.</p>
<h3>Nice ways of direct access</h3>
<p>Both ptrace and memory-file interfaces are quite low-level, so instead of writing lots of C code, I&#8217;m going to use some Python instead. Fortunately there&#8217;s an existing <a href="https://pypi.python.org/pypi/python-ptrace">ptrace wrapper on pypi</a> and even though it looks abandoned, it still works very well. The interface allows easy &#8220;stop and attach&#8221; operation as well as exposes some interesting functions for address range reading and writing. Allow me to do some blog-literate programming here. The ptrace interface allows for easy attaching to a chosen PID (1 in this case):</p>
<pre><code>def get_init_process():<br/>    d = ptrace.debugger.PtraceDebugger()<br/>    proc = d.addProcess(1, False)<br/>    return proc</code></pre>
<p>Now down to the details&#8230; After a quick glance at <a href="http://bazaar.launchpad.net/~ubuntu-branches/ubuntu/precise/upstart/precise/view/head:/init/job.h" title="init/job.h">init/job.h</a> from upstart source code, it looks like we&#8217;re interested in two values from struct Job - goal and state. Both have a range of values described at the top of the file. Counting from the beginning of the struct, they&#8217;re at offset 5*(native pointer length), because <a href="http://libnih.sourcearchive.com/documentation/1.0.1/structnih__list.html" title="libnih documentation">NihList</a> consists of two pointers only.</p>
<pre><code>PTR_SIZE=ptrace.cpu_info.CPU_WORD_SIZE<br/>JOB_CLASS_NAME_OFFSET = PTR_SIZE*2<br/>JOB_CLASS_PATH_OFFSET = PTR_SIZE*3<br/>JOB_NAME_OFFSET = PTR_SIZE*2<br/>JOB_JOB_CLASS_OFFSET = PTR_SIZE*3<br/>JOB_PATH_OFFSET = PTR_SIZE*4<br/>JOB_GOAL_OFFSET = PTR_SIZE*5</code></pre>
<p>But struct <strong>Job</strong> is not something we can find easily. Let&#8217;s say the upstart job to fix is called &#8220;<em>rsyslog</em>&#8221;. This string is in the heap, but not pointed to from the Job structure. That part initially consisted of some guesswork and upstream code browsing which I&#8217;m not going to reproduce here, but the result is that the bytes &#8220;<em>rsyslog</em>" (or "<em>rsyslog\0</em>" to be precise) exists in structure <strong>JobClass</strong> in <a href="http://bazaar.launchpad.net/~ubuntu-branches/ubuntu/precise/upstart/precise/view/head:/init/job_class.h" title="init/job_class.h">init/job_class.h</a>. Actually&#8230; there and in 18 other places. That means on the current system I can find 19 places which contain that name terminated by a zero byte and the next steps are going to be figuring out how to figure out which of those occurrences can be traced back to the job itself.</p>
<pre><code>def get_heap(proc):<br/>    return [m for m in proc.readMappings() if m.pathname == '[heap]'][0]<br/><br/>def find_refs_to(mem, bytestr)<br/>    return [addr for addr in heap.search(bytestr)]</code></pre>
<p>With such a low number of hits we can just check each of them and see how viable each one is.</p>
<h3>Tracking references</h3>
<p>So how to find out if each of the guesses is correct? By checking if the surrounding values and pointers makes sense. In this case the JobClass has a <strong>path</strong> field which according to comments is a string containing the DBus path for the job. As noted previously, those fields have a known offset from the start of the structure. Let&#8217;s write something generic then that will browse through given addresses and check if the memory referencing them looks like it could be a known object:</p>
<pre><code>def flatten(stream):<br/>    result = []<br/>    for collection in stream:<br/>        result.extend(collection)<br/>    return result<br/><br/>def places_referring_to(mem, search_value):<br/>    needle = ptrace.ctypes_tools.word2bytes(search_value)<br/>    return find_refs_to(mem, needle)<br/><br/>def find_object_references(proc, heap, values, offset, verifier):<br/>    refs = flatten(places_referring_to(heap, value) for value in values)<br/>    return [ref-offset for ref in refs if verifier(proc, ref-offset)]</code></pre>
<p>Now some functions that can actually judge whether some location looks like a Job or a JobClass by extracting expected strings:</p>
<pre><code>def deref_string(proc, addr):<br/>    s_addr = proc.readWord(addr)<br/>    try:<br/>        return proc.readCString(s_addr, 100)[0]<br/>    except ptrace.debugger.process_error.ProcessError:<br/>        return None<br/><br/>def looks_like_job_class(proc, addr):<br/>    s = deref_string(proc, addr+JOB_CLASS_PATH_OFFSET)<br/>    return s is not None and s.startswith('/com/ubuntu/Upstart/jobs/')<br/><br/>def looks_like_job(proc, addr):<br/>    s = deref_string(proc, addr+JOB_PATH_OFFSET)<br/>    return s is not None and s.startswith('/com/ubuntu/Upstart/jobs/')</code></pre>
<p>And that&#8217;s it. There could be a lot more sanity checking going on, but after a quick check it appears to be unnecessary. A quick run results in only one pointer which actually does show a valid Job structure.</p>
<p>The reference chain we&#8217;re looking for is: string (name of the process) -&gt; that is used in a JobClass -&gt; that is used in a Job. To wrap it all up into an actual script:</p>
<pre><code>proc = get_init_process()<br/>heap = get_heap(proc)<br/>process_strings = find_refs_to(heap, process_to_fix)<br/>job_classes = find_object_references(proc, heap, process_strings,<br/>    JOB_CLASS_NAME_OFFSET, looks_like_job_class)<br/>jobs = find_object_references(proc, heap, job_classes,<br/>    JOB_JOB_CLASS_OFFSET, looks_like_job)<br/><br/>for job in jobs:<br/>    print "job found at 0x%016x" % job<br/>    goal, state = proc.readStruct(job+JOB_GOAL_OFFSET,<br/>        ctypes.c_int32*2)[:]<br/>    print "goal", job_goals[goal]<br/>    print "state", job_states[state]</code></pre>
<h3>Does it all work?</h3>
<p>Yes, of course it does! And pretty reliably actually:</p>
<pre><code>sudo ./search_init.py rsyslog<br/>job found at 0x00007fae2cf95ca0<br/>goal JOB_START<br/>state JOB_RUNNING</code></pre>
<p>After finding the right address it&#8217;s only a matter of <strong>proc.writeBytes()</strong> to force the change of the goal and state.</p>
<p>Unfortunately there&#8217;s nothing stopping the system from being in a state where this change really shouldn&#8217;t happen. For example right before the value is read, or while it&#8217;s being copied and some code path still holds the old reference, or&#8230; Basically changing memory which you don&#8217;t have complete control over is not safe. Ever. Around 1% of machines had problems with init going crazy afterwards, but those could be just rebooted then. But as a hack that allows you to fix a critical issue, it&#8217;s worth remembering that it&#8217;s not rocket science.</p>
<p>And finally: thanks to <a href="https://bitbucket.org/haypo" title="Victor Stinner's bitbucket repos">Victor Stinner</a> for writing some really useful Python tools.</p>
					
					
					
					
					
					<div id="notes"><ol class="notes"><!-- START NOTES --><li class="note reblog tumblelog_awasim without_commentary"><a rel="nofollow" class="avatar_frame" target="_blank" href="http://blog.scriptingsysadmin.com/" title="Adnans Tech Links Blog"><img src="http://31.media.tumblr.com/avatar_9f929118c414_16.png" class="avatar " alt="" /></a><span class="action" data-post-url="http://blog.scriptingsysadmin.com/post/44930002973"><a rel="nofollow" href="http://blog.scriptingsysadmin.com/" class="tumblelog" title="Adnans Tech Links Blog">awasim</a> reblogged this from <a rel="nofollow" href="http://blog.viraptor.info/" class="source_tumblelog" title="Wild code">viraptor</a></span><div class="clear"></div></li><li class="note like tumblelog_geeky without_commentary"><a rel="nofollow" class="avatar_frame" target="_blank" href="http://geeky.tumblr.com/" title="Geeky Tumblr " rel="nofollow"><img src="http://31.media.tumblr.com/avatar_1ad7baacf1cf_16.gif" class="avatar " alt="" /></a><span class="action"><a rel="nofollow" href="http://geeky.tumblr.com/" title="Geeky Tumblr" rel="nofollow">geeky</a> likes this</span><div class="clear"></div></li><li class="note like tumblelog_scruffyinfant without_commentary"><a rel="nofollow" class="avatar_frame" target="_blank" href="http://scruffyinfant.tumblr.com/" title="はじめまして！！！ " rel="nofollow"><img src="http://31.media.tumblr.com/avatar_151fcdb25b66_16.png" class="avatar " alt="" /></a><span class="action"><a rel="nofollow" href="http://scruffyinfant.tumblr.com/" title="はじめまして！！！" rel="nofollow">scruffyinfant</a> likes this</span><div class="clear"></div></li><li class="note reblog tumblelog_viraptor original_post without_commentary"><a rel="nofollow" class="avatar_frame" target="_blank" href="http://blog.viraptor.info/" title="Wild code"><img src="http://assets.tumblr.com/images/default_avatar_16.png" class="avatar " alt="" /></a><span class="action" data-post-url="http://blog.viraptor.info/post/44424140237"><a rel="nofollow" href="http://blog.viraptor.info/" class="tumblelog" title="Wild code">viraptor</a> posted this</span><div class="clear"></div></li><!-- END NOTES --></ol>
</div>
					
					
					
				</p>
			</div>
			
        </div>
        
        
        <p id="addresses" class="post-content">
            <em>
            Was it useful?<br>
            BTC: <a href="bitcoin:18AMX5sowkLoR78Lns7Qz7fEzSTVEqCpqS">18AMX5sowkLoR78Lns7Qz7fEzSTVEqCpqS</a><br>
            DOGE: <a href="dogecoin:DDYKHC6EBRxR7Ac2ByVLEuxmrhwo3xV3kk">DDYKHC6EBRxR7Ac2ByVLEuxmrhwo3xV3kk</a>
            </em>
        </p>
		</div><!--- End Container --->
		
    </div><!--- End Wrapper --->
    
	<div id="footer">
		<div id="footer-pat">
			<div id="header-end">
				<div id="footer-top"></div>
			</div>
			<div id="footer-bot">
				
				
				<div class="btn-prev"><a href="javascript:javascript:history.go(-1)">Back</a></div>
				
				<a href="http://www.goroboto.com" target="_blank" class="attribution bebas">A THEME BY GOROBOTO</a>
			</div>
		</div>
	</div>
	
	
    
    <script type="text/javascript">
		var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
		document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		</script>
		<script type="text/javascript">
		try {
		var pageTracker = _gat._getTracker("UA-260586-9");
		pageTracker._trackPageview();
		} catch(err) {}
	</script>
	
	

<!-- BEGIN TUMBLR CODE --><iframe scrolling="no" width="1" height="1" frameborder="0" style="background-color:transparent; overflow:hidden; position:absolute; top:0; left:0; z-index:9999;" id="ga_target"></iframe><script type="text/javascript">
    (function(){
        var analytics_frame = document.getElementById('ga_target');
        var analytics_iframe_loaded;
        var user_logged_in;
        var blog_is_nsfw = 'No';

        var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
        var eventer = window[eventMethod];
        var messageEvent = eventMethod == "attachEvent" ? "onmessage" : "message";
        eventer(messageEvent,function(e) {
            var message = (e.data && e.data.split) ? e.data.split(';') : '';
            switch (message[0]) {
                case 'analytics_iframe_loaded':
                    analytics_iframe_loaded = true;
                    postCSMessage();
                    postGAMessage();
                    break;
                case 'user_logged_in':
                    user_logged_in = message[1];
                    postGAMessage();
                    break;
            }
        }, false);

        analytics_frame.src = "http://assets.tumblr.com/analytics.html?3e91d63d5994bffc6ac211967f138b2c#http://blog.viraptor.info";
        function postGAMessage() {
            if (analytics_iframe_loaded && user_logged_in) {
                var is_ajax = false;
                analytics_frame.contentWindow.postMessage(['tick_google_analytics', is_ajax, user_logged_in, blog_is_nsfw, '/post/44424140237/peek-and-poke-in-the-age-of-linux?route=%2Fpost%2F%3Aid%2F%3Asummary'].join(';'), analytics_frame.src.split('/analytics.html')[0]);
            }
        }
        function postCSMessage() {
            COMSCORE = true;
            analytics_frame.contentWindow.postMessage('enable_comscore;' + window.location, analytics_frame.src.split('/analytics.html')[0]);
        }
    })();
</script><script>
            var _qevents = _qevents || [];
            (function() {
                var s = document.createElement('script');
                var el = document.getElementsByTagName('script')[0];
                s.src = (document.location.protocol == "https:" ? "https://secure" : "http://edge") + ".quantserve.com/quant.js";
                el.parentNode.insertBefore(s, el);
            })();
        </script><script type="text/javascript">
            _qevents.push( { qacct: 'p-19UtqE8ngoZbM' } );
        </script><noscript><div style="display: none;"><img src="//pixel.quantserve.com/pixel/'p-19UtqE8ngoZbM'.gif" height="1" width="1" alt="Quantcast"/></div></noscript><script type="text/javascript">!function(s){s.src='http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoidXJsIiwidXJsIjoiaHR0cDpcL1wvYmxvZy52aXJhcHRvci5pbmZvXC9wb3N0XC80NDQyNDE0MDIzN1wvcGVlay1hbmQtcG9rZS1pbi10aGUtYWdlLW9mLWxpbnV4IiwicmVxdHlwZSI6MCwicm91dGUiOiJcL3Bvc3RcLzppZFwvOnN1bW1hcnkifQ==&U=JGDPACFHJM&K=ad20c61d9422f6493e675b4fbda2988259ea6233e3e80b7151576ea623e2e16c&R='.replace(/&R=[^&$]*/,'').concat('&R='+escape(document.referrer)).slice(0,2000).replace(/%.?.?$/,'');}(new Image());</script><noscript><img style="position:absolute;z-index:-3334;top:0px;left:0px;visibility:hidden;" src="http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoidXJsIiwidXJsIjoiaHR0cDpcL1wvYmxvZy52aXJhcHRvci5pbmZvXC9wb3N0XC80NDQyNDE0MDIzN1wvcGVlay1hbmQtcG9rZS1pbi10aGUtYWdlLW9mLWxpbnV4IiwicmVxdHlwZSI6MCwicm91dGUiOiJcL3Bvc3RcLzppZFwvOnN1bW1hcnkiLCJub3NjcmlwdCI6MX0=&U=JGDPACFHJM&K=9a429cb48d8263713dd05d1a1eab2608b9cdf9ba62e063b4a2a8752526e133c6&R="></noscript><script type="text/javascript">!function(s){s.src='http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoicG9zdCIsInVybCI6Imh0dHA6XC9cL2Jsb2cudmlyYXB0b3IuaW5mb1wvcG9zdFwvNDQ0MjQxNDAyMzdcL3BlZWstYW5kLXBva2UtaW4tdGhlLWFnZS1vZi1saW51eCIsInJlcXR5cGUiOjAsInJvdXRlIjoiXC9wb3N0XC86aWRcLzpzdW1tYXJ5IiwicG9zdHMiOlt7InBvc3RpZCI6IjQ0NDI0MTQwMjM3IiwiYmxvZ2lkIjoiOTM3MTkyNjQiLCJzb3VyY2UiOjMzfV19&U=OFKLCAAINH&K=cabc0a05e0d97b9428339d167a15e2dbd6768e825d57d6b4e8ddb1e2bf66e534&R='.replace(/&R=[^&$]*/,'').concat('&R='+escape(document.referrer)).slice(0,2000).replace(/%.?.?$/,'');}(new Image());</script><noscript><img style="position:absolute;z-index:-3334;top:0px;left:0px;visibility:hidden;" src="http://www.tumblr.com/impixu?T=1406129592&J=eyJ0eXBlIjoicG9zdCIsInVybCI6Imh0dHA6XC9cL2Jsb2cudmlyYXB0b3IuaW5mb1wvcG9zdFwvNDQ0MjQxNDAyMzdcL3BlZWstYW5kLXBva2UtaW4tdGhlLWFnZS1vZi1saW51eCIsInJlcXR5cGUiOjAsInJvdXRlIjoiXC9wb3N0XC86aWRcLzpzdW1tYXJ5IiwicG9zdHMiOlt7InBvc3RpZCI6IjQ0NDI0MTQwMjM3IiwiYmxvZ2lkIjoiOTM3MTkyNjQiLCJzb3VyY2UiOjMzfV0sIm5vc2NyaXB0IjoxfQ==&U=OFKLCAAINH&K=5073b20a8e5a811bcabf0d8ddbdae9f80a035f5b1f66d8cdb7972e2a037ad680&R="></noscript><script>
                    (function() {
                        var s = document.createElement('script');
                        var el = document.getElementsByTagName('script')[0];
                        s.src = ('https:' == document.location.protocol ? 'https://s' : 'http://l') + '.yimg.com/ss/rapid-3.18.1.js';
                        s.onload = function(){
                            var YAHOO = window.YAHOO;
                            if (YAHOO) {
                                var keys = {
                                    pd:'/post/:id/:summary',
                                    _li:0,
                                    b_id:93719264,
                                    i_rad:0,
                                    i_strm:0
                                };
                                var conf = {
                                                                        spaceid:1197716038,
                                    client_only:1,
                                    yql_enabled:false,
                                    keys:keys,
                                    nol:1
                                };
                                YAHOO.rapid = new YAHOO.i13n.Rapid(conf);
                            }
                        };
                        el.parentNode.insertBefore(s, el);
                    })();
                </script><iframe id="tumblr_controls" class="tumblr_controls" width="1" height="1" frameborder="0" scrolling="no" src="http://assets.tumblr.com/assets/html/iframe/o.html?_v=9e17aad297935c7fb478643c59604364#src=http%3A%2F%2Fblog.viraptor.info%2Fpost%2F44424140237%2Fpeek-and-poke-in-the-age-of-linux&amp;pid=44424140237&amp;rk=1xeuR4RJ&amp;lang=en_US&amp;name=viraptor&amp;avatar=http%3A%2F%2Fassets.tumblr.com%2Fimages%2Fdefault_avatar_64.png&amp;title=Wild+code&amp;url=http%3A%2F%2Fblog.viraptor.info%2F&amp;page_slide=slide"></iframe><div id="teaser_iframe_container" style="display:none;"><iframe scrolling="no" frameborder="0" src="http://www.tumblr.com/assets/html/iframe/teaser.html?_v=bfe495a8395cc4648dc91acfefafee5c#src=http%3A%2F%2Fblog.viraptor.info%2Fpost%2F44424140237%2Fpeek-and-poke-in-the-age-of-linux&amp;pid=44424140237&amp;rk=1xeuR4RJ&amp;lang=en_US&amp;name=viraptor&amp;avatar=http%3A%2F%2Fassets.tumblr.com%2Fimages%2Fdefault_avatar_64.png&amp;title=Wild+code&amp;url=http%3A%2F%2Fblog.viraptor.info%2F&amp;page_slide=slide" id="teaser_iframe" width="1" height="1"></iframe></div><script type="text/javascript">
    (function(Tumblr){
        var follow_iframe_initialized = false;
        if (Tumblr.FollowTeaser && Tumblr.PostMessageListener) {
            // Don't do anything until the first initialize event
            Tumblr.PostMessageListener.initialize(function(message, origin) {
                if (follow_iframe_initialized || message.length < 2) return;

                if (message[0] === 'follow_iframe' && message[1] === 'enable') {
                    Tumblr.FollowTeaser.current_page = 1;
                    Tumblr.FollowTeaser.infer_infinite_scroll = true;
                    Tumblr.FollowTeaser.create_from_tumblr_controls("http:\/\/assets.tumblr.com\/assets\/html\/iframe\/follow.html?_v=a52b0a29bf82ebeec459a1f647a24914");
                    Tumblr.FollowTeaser.scroll_listener(true);
                    follow_iframe_initialized = true;
                }
            });
        }
    })(this.Tumblr || (this.Tumblr = {}));
</script><!--[if IE]><script type="text/javascript">document.getElementById('tumblr_controls').allowTransparency=true;</script><![endif]--><!-- END TUMBLR CODE -->

</body>
</html>
